/**
 * @license
 * Copyright (c) 2014, 2022, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define(["ojs/ojcore-base","jquery","knockout","ojs/ojarraytreedataprovider","ojs/ojarraydataprovider","ojs/ojdataprovider","ojs/ojeventtarget","ojs/ojmap"],function(t,e,s,i,r,n,a,o){"use strict";t=t&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t,e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e,i=i&&Object.prototype.hasOwnProperty.call(i,"default")?i.default:i,r=r&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r,o=o&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o;class h{constructor(t,e,s,i){var r;this.dataProvider=t,this.sortComparator=e,this.sectionRenderer=s,this.options=i,this.GroupAsyncIterator=class{constructor(t,e,s,i){this._parent=t,this._baseIterable=e,this._dataprovider=s,this._params=i}next(){let t=0;this._parent._currentRootSection&&(t=Object.keys(this._parent._sections).indexOf(this._parent._currentRootSection));const e=this._parent._currentBaseOffset<t||this._parent._dataFetchComplete;return this._parent._getDataFromDataProvider(this._params,"root",e).then(t=>{if("error"===t)return Promise.reject("Fetch interrupted due to refresh event");this._parent._updateSectionIndex();const e=new this._parent.FetchByOffsetParameters(this._parent,this._parent._currentBaseOffset,this._params.size,this._params.sortCriteria,this._params.filterCriterion);return this._dataprovider.fetchByOffset(e).then(t=>{const e=t.results,s=e.map(t=>t.data),i=e.map(t=>t.metadata);for(let t=0;t<i.length;t++)i[t]=this._parent._getNodeMetadata(e[t].data),s[t]=this._parent.sectionRenderer(i[t].key);return this._parent._currentBaseOffset=this._parent._currentBaseOffset+s.length,t.done&&this._parent._dataFetchComplete&&0===s.length?Promise.resolve(new this._parent.AsyncIteratorReturnResult(this._parent,new this._parent.FetchListResult(this._parent,this._params,s,i))):Promise.resolve(new this._parent.AsyncIteratorYieldResult(this._parent,new this._parent.FetchListResult(this._parent,this._params,s,i)))})})}},this.TreeAsyncIterator=class{constructor(t,e,s,i,r){this._parent=t,this._isParentSection=e,this._parentKey=s,this._dataprovider=i,this._params=r,this._parent._registerIteratorOffset(this,this._parentKey,0)}next(){const t=this._parent._getIteratorOffset(this),e=new this._parent.FetchByOffsetParameters(this._parent,t.offset,this._params.size,this._params.sortCriteria,this._params.filterCriterion),s=this._parent._sections[this._parentKey].children().length-t.offset>0,i=s||this._parent._dataFetchComplete;return this._parent._getDataFromDataProvider(this._params,this._parentKey,i).then(i=>"error"===i?Promise.reject("Fetch interrupted due to refresh event"):(void 0===i&&this._parent._updateSectionIndex(),this._dataprovider.fetchByOffset(e).then(e=>{const i=e.results;let r=e.done;const n=i.map(t=>t.data),a=i.map(t=>this._parent._getNodeMetadata(t.data));if(this._isParentSection)for(let t=0;t<a.length;t++)n[t]=this._parent.sectionRenderer(a[t].key);if(this._parent._updateIteratorOffset(this,t.offset+n.length),s&&r){this._parent._sections[this._parentKey].next||(r=!1)}return r&&0===n.length?Promise.resolve(new this._parent.AsyncIteratorReturnResult(this._parent,new this._parent.FetchListResult(this._parent,this._params,n,a))):Promise.resolve(new this._parent.AsyncIteratorYieldResult(this._parent,new this._parent.FetchListResult(this._parent,this._params,n,a)))})))}},this.TreeAsyncIterable=(r=class{constructor(t,e){this._parent=t,this._asyncIterator=e,this[Symbol.asyncIterator]=()=>this._asyncIterator}},Symbol.asyncIterator,r),this.FetchListParameters=class{constructor(t,e,s,i){this._parent=t,this.size=e,this.sortCriteria=s,this.attributes=i,this.size=e,this.sortCriteria=s,this.attributes=i}},this.FetchByOffsetParameters=class{constructor(t,e,s,i,r){this._parent=t,this.offset=e,this.size=s,this.sortCriteria=i,this.filterCriterion=r,this.size=s,this.sortCriteria=i,this.offset=e,this.filterCriterion=r}},this.FetchListResult=class{constructor(t,e,s,i){this._parent=t,this.fetchParameters=e,this.data=s,this.metadata=i,this.fetchParameters=e,this.data=s,this.metadata=i}},this.AsyncIteratorYieldResult=class{constructor(t,e){this._parent=t,this.value=e,this.value=e,this.done=!1}},this.AsyncIteratorReturnResult=class{constructor(t,e){this._parent=t,this.value=e,this.value=e,this.done=!0}},this._dataProvider=t,this._addEventListeners(this._dataProvider),this._initialize()}containsKeys(t){return this.fetchByKeys(t).then(e=>{const s=new Set;return t.keys.forEach(t=>{null!=e.results.get(t)&&s.add(t)}),Promise.resolve({containsParameters:t,results:s})})}getCapability(t){return"filter"===t?null:this._baseDataProvider.getCapability(t)}getTotalSize(){return this._baseDataProvider.getTotalSize()}isEmpty(){return this._baseDataProvider.isEmpty()}getChildDataProvider(t){const s=this._getChildren(t),n=this._isParentSection(t);class a{constructor(t,s,n){this.parent=t,this.sections=s,this.params=n,this.containsKeys=function(t){return this._baseTreeDataProvider.containsKeys(t)},this.getCapability=function(t){return this._baseTreeDataProvider.getCapability(t)},this.getTotalSize=function(){return this._baseTreeDataProvider.getTotalSize()},this.isEmpty=function(){return this._baseTreeDataProvider.isEmpty()},this.fetchByOffset=function(t){return this._baseTreeDataProvider.fetchByOffset(t)},this.fetchByKeys=function(t){return this._baseTreeDataProvider.fetchByKeys(t)},this.getChildDataProvider=function(t,e){return this._parent.getChildDataProvider(t)},this.fetchFirst=function(t){t&&t.filterCriterion&&((t=e.extend({},t)).filterCriterion=null);const s=this._baseDataProvider,i=this._isParentSection,r=this._parentKey;return this._parent._getTreeIterator(i,r,s,t)},this._getId=function(t){return this._parent._getId(t)},this._parent=t,this._parentKey=n.parentKey,this._isParentSection=n.isParentSection,this._isParentSection?(this._baseDataProvider=new r(s.childData,{}),this._baseTreeDataProvider=new i(s.childData,{keyAttributes:n.keyAttributes})):(this._baseDataProvider=new r(s.children,{keyAttributes:n.keyAttributes}),this._baseTreeDataProvider=new i(s.children,{keyAttributes:n.keyAttributes}))}}return s?new a(this,this._sections[t],{keyAttributes:this._getKeyAttribute(),parentKey:t,isParentSection:n}):null}fetchFirst(t){t&&t.filterCriterion&&((t=e.extend({},t)).filterCriterion=null);const s=this._baseDataProvider.fetchFirst(t);return this._initializeTreeCache(),this._getGroupIterator(s,this._baseDataProvider,t)}fetchByOffset(t){return this._baseDataProvider.fetchByOffset(t).then(t=>{const e=t.results,s=[];for(const t of e){const e=t.data,i=this._getNodeMetadata(e);s.push({data:e,metadata:i})}return{done:t.done,fetchParameters:t.fetchParameters,results:s}})}fetchByKeys(t){const e=new Map;return t.keys.forEach(t=>{const s=this._getNodeForKey(t);s&&e.set(t,{metadata:{key:t},data:s})}),Promise.resolve({fetchParameters:t,results:e})}_getTreeIterator(t,e,s,i){return new this.TreeAsyncIterable(this,new this.TreeAsyncIterator(this,t,e,s,i))}_getGroupIterator(t,e,s){return new this.TreeAsyncIterable(this,new this.GroupAsyncIterator(this,t,e,s))}_getChildren(t){return this._sections[t]?this._sections[t].children:null}_isParentSection(t){if(t in this._sections){const e=this._sections[t];if(e&&e.children().length>0&&this._sections[e.children()[0]])return!0}return!1}_initialize(){this._mapKeyToNode=new Map,this._mapNodeToKey=new o,this._sections={},this._sectionRoots=s.observableArray(),this._sectionRootData=s.observableArray(),this._dataFetchComplete=!1,this._internalIterator=null,this.treeData=s.observableArray([]),this._initializeTreeCache(),this._createSections(),this._storedAddSection=[],this._storedAddSectionKeys=[],this._storedRemoveSection=[],this._baseDataProvider=null,this._processSectionsArray([])}_initializeTreeCache(){this._treeKeyMap=[],this._treeMetadata=[],this._treeData=[],this._currentFirstSection=null,this._currentSectionKey=null,this._currentRootSection=null,this._currentSectionData=[],this._currentOffset=0,this._currentBaseOffset=0,this._iteratorOffsets=new Map,this._dataFetchComplete=!1,this._internalIterator=null}_registerIteratorOffset(t,e,s){this._iteratorOffsets.set(t,{parentKey:e,offset:s})}_getIteratorOffset(t){return this._iteratorOffsets.get(t)}_updateIteratorOffset(t,e){const s=this._iteratorOffsets.get(t);s.offset=e,this._iteratorOffsets.set(t,s)}_getRootDataProvider(){return this}_getDataFromDataProvider(t,e,s){if(!this._inCurrentFetchingSection(e)||s)return Promise.resolve("skip");let i=this._internalIterator;return this._internalIterator||(i=this._dataProvider.fetchFirst(t)[Symbol.asyncIterator](),this._internalIterator=i,this._previousTotalSize=0,this._internalIteratorCacheLength=0),this._previousTotalSize!==this._treeData.length&&(this._internalIteratorCacheLength=0),new Promise(t=>{this._internalIteratorResolve=t;const e=(t,s)=>this._internalIterator.next().then(i=>{if(null!=this._internalIterator&&this._internalIterator===s){if(this._treeData=this._treeData.concat(i.value.data),this._treeMetadata=this._treeMetadata.concat(i.value.metadata),i.value.metadata.forEach(t=>{this._treeKeyMap.push(t.key)}),t+=i.value.data.length,i.done?this._dataFetchComplete=!0:this._dataFetchComplete=!1,!(i.done||t>=i.value.fetchParameters.size))return e(t,s);{const e=t-i.value.fetchParameters.size;this._internalIteratorCacheLength=Math.max(0,e),this._previousTotalSize=this._treeData.length,this._internalIteratorResolve(void 0),this._internalIteratorResolve=null}}});return e(this._internalIteratorCacheLength,i)})}_inCurrentFetchingSection(t){return"root"===t||this._currentSectionKey===t}_processSectionsArray(e){this._baseDataProvider||(this._baseDataProvider=new t.ArrayDataProvider(this.treeData,null))}_processNode(t,e,s){const i={key:null,keyPath:null};return i.key=s,i.keyPath=e,i.keyPath.push(s),this._setMapEntry(i.key,t),i}_createSections(){if(this.options&&this.options.groupByStrategy)"function"==typeof this.options.groupByStrategy?this._groupingFunction=this.options.groupByStrategy:"string"==typeof this.options.groupByStrategy&&(this._groupingFunction=t=>this._getVal(t,this.options.groupByStrategy));else{const t=[],e=new Date(Date.now());t.push(e);let s=new Date(Date.now());const i=s.setDate(e.getDate()-1),r=s.setDate(e.getDate()-7);t.push(i),t.push(r),s=new Date(Date.now());const n=s.setMonth(e.getMonth()-1);t.push(n),s=new Date(Date.now());const a=s.setFullYear(e.getFullYear()-1);t.push(a),this._groupingFunction=e=>{const s=["In the past day","In the past week","In the past month","In the past year","Earlier"];if(e&&e.date){const i=new Date(e.date);let r=1;for(;i<t[r]&&5!==r;)r++;return[s[r-1]]}return["Section 1"]}}this.treeData&&this.treeData.valueHasMutated()}_getSectionKeyFromArray(t){if(t){if(Array.isArray(t)&&t.length>0)return t[t.length-1];if("string"==typeof t)return t}return null}_insertSection(t,e,i){const r={parent:t.parentKey,key:t.newKey,children:s.observableArray([]),childData:s.observableArray([]),previous:t.previousKey,next:t.nextKey,previousLeaf:e.previousLeaf,nextLeaf:e.nextLeaf,depth:i,active:!0};this._sections[t.newKey]=r,this._sections[t.newKey].index=function(){const t=r.parent,e=r.key;return null!=t?this._sections[t].children.indexOf(e):this._sectionRoots.indexOf(e)}.bind(this),this._sections[t.newKey].cutoffIndex=function(){const t=r.key;return this._getCutoffIndex(this._sections[t].previousLeaf)+this._sections[t].children().length}.bind(this)}_createNewSection(t,e,s,i,r){const a=s.indexOf(t);let o,h,c=null;0!==a&&(c=s[a-1]);let l=null,_=null;const d=a===this._getDepth(s);let u=!1;d&&(l=i,_=r),null!=c?(c in this._sections&&this._sections[c].active||(this._createNewSection(c,e,s,i,r),e&&(e=!1)),o=this._sections[c].children,h=this._sections[c].childData):(o=this._sectionRoots,h=this._sectionRootData,u=!0);let p=null;if(null==r)if(null==i)o().length>0&&(i=o()[o().length-1],d&&(l=i)),o.push(t),h.push(this.sectionRenderer(t));else{for(p=this._sections[i];p.depth>a;)p=this._sections[this._sections[i].parent];if(p.depth===a){i=p.key;const e=o.indexOf(i);e>=0?(o.splice(e+1,0,t),h.splice(e+1,0,this.sectionRenderer(t))):(o.push(t),h.push(this.sectionRenderer(t))),r=p.next}else i=null,r=null,o.push(t),h.push(this.sectionRenderer(t))}else{let e=this._sections[r];for(;e.depth>a;)e=this._sections[this._sections[r].parent];if(e.depth===a){r=e.key;const s=o.indexOf(r);s>=0?(o.splice(s,0,t),h.splice(s,0,this.sectionRenderer(t))):(o.push(t),h.push(this.sectionRenderer(t))),i=e.previous}else i=null,r=null,o.push(t),h.push(this.sectionRenderer(t))}t in this._sections?(this._sections[t].active=!0,this._sections[t].previous=i,this._sections[t].next=r,this._sections[t].previousLeaf=l,this._sections[t].nextLeaf=_,this._sections[t].parent=c):this._insertSection({newKey:t,parentKey:c,previousKey:i,nextKey:r},{previousLeaf:l,nextLeaf:_},a),null!=i&&(this._sections[i].next=t),null!=r&&(this._sections[r].previous=t),a===this._getDepth(s)&&(null!=l&&(this._sections[l].nextLeaf=t),null!=_&&(this._sections[_].previousLeaf=t)),a!==this._getDepth(s)||r!=this._currentFirstSection&&null!=this._currentFirstSection||(this._currentFirstSection=t);let f=null;null!=r&&(f=[r]);const y=this.sectionRenderer(t);if(this._processNode(y,[],t),e&&-1===this._storedAddSectionKeys.indexOf(this._sections[t].parent)){const e=t,s={key:t},i=this._sections[t].index(),r={data:[y],indexes:[i],keys:new Set([e]),metadata:[s],addBeforeKeys:f,parentKeys:[c]},a=new n.DataProviderMutationEvent({add:r,remove:null,update:null});if(this._storedAddSection.push(a),this._storedAddSectionKeys.push(t),!this._dataFetchComplete&&u&&this._currentBaseOffset>i&&this._currentBaseOffset++,!this._dataFetchComplete)for(const[t,e]of this._iteratorOffsets)e.parentKey===c&&e.offset>i&&e.offset++,this._updateIteratorOffset(t,e.offset)}this.treeData.valueHasMutated()}_removeSection(t){const e=this._sections[t],s=e.parent,i=e.previous,r=e.next,a=e.previousLeaf,o=e.nextLeaf;let h=!0;if(this._sections[r]&&this._sections[r].previous===t&&(this._sections[r].previous=e.previous),this._sections[i]&&this._sections[i].next===t&&(this._sections[i].next=e.next),this._sections[o]&&this._sections[o].previousLeaf===t&&(this._sections[o].previousLeaf=e.previousLeaf),this._sections[a]&&this._sections[a].nextLeaf===t&&(this._sections[a].nextLeaf=e.nextLeaf),this._sections[s]&&-1!==this._sections[s].children.indexOf(t)){const e=this._sections[s].children.indexOf(t);if(!this._dataFetchComplete)for(const[t,i]of this._iteratorOffsets)i.parentKey===s&&i.offset>e&&i.offset--,this._updateIteratorOffset(t,i.offset);this._sections[s].children.splice(e,1),this._sections[s].childData.splice(e,1),0===this._sections[s].children().length&&(this._removeSection(s),h&&(h=!1))}if(this._sections[t].active=!1,this._sections[t].children([]),this._sections[t].childData([]),null==this._sections[t].parent){const e=this._sectionRoots.indexOf(t);this._sectionRoots.splice(e,1),this._sectionRootData.splice(e,1),!this._dataFetchComplete&&this._currentBaseOffset>e&&this._currentBaseOffset--}if(t===this._currentFirstSection&&(this._currentFirstSection=r),h){const e={key:t},s={data:[this.sectionRenderer(t)],indexes:null,keys:new Set([t]),metadata:[e]},i=new n.DataProviderMutationEvent({add:null,remove:s,update:null});this._storedRemoveSection.push(i)}this.treeData.valueHasMutated()}_updateSectionIndex(){for(let t=this._currentOffset;t<this._treeData.length;t++){const e=this._treeData[t],s=this._treeKeyMap[t];this._processNode(e,[],s);const i=this._groupingFunction(e),r=this._getSectionKeyFromArray(i);null==this._currentSectionKey&&(r in this._sections||this._createNewSection(r,!1,i,this._currentSectionKey,null),this._currentSectionKey=r,this._currentRootSection=this._getSectionArray(i)[0]),r===this._currentSectionKey?this._currentSectionData.push(e):(r in this._sections&&this._sections[r].active||this._createNewSection(r,!1,i,this._currentSectionKey,null),this._sections[this._currentSectionKey].children(this._currentSectionData),this._sections[this._currentSectionKey].childData(this._getChildDataFromChildren(this._currentSectionKey)),this._currentSectionKey=r,this._currentRootSection=this._getSectionArray(i)[0],this._currentSectionData=[e]),this._currentOffset++}this._currentSectionData.length>0&&(this._sections[this._currentSectionKey].children(this._currentSectionData),this._sections[this._currentSectionKey].childData(this._getChildDataFromChildren(this._currentSectionKey)));const t=[];for(const e in this._sections)null==this._sections[e].parent&&t.push(this.sectionRenderer(e));this.treeData(t),this.treeData.valueHasMutated()}_getSectionArray(t){return Array.isArray(t)?t:[t]}_getChildDataFromChildren(t){const e=[];return this._sections[t].children().forEach(t=>{e.push(this.sectionRenderer(t))}),e}_getKeyAttribute(){let t=null!=this.options?this.options.keyAttributes:null;return t||(t="id"),t}_getId(t){let e,s=null!=this.options?this.options.keyAttributes:null;if(s||(s="id"),null!=s){if(Array.isArray(s)){let i;for(e=[],i=0;i<s.length;i++)e[i]=this._getVal(t,s[i])}else e="@value"===s?this._getAllVals(t):this._getVal(t,s);return e}return null}_getDepth(t){return Array.isArray(t)?t.length-1:0}_getVal(t,e,s=!1){if("string"==typeof e){const s=e.indexOf(".");if(s>0){const i=e.substring(0,s),r=e.substring(s+1),n=t[i];if(n)return this._getVal(n,r)}}return!0!==s&&"function"==typeof t[e]?t[e]():t[e]}_getAllVals(t){return Object.keys(t).map(e=>this._getVal(t,e))}_getNodeMetadata(t){let e=this._getKeyForNode(t);return null==e&&(e=this._getId(t)),{key:e}}_getNodeForKey(t){return this._getRootDataProvider()._mapKeyToNode.get(JSON.stringify(t))}_getKeyForNode(t){return this._getRootDataProvider()._mapNodeToKey.get(t)}_setMapEntry(t,e){const s=this._getRootDataProvider();s._mapKeyToNode.set(JSON.stringify(t),e),s._mapNodeToKey.set(e,t)}_addData(t){const e=t.data,s=t.metadata;let i=t.addBeforeKeys;const r=t.indexes,n=[];if(t.keys.forEach(t=>{n.push(t)}),null!=r&&r.length>0){const t=r.slice(0).sort();for(const i of t){const t=r.indexOf(i);this._treeData.splice(i,0,e[t]),this._treeMetadata.splice(i,0,s[t]),this._treeKeyMap.splice(i,0,n[t])}if(null==i||0===i.length){i=[];for(const t of r){const e=t+1<this._treeKeyMap.length?this._treeKeyMap[t+1]:null;i.push(e)}}}else{const t=[],r=[],a=[];let o=0,h=!1;e.forEach((e,i)=>{if(h=!1,0!==t.length)for(;o<t.length&&!h;)this.sortComparator(e,t[o])?(t.splice(o,0,e),r.splice(o,0,s[i]),a.splice(o,0,n[i]),h=!0):o++;h||(t.push(e),r.push(s[i]),a.push(n[i]))}),o=this._treeData.length-1;const c={};t.forEach((t,e)=>{const s=t,i=r[e],n=a[e];for(h=!1;o>=0&&!h;)this.sortComparator(s,this._treeData[o])?(o+1!==this._treeData.length?(this._treeData.splice(o+1,0,s),this._treeMetadata.splice(o+1,0,i),c[this._getId(s)]=this._treeKeyMap[o+1],this._treeKeyMap.splice(o+1,0,n)):(this._treeData.push(s),this._treeMetadata.push(i),c[this._getId(s)]=null,this._treeKeyMap.push(n)),h=!0):o--;h||(this._treeData.splice(0,0,s),this._treeMetadata.splice(0,0,i),c[this._getId(s)]=this._treeKeyMap[0],this._treeKeyMap.splice(0,0,n),o=0)}),i=[],e.forEach(t=>{i.push(c[this._getId(t)])})}return i}_handleAdd(t){const e=[],s=this._addData(t);t.addBeforeKeys&&0!==t.addBeforeKeys.length||(t.addBeforeKeys=s),t.keys.forEach(i=>{const r=e.length,n=t.data[r],a=s[r];e.push({addBeforeKey:a,key:i,data:n})});const i=[],r=[],n=[],a=this._getIndexFromKeys(t.keys);if(t.indexes&&0!==t.indexes.length||(t.indexes=[]),t.data.forEach((s,o)=>{this._processNode(s,[],e[o].key);const h=this._groupingFunction(s);let c,l,_=this._getSectionKeyFromArray(h);_ in this._sections&&this._sections[_].active?-1===r.indexOf(_)&&n.push(o):(0!==a[o]?(c=this._getSectionKeyFromArray(this._groupingFunction(this._treeData[a[o]-1])),l=this._sections[c].nextLeaf):c=null,a[o]+1<this._treeData.length&&null==c&&(l=this._currentFirstSection),this._createNewSection(_,!0,h,c,l),_=this._getSectionKeyFromArray(h),r.push(_));const d=this._sections[_].children,u=this._sections[_].childData;c=this._sections[_].previousLeaf;let p=0;if(null!=c&&(p=this._sections[c].cutoffIndex()),d.splice(a[o]-p,0,s),u.splice(a[o]-p,0,this.sectionRenderer(s)),i.push(_),t.indexes[o]=a[o]-p,null!=t.addBeforeKeys[o]&&o===t.data.length-1){this._getSectionKeyFromArray(this._groupingFunction(this._treeData[this._treeKeyMap.indexOf(t.addBeforeKeys[o])]))!==_&&(t.addBeforeKeys[o]=null)}}),t.parentKeys=i,r.length>0){let e=0;const s=[],i=[],r=[],a=[],o=[],h=[];t.keys.forEach(c=>{-1!==n.indexOf(e)&&(i.push(c),s.push(t.data[e]),r.push(t.metadata[e]),a.push(t.parentKeys[e]),o.push(t.indexes[e]),h.push(t.addBeforeKeys[e])),e++}),t=i.length>0?{data:s,keys:new Set(i),metadata:r,parentKeys:a,indexes:o,addBeforeKeys:h}:null}return t}_handleRemove(t){const e=this._getIndexFromKeys(t.keys);this._removeKeys(t.keys);const s=[],i=[];for(const t of e){const e=this._treeData[t],r=this._treeKeyMap[t],n=this._mapKeyToNode.get(JSON.stringify(r));this._mapKeyToNode.delete(JSON.stringify(r)),this._mapNodeToKey.delete(n);const a=this._getSectionKeyFromArray(this._groupingFunction(e)),o=this._sections[a].previousLeaf;let h=0;null!=o&&(h=this._sections[o].cutoffIndex()),s.push({ind:t-h,sectionId:a}),i.push(t)}s.sort((t,e)=>e.ind-t.ind),i.sort((t,e)=>e-t);for(let t=0;t<s.length;t++){const e=s[t].sectionId,r=this._sections[e].children;r.splice(s[t].ind,1),0===r().length&&this._removeSection(e),this._treeData.splice(i[t],1),this._treeMetadata.splice(i[t],1)}}_handleUpdate(t){const e=this._getIndexFromKeys(t.keys);t.data.forEach((t,s)=>{const i=e[s],r=this._treeData[i],n=this._treeKeyMap[i],a=this._mapKeyToNode.get(JSON.stringify(n));this._mapNodeToKey.delete(a),this._setMapEntry(n,r);const o=this._getSectionKeyFromArray(this._groupingFunction(r)),h=this._sections[o].children,c=this._sections[o].previousLeaf;let l=0;null!=c&&(l=this._sections[c].cutoffIndex()),h.splice(i-l,1,t),this._treeData[i]=t})}_getCutoffIndex(t){return null!=t?this._sections[t].cutoffIndex():0}_getIndexFromKeys(t){const e=[];return t.forEach(t=>{e.push(this._treeKeyMap.indexOf(t))}),e}_removeKeys(t){t.forEach(t=>{this._treeKeyMap.splice(this._treeKeyMap.indexOf(t),1)})}_cleanEvent(t){const e=this._getIndexFromKeys(t.keys);let s=0;t.keys.forEach(i=>{-1===e[s]&&t.keys.delete(i),s++});for(let s=e.length-1;s>=0;s--)-1===e[s]&&(t.data&&t.data.splice(s,1),t.indexes&&t.indexes.splice(s,1),t.metadata&&t.metadata.splice(s,1));return t}_cleanAddEvent(t){const e=t.addBeforeKeys,s=t.indexes,i=[],r=[];if(t.keys.forEach(t=>{i.push(t)}),null!=s){const t=s.slice(0).sort();for(let e=0;e<t.length;e++){const i=t[e],n=s.indexOf(i);this._treeData.length+e-r.length<i&&r.push(n)}}else if(null!=e){const t=e.slice(0).sort();for(const s of t){const t=e.indexOf(s);null!=s?(-1===this._treeKeyMap.indexOf(s)&&-1===i.indexOf(s)||-1===this._treeKeyMap.indexOf(s)&&-1!==i.indexOf(s)&&-1===r.indexOf(i.indexOf(s)))&&r.push(t):this._dataFetchComplete||r.push(t)}}let n=0;t.keys.forEach(e=>{-1!==r.indexOf(n)&&t.keys.delete(e),n++});const a=r.splice(0).sort();for(let e=a.length-1;e>=0;e--)t.data&&t.data.splice(a[e],1),t.indexes&&t.indexes.splice(a[e],1),t.metadata&&t.metadata.splice(a[e],1),t.parentKeys&&t.parentKeys.splice(a[e],1),t.addBeforeKeys&&t.addBeforeKeys.splice(a[e],1);return t}_addEventListeners(t){t.addEventListener("refresh",t=>{this._initialize(),null!=this._internalIteratorResolve?(this._internalIteratorResolve("error"),this._internalIteratorResolve=null,window.requestAnimationFrame(()=>{this.dispatchEvent(new n.DataProviderRefreshEvent)})):this.dispatchEvent(new n.DataProviderRefreshEvent)}),t.addEventListener("mutate",t=>{t.detail.add&&(t.detail.add=this._cleanAddEvent(t.detail.add),0!==t.detail.add.keys.size&&(t.detail.add=this._handleAdd(t.detail.add),this._storedAddSection.forEach(t=>{this.dispatchEvent(t)}),t.detail.add&&this.dispatchEvent(t),this._storedAddSection=[],this._storedAddSectionKeys=[])),(t.detail.remove||t.detail.update)&&(t.detail.remove&&(t.detail.remove=this._cleanEvent(t.detail.remove),0!==t.detail.remove.keys.size&&(this._handleRemove(t.detail.remove),this.dispatchEvent(t))),t.detail.update&&(t.detail.update=this._cleanEvent(t.detail.update),0!==t.detail.update.keys.size&&(this._handleUpdate(t.detail.update),this.dispatchEvent(t)))),this._storedRemoveSection.forEach(t=>{this.dispatchEvent(t)}),this._storedRemoveSection=[]})}}return a.EventTargetMixin.applyMixin(h),t._registerLegacyNamespaceProp("GroupingDataProvider",h),h});
//# sourceMappingURL=ojgroupingdataprovider.js.map