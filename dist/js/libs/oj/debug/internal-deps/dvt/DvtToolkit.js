/**
 * Copyright (c) 2014, 2016, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 */
"use strict";
define([], function() {
  // Internal use only.  All APIs and functionality are subject to change at any time.

  // Declare dvt, since it will be used in the toolkit source.
  var dvt;

dvt = (function() {
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * Namespace for DVT toolkit.
 */
var dvt = {};

/**
 *  Exports a property on an object.
 *  @param {object} obj The object on which the property will be exported.
 *  @param {string} propertyName The property to be exported.
 *  @param {object} value The value of the property.
 */
dvt.exportProperty = function(obj, propertyName, value) {
  obj[propertyName] = value;
};

/**
 * Base object for HTML toolkit derivative objects.
 * @class The base object for HTML toolkit derivative objects.
 * @constructor
 */
dvt.Obj = function() {};

/** @private @const **/
dvt.Obj._GET_FUNCTION_NAME_REGEXP = /function\s+([\S^]+)\s*\(/;

/**
 *  Provides inheritance by subclassing a class from a given base class.
 *  @param  {class} extendingClass  The class to be extended from the base class.
 *  @param  {class} baseClass  The base class
 *  @param  {string} typeName The type of the extending class
 */
dvt.Obj.createSubclass = function(extendingClass, baseClass, typeName) {
  if (extendingClass === undefined || extendingClass === null) {
    return;
  }

  if (baseClass === undefined) {
    // assume Object
    baseClass = Object;
  }

  if (extendingClass == baseClass) {
    return;
  }

  // use a temporary constructor to get our superclass as our prototype
  // without out having to initialize the superclass
  var tempConstructor = dvt.Obj._tempSubclassConstructor;

  tempConstructor.prototype = baseClass.prototype;
  extendingClass.prototype = new tempConstructor();

  extendingClass.prototype.constructor = extendingClass;
  extendingClass.superclass = baseClass.prototype;

  if (typeName)
    extendingClass._typeName = typeName;
};

/**  @private  */
dvt.Obj._tempSubclassConstructor = function() {};

dvt.Obj.getTypeName = function(clazz) {
  var typeName = clazz._typeName;
  if (typeName == null) {
    var constructorText = clazz.toString();
    var matches = dvt.Obj._GET_FUNCTION_NAME_REGEXP.exec(constructorText);

    if (matches) {
      typeName = matches[1];
      clazz._typeName = typeName;
    }
  }

  return typeName;
};

dvt.Obj.prototype.getTypeName = function() {
  return dvt.Obj.getTypeName(this.constructor);
};

/**
  *  Returns a copy of this object.  Abstract method, subclasses
  *   must implement.
  *  @type {dvt.Obj}
  */
dvt.Obj.prototype.clone = function()
{
  return null;
};

/**
  *   Merge properties in the current object into the supplied object.
  *   Abstract method, subclasses must implement. Used internally by clone().
  *   @param {dvt.Obj}
  *   @private
  */
dvt.Obj.prototype.mergeProps = function(obj)
{
};

/**
  * Creates a callback function
  *
  * @param {object} thisPtr the object that should be "this" when the function is called
  * @param {function} func the function to create the callback for
  *
  * @return {function} the callback function
  */
dvt.Obj.createCallback = function(thisPtr, func) {
  return function() {
    return func.apply(thisPtr, arguments);
  };
};


//:
/**
 * Define a constant value such that the advanced closure compiler will not simply do an inline replace of the
 * value everywhere it's referenced.  The compiled code should then contain abbreviated references to the constant
 * instead of the literal value, which should help decrease overall code size.
 * @param {object} constValue value to define for the constant
 * @return {object}
 */
dvt.Obj.defineConstant = function(constValue) {
  return constValue;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Utilities for Arrays.
 * @class dvt.ArrayUtils  
 */
dvt.ArrayUtils = new Object();

dvt.Obj.createSubclass(dvt.ArrayUtils, dvt.Obj);

//  Factor scaling operation types for toFloat()


/**
  * Factor operation for dvt.ArrayUtils.toFloat() - no scaling of converted float.
  * @final
  */
dvt.ArrayUtils.NONE = 0;


/**
  * Factor operation for dvt.ArrayUtils.toFloat() - add factor to converted float.
  * @final
  */
dvt.ArrayUtils.ADD = 1;


/**
  * Factor operation for dvt.ArrayUtils.toFloat() - subtract factor from converted float.
  * @final
  */
dvt.ArrayUtils.SUB = 2;


/**
  * Factor operation for dvt.ArrayUtils.toFloat() - divide converted float by factor.
  * @final
  */
dvt.ArrayUtils.DIV = 3;


/**
  * Factor operation for dvt.ArrayUtils.toFloat() - multiply converted float by factor.
  * @final
  */
dvt.ArrayUtils.MULT = 4;


/**
  *  Factor operation for dvt.ArrayUtils.toFloat() - set converted float to mod(factor).
  * @final
  */
dvt.ArrayUtils.MOD = 5;



dvt.ArrayUtils.argsToArray = function(args)
{
  if (args)
  {
    var array = new Array(args.length);
    if (args.length > 0)
    {
      for (var i = 0; i < args.length; i++)
      {
        array[i] = args[i];
      }
    }
    return array;
  }
  return args;
};


/*--------------------------------------------------------------------*/
/*  isArray()          Cross-browser array detection                  */
/*--------------------------------------------------------------------*/
/**
  *   Test if the specified object is an instance of Array (cross-browser safe).
  * @base dvt.ArrayUtils
  *   @param {Object}  obj
  *   @type {Boolean}
  *   @return true if the object is an Array.
  */
dvt.ArrayUtils.isArray = function(obj)
{
  // check for undefined explicitly because the second clauses will blow up in Rhino
  return typeof obj != 'undefined' && Object.prototype.toString.apply(obj) === '[object Array]';
};


/*--------------------------------------------------------------------*/
/*  toFloat()                                                         */
/*--------------------------------------------------------------------*/
/**
  *  Converts an array from string values to floats.  If optional 'factor'
  *  argument is supplied, the array values are scaled by this factor using
  *  the factorType  operator. e.g. <p><code>
  *  &nbsp; &nbsp; &nbsp;  dvt.ArrayUtils.toFloat(ar, 0.01, dvt.ArrayUtils.MULT) ;<p></code>
  *  converts an array of percentage value strings to an array of floats converted
  *  to dcimal percentages (between zero and 1).
  *  @param {Array} ar
  *  @param {number} factor
  *  @param {number} factorType
  *  @type {Array}
  *  @return the Array that was supplied as the first argument.
  */
dvt.ArrayUtils.toFloat = function(ar, factor, factorType)
{
  if (! dvt.ArrayUtils.isArray(ar)) {
    return ar;
  }

  if (! factor) {
    factorType = dvt.ArrayUtils.NONE;
  }

  factorType = (factorType === null || isNaN(factorType)) ? dvt.ArrayUtils.NONE : factorType;

  if (factorType !== dvt.ArrayUtils.NONE) {
    if ((typeof factor) !== 'number') {
      factor = parseFloat(factor);
    }
    if (isNaN(factor)) {
      factorType = dvt.ArrayUtils.NONE;
    }
  }

  var len = ar.length;
  var i;

  if (factorType === dvt.ArrayUtils.NONE) {
    for (i = 0; i < len; i++) {
      ar[i] = parseFloat(ar[i]);
    }
  }
  else {
    for (i = 0; i < len; i++) {
      var v = parseFloat(ar[i]);

      switch (factorType) {
        case dvt.ArrayUtils.MULT: v *= factor;
        break;
        case dvt.ArrayUtils.ADD: v += factor;
        break;
        case dvt.ArrayUtils.SUB: v -= factor;
        break;
        case dvt.ArrayUtils.DIV: v /= factor;
        break;
        case dvt.ArrayUtils.MOD: v %= factor;
        break;
      }
      ar[i] = v;
    }

  }

  return ar;
};


/*--------------------------------------------------------------------*/
/*   copy()       Performs a shallow copy of the array. (Much faster  */
/*                than Array.concat().                                */
/*--------------------------------------------------------------------*/
/**
  *  Create a shallow copy of the supplied array.
  *  @param {Array} ar The array to be copied.
  *  @type {Array}
  *  @return A shallow copy of the supplied array.
  */
dvt.ArrayUtils.copy = function(ar)
{
  var arRet;

  if (ar) {
    arRet = [];
    var len = ar.length;

    for (var i = 0; i < len; i++) {
      arRet.push(ar[i]);
    }
  }
  return arRet;
};


/**
  *  Returns the index of the first occurrence of an item in an array.
  *  @param {Array} array  The array to be searched.
  *  @param {Object} item  The item to be found.
  *  @type {number}
  */
dvt.ArrayUtils.getIndex = function(array, item) 
{
  if (array) {
    if (array.indexOf)
      return array.indexOf(item);

    for (var i = 0; i < array.length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
  }
  return -1;
};

/**
  *  Returns the index of the last occurrence of an item in an array.
  *  @param {Array} array  The array to be searched.
  *  @param {Object} item  The item to be found.
  *  @type {number}
  */
dvt.ArrayUtils.getLastIndex = function(array, item) 
{
  if (array.lastIndexOf)
    return array.lastIndexOf(item);

  for (var i = array.length - 1; i >= 0; i--) {
    if (array[i] === item) {
      return i;
    }
  }
  return -1;
};

/**
 * Returns true if the two arrays have the same contents.
 * @param {array} a
 * @param {array} b
 */
dvt.ArrayUtils.equals = function(a, b) {
  if (!a && b)
    return false;
  else if (a && !b)
    return false;
  else if (!a && !b)
    return true;
  else // a && b
  {
    if (a.length != b.length)
      return false;

    // Compare the individual items
    for (var i = 0; i <= a.length; i++) {
      if (a[i] !== b[i])
        return false;
    }

    // Everything matched, return true
    return true;
  }
};

/**
 * Returns true if the specified map has any of the specified array items.
 * @param {Object} map The boolean map within which to look for the items.
 * @param {array} items The array of items to look for.
 * @return {boolean}
 */
dvt.ArrayUtils.hasAnyMapItem = function(map, items) {
  // Return false if either array is empty
  if (!map || !items)
    return false;

  // Look for each of the items
  for (var i = 0; i < items.length; i++) {
    if (map[items[i]])
      return true;
  }

  // No match found, return false
  return false;
};

/**
 * Returns true if the specified map has all of the specified array items.
 * @param {Object} map The boolean map within which to look for the items.
 * @param {array} items The array of items to look for.
 * @return {boolean}
 */
dvt.ArrayUtils.hasAllMapItems = function(map, items) {
  // Return true if the items array is empty
  if (!map || !items)
    return false;

  // Look for each of the items
  for (var i = 0; i < items.length; i++) {
    if (!map[items[i]])
      return false;
  }

  // No missing items found, return true
  return true;
};

/**
 * Returns true if the specified array has any of the specified items.
 * @param {array} array The array within which to look for the items.
 * @param {array} items The array of items to look for.
 * @return {boolean}
 */
dvt.ArrayUtils.hasAnyItem = function(array, items) {
  return dvt.ArrayUtils.hasAnyMapItem(dvt.ArrayUtils.createBooleanMap(array), items);
};

/**
 * Returns true if the specified array has all of the specified items.
 * @param {array} array The array within which to look for the items.
 * @param {array} items The array of items to look for.
 * @return {boolean}
 */
dvt.ArrayUtils.hasAllItems = function(array, items) {
  return dvt.ArrayUtils.hasAllMapItems(dvt.ArrayUtils.createBooleanMap(array), items);
};

/**
 * Creates and returns a map whose keys are the items in the specified array. This map will return true if index by an
 * item in the array.
 * @param {array} array
 * @return {object}
 */
dvt.ArrayUtils.createBooleanMap = function(array) {
  if (!array)
    return null;

  var ret = {};
  for (var i = 0; i < array.length; i++) {
    ret[array[i]] = true;
  }
  return ret;
};

/**
 * Applies a function against an accumulator and each value of the array (from left-to-right) to reduce it to a single value.
 * @param {array} array The array to apply reduce function to
 * @param {function} callback The function to apply
 * @return {Object}
 */
dvt.ArrayUtils.reduce = function(array, callback) {
  if (array.reduce)
    return array.reduce(callback);

  var len = array.length;
  var val = array[0];
  for (var i = 1; i < len; i++)
    val = callback(val, array[i], i, array);
  return val;
};

/**
 * Creates a new array with the results of calling a provided function on every element in this array.
 * @param {array} array The array to apply map function to
 * @param {function} callback The function to apply
 * @return {array}
 */
dvt.ArrayUtils.map = function(array, callback) {
  if (array.map)
    return array.map(callback);

  var len = array.length;
  var ar = [];
  for (var i = 0; i < len; i++)
    ar[i] = callback(array[i], i, array);

  return ar;
};

/**
 * Executes a provided function once per array element
 * @param {array} array The array to apply map function to
 * @param {function} callback The function to apply
 */
dvt.ArrayUtils.forEach = function(array, callback) {
  if (array.map) {
    array.forEach(callback);
  } else {
    var len = array.length;
    for (var i = 0; i < len; i++)
      callback(array[i], i, array);
  }
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Utilities for Strings.
 * @class dvt.StringUtils
 */
dvt.StringUtils = {};

dvt.Obj.createSubclass(dvt.StringUtils, dvt.Obj);

/**
 * Perform a check to see if native String APIs is available, since they are much faster.
 * @private
 */
dvt.StringUtils._hasTrim = 'hello'.trim != null;

/**
 * Perform a check to see if native String APIs is available, since they are much faster.
 * @private
 */
dvt.StringUtils._hasEndsWith = 'hello'.endsWith != null;

/**
 * Removes leading and trailing whitespace from a string.
 * @param {string} s  The string to be trimmed.
 * @return {string} A string with leading and trailing whitespace removed.
 */
dvt.StringUtils.trim = function(s)
{
  if (dvt.StringUtils._hasTrim)
    return s.trim();
  else
    return s.replace(/^\s+|\s+$/g, '');
};


/**
 * Returns true if the specified string ends with the specified suffix.
 * @param {string} s The string to check.
 * @param {string} suffix The suffix that the search string should end with.
 * @return {boolean}
 */
dvt.StringUtils.endsWith = function(s, suffix)
{
  if (dvt.StringUtils._hasEndsWith)
    return s.endsWith(suffix);
  else
    return (s.match(suffix + '$') == suffix);
};

/**
 * Returns a processed aria label where all supported HTML formatting characters are removed.
 * @param {string} label
 * @return {string}
 */
dvt.StringUtils.processAriaLabel = function(label) {
  var ret = label;

  // Make all brackets consistent to simplify later searches
  ret = ret.replace(/(<|&#60;)/g, '&lt;');
  ret = ret.replace(/(>|&#62;)/g, '&gt;');

  // Strip out bold and italic tags
  ret = ret.replace(/&lt;b&gt;/g, '');
  ret = ret.replace(/&lt;\/b&gt;/g, '');
  ret = ret.replace(/&lt;i&gt;/g, '');
  ret = ret.replace(/&lt;\/i&gt;/g, '');

  // Replace logical newlines sequences with semicolons
  ret = ret.replace(/\n/g, '; ');
  ret = ret.replace(/&#92;n/g, '; ');
  ret = ret.replace(/&lt;br&gt;/g, '; ');
  ret = ret.replace(/&lt;br\/&gt;/g, '; ');

  return ret;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Context object corresponding to an SVG document. The constructor creates a SVG document inside the specified
 * container.
 * @param {Element} container The div element under which the SVG document will be created.
 * @param {string} id
 * @param {Element=} referenceDiv An optional div element to use as a reference point for calculating the absolute
 *                                 position of the stage.
 * @extends {dvt.Obj}
 * @class dvt.Context
 * @constructor
 */
dvt.Context = function(container, id, referenceDiv) {
  // Create the SVG document and add to the container
  var svgId = id ? id + '_svg' : null;
  this._root = dvt.ToolkitUtils.createSvgDocument(svgId);
  container.appendChild(this._root);//@HTMLUpdateOK

  // Save a reference to the svg element's parent div for updating the active descendent needed for accessibility
  this._parentDiv = container;

  // Store a reference to the div used for calculating the absolute position of the stage.
  this._referenceDiv = referenceDiv;

  // Create the impl factory, defs, and stage
  this._implFactory = new DvtSvgImplFactory(this);
  this._defs = this._implFactory.newDefs();
  dvt.ToolkitUtils.appendChildElem(this._root, this._defs);

  this._keyboardFocusArray = [];
  this._keyboardFocusIndex = 0;

  this.Init(this._implFactory, this._root, id);

  // Add the stage element
  dvt.ToolkitUtils.appendChildElem(this._root, this._stage.getElem());
};

dvt.Obj.createSubclass(dvt.Context, dvt.Obj);


/**
 * @const
 * @private
 */
dvt.Context._DATATIP_POPUP_STYLE_CLASS = 'OraDVTDatatipPopup';
/**
 * @const
 * @private
 */
dvt.Context._TOOLTIP_POPUP_STYLE_CLASS = 'OraDVTTooltipPopup';

/** @private @const */
dvt.Context._DEFAULT_FONT_FAMILY = '\'Helvetica Neue\', Helvetica, Arial, sans-serif';

/** @private */
dvt.Context._DEFAULT_FONT_FAMILIES = {'\'Helvetica Neue\', Helvetica, Arial, sans-serif': true,
  '"Helvetica Neue", Helvetica, Arial, sans-serif': true,
  '"Helvetica Neue",Helvetica,Arial,sans-serif': true};

/** @private @const */
dvt.Context._DEFAULT_FONT_SIZE = '12px';

/** @private */
dvt.Context._id = 0;

/**
  * Initializes this context object with the platform dependent objects.
  * @param  {DvtSvgImplFactory} implFactory
  * @param  {DOMElement} root
  * @param  {string} id
  * @protected
  */
dvt.Context.prototype.Init = function(implFactory, root, id) {
  this._implFactory = implFactory;

  var stageId = (id ? id : '_dvt' + dvt.Context._id) + '_stage';
  this._stage = new DvtStage(this, root, stageId);     // TODO use naming utils
  dvt.Context._id++;

  // Apply the default font properties to the stage for inheritance
  dvt.ToolkitUtils.setAttrNullNS(this._stage.getElem(), 'font-family', this.getDefaultFontFamily());
  dvt.ToolkitUtils.setAttrNullNS(this._stage.getElem(), 'font-size', this.getDefaultFontSize());

  this._tooltipManagers = new Object();
  this._customTooltipManagers = new Object();

  this._scheduler = null;

  //: map of dvt.ClipPath objects stored by id
  this._globalDefsMap = {};
};

/**
 * Returns the default CSS font family that is applied to the stage.
 * @return {string}
 */
dvt.Context.prototype.getDefaultFontFamily = function() {
  return dvt.Context._DEFAULT_FONT_FAMILY;
};

/**
 * Returns true if the specified fontFamily is equal to the default (or one of its syntactic equivalents)
 * @param {string} fontFamily
 * @return {boolean} true if the fontFamily is the default, false otherwise
 */
dvt.Context.prototype.isDefaultFontFamily = function(fontFamily) {
  return dvt.Context._DEFAULT_FONT_FAMILIES[fontFamily] == true;
};

/**
 * Returns the default CSS font size that is applied to the stage.
 * @return {string}
 */
dvt.Context.prototype.getDefaultFontSize = function() {
  return dvt.Context._DEFAULT_FONT_SIZE;
};

/**
 *  Returns a platform dependent implementation factory of the one and only
 *  implementation factory object.
 *  @return {DvtSvgImplFactory}
 */
dvt.Context.prototype.getImplFactory = function() {
  return this._implFactory;
};


/**
 *  Returns a platform dependent implementation of the one and only
 *  stage.
 *  @return {DvtStage}
 */
dvt.Context.prototype.getStage = function() {
  return this._stage;
};

/**
 * Returns true if this dvt.Context is ready to support component rendering.  This will be false when the SVG document
 * is not attached to a visible subtree of the DOM.
 * @return {boolean}
 */
dvt.Context.prototype.isReadyToRender = function() {
  // Check if the parent div is connected to the DOM and not hidden via display:none. This indicates that
  // we can perform measurement, which is a pre-requisite for us to render.
  var ancestor = this._parentDiv;
  while (ancestor && ancestor != document) {
    if (ancestor.style && ancestor.style.display == 'none')
      return false;

    ancestor = ancestor.parentNode;
  }

  // The ancestor will be the document if all parents are connected.
  return ancestor == document;
};

/**
 * Returns the SVG document corresponding to this context instance.
 * @return {Element}
 */
dvt.Context.prototype.getSvgDocument = function() {
  return this._root;
};


/**
 * Specifies the reading direction for the context.  This is used by dvt.Agent.isRightToLeft(context) overriding the
 * reading direction from the DOM when specified.
 * @param {string} dir The reading direction string, such as "rtl" or "ltr".
 */
dvt.Context.prototype.setReadingDirection = function(dir) {
  this._readingDirection = dir;
};


/**
 * Returns the reading direction for the context, if specified.  Component developers should use dvt.Agent.isRightToLeft
 * instead, as that function will determine the reading direction from the DOM when not specified on the context.
 * @return {string} The reading direction string if specified on the context, null otherwise.
 */
dvt.Context.prototype.getReadingDirection = function() {
  return this._readingDirection;
};


/**
  * Adds a reference count for the global def element with the given id
  * @param {string} id The id of the global def element
  */
dvt.Context.prototype.increaseGlobalDefReference = function(id) {
  // The id of the element must be valid to continue
  if (id == null)
    return;

  if (this._globalDefsMap[id])
    this._globalDefsMap[id] = this._globalDefsMap[id]++;
  else
    this._globalDefsMap[id] = 1;
};


/**
  * Removes a reference count for the global def element with the given id
  * @param {string} id The id of the global def element
  */
dvt.Context.prototype.decreaseGlobalDefReference = function(id) {
  // The id of the element must be valid to continue
  if (id == null)
    return;

  // Update the reference count for this clip path id
  var refCount = this._globalDefsMap[id];
  if (refCount) {
    if (refCount == 1)
      delete this._globalDefsMap[id];
    else
      this._globalDefsMap[id] = refCount--;
  }

  // If no longer referenced, remove the clip path from the defs
  if (!this._globalDefsMap[id])
    this.removeDefsById(id);
};

/**
 * Returns a platform dependent implementation of the one and only
 * tooltip manager.
 * @param {string} id
 * @return {dvt.TooltipManager}
 */
dvt.Context.prototype.getTooltipManager = function(id) {
  if (!id)
    id = '_dvtTooltip';
  var stageId = this.getStage().getId();
  id = id + stageId;
  var manager = this._tooltipManagers[id];
  if (!manager) {
    this._tooltipManagers[id] = this._implFactory.newTooltipManager(id);
  }
  return this._tooltipManagers[id];
};

/**
 * Hides tooltips shown by tooltip managers registered with the context
 */
dvt.Context.prototype.hideTooltips = function() {
  for (var id in this._tooltipManagers) {
    this._tooltipManagers[id].hideTooltip();
  }
};

/**
  * Get the single scheduler instance for this context.
  * @return {DvtScheduler}
  */
dvt.Context.prototype.getScheduler = function() {
  if (!this._scheduler)
  {
    this._scheduler = new DvtScheduler(this);
  }

  return this._scheduler;
};


/**
  * Obtain document utils singleton.
  * @return {Object}
  */
dvt.Context.prototype.getDocumentUtils = function() {
  return this._implFactory.getDocumentUtils();
};


/**
 * Returns the specified page coordinates relative to the stage.
 * @param {number} pageX
 * @param {number} pageY
 * @return {dvt.Point}
 */
dvt.Context.prototype.pageToStageCoords = function(pageX, pageY) {
  var stagePos = this.getStageAbsolutePosition();
  var xPos = pageX - stagePos.x;
  var yPos = pageY - stagePos.y;
  return new dvt.Point(xPos, yPos);
};


/**
 * Returns the specified stage coordinates relative to the page.
 * @param {number} stageX The x coordinate, relative to the stage.
 * @param {number} stageY The y coordinate, relative to the stage.
 * @return {dvt.Point}
 */
dvt.Context.prototype.stageToPageCoords = function(stageX, stageY) {
  var stagePos = this.getStageAbsolutePosition();
  var xPos = stageX + stagePos.x;
  var yPos = stageY + stagePos.y;
  return new dvt.Point(xPos, yPos);
};


/**
 * Returns the coordinates of the stage, relative to the page.  This is an expensive operation which is optimized by
 * using a cache, managed by dvt.EventManager.
 * @return {dvt.Point}
 */
dvt.Context.prototype.getStageAbsolutePosition = function() {
  // If a cached value is available, use it
  if (this._stageAbsolutePosition)
    return this._stageAbsolutePosition;


  // Use a reference element at the same position at the SVG whenever possible.  The browser functions used in dvt.Agent's
  // getElementPosition do not always return the correct values for SVG elements, especially in Firefox.  Note that we
  // can ensure the presence of a parent div at the same coordinates across all our supported frameworks, so this
  // issue will never occur in the real product.
  var referenceElem = this._referenceDiv;
  if (!referenceElem) {
    var svgRoot = this.getStage().getImpl().getSVGRoot();
    referenceElem = svgRoot.parentNode ? svgRoot.parentNode : svgRoot;
  }

  // Note: As mentioned above, this returns the wrong position in Firefox for SVG elements.
  var svgPos = dvt.Agent.getElementPosition(referenceElem);

  this._stageAbsolutePosition = new dvt.Point(parseInt(svgPos.x), parseInt(svgPos.y));
  return this._stageAbsolutePosition;
};

/**
 * Clears the cached value for the stage position.
 */
dvt.Context.prototype.clearStageAbsolutePosition = function() {
  this._stageAbsolutePosition = null;
};

/**
 * Returns true if the SVG for this context is fully offscreen.
 * @return {boolean}
 */
dvt.Context.prototype.isOffscreen = function() {
  // Note: This code ignores the FF bug in getBoundingClientRect, which is supposed to be fixed in FF33. This should be
  // okay as the current behavior only returns sizes larger than the actual.
  var referenceElem = this.getStage().getImpl().getSVGRoot();
  var rect = referenceElem.getBoundingClientRect();
  return rect.bottom < 0 || rect.right < 0 ||
         rect.top > (window.innerHeight || document.documentElement.clientHeight) ||
         rect.left > (window.innerWidth || document.documentElement.clientWidth);
};

/**
 * Returns the DvtCustomTooltipManager for the given id.
 * @param {string} id
 * @return {DvtCustomTooltipManager}
 */
dvt.Context.prototype.getCustomTooltipManager = function(id)
{
  if (!id)
    id = '_dvtCustomTooltip';
  var stageId = this.getStage().getId();
  id = id + stageId;
  var manager = this._customTooltipManagers[id];
  if (!manager) {
    this._customTooltipManagers[id] = new DvtCustomTooltipManager(this, id);
  }
  return this._customTooltipManagers[id];
};


/**
 * Append element(s) to the application global <defs> element.
 * @param {object} elem
 */
dvt.Context.prototype.appendDefs = function(elem)
{
  dvt.ToolkitUtils.appendChildElem(this._defs, elem);
};


/**
  *   @return {DOM_Element}  the global <defs> DOM element
  */
dvt.Context.prototype.getDefs = function()
{
  return this._defs;
};


/**
  *   @return {DvtSvgImplFactory}  the platform implementation factory.
  */
dvt.Context.prototype.getImplFactory = function()
{
  return this._implFactory;
};


/**
  * Removes the specified element from the global <defs> element.
  * @param {object} elem
  */
dvt.Context.prototype.removeDefs = function(elem)
{
  this._defs.removeChild(elem);
};


/**
  * Removes the element with the specified id from the global <defs> element.
  * @param {string} id
  */
dvt.Context.prototype.removeDefsById = function(id)
{
  var defs = this._defs.childNodes;
  var len = defs.length;
  for (var i = 0; i < len; i++) {
    var def = defs[i];
    if (def.id === id) {
      this._defs.removeChild(def);
      return;
    }
  }
};

/**
 * Returns the value of the attribute on the root element
 * @param {string} attrName Attribute name
 * @return {string} value of the attribute
 */
dvt.Context.prototype.getRootAttribute = function(attrName) {
  return dvt.ToolkitUtils.getAttrNullNS(this._root, attrName);
};


/**
 * Clears all unique seeds used for filter, clip path, gradient, and af component id generation.
 * Should only be called by Junit tests.
 */
dvt.Context.resetUniqueSeeds = function() {
  if (dvt.Agent.isEnvironmentBrowser())
    return;

  if (typeof DvtAfComponent != 'undefined')
    DvtAfComponent._uniqueSeed = 0;
  DvtSvgFilterUtils._counter = 0;
  dvt.ClipPath._uniqueSeed = 0;
  dvt.SvgShapeUtils._uniqueSeed = 0;
  dvt.Mask._uniqueSeed = 0;
  dvt.Agent._bInitialized = false;
};

/**
 * Clears all caches used for text and af components.
 * Should only be called by Junit tests.
 */
dvt.Context.resetCaches = function() {
  if (dvt.Agent.isEnvironmentBrowser())
    return;

  if (typeof DvtAfComponent != 'undefined')
    DvtAfStyleUtils.resetStyles();
  dvt.OutputText._cache = null;
  dvt.TextUtils._cachedTextDimensions = {};
  dvt.MarkerUtils._cache = {};

  if (dvt.LedGaugeRenderer)
    dvt.LedGaugeRenderer._cache = null;
};

/**
 * Sets the wai-aria active-descendent to be the given displayable.
 * @param {dvt.Displayable} displayable The new active displayable.
 */
dvt.Context.prototype.setActiveElement = function(displayable) {
  if (!dvt.Agent.isEnvironmentBrowser())
    return;

  // Clear the id of the current active element.  This field is only set if a temp id was applied earlier.
  if (this._activeElement) {
    dvt.ToolkitUtils.removeAttrNullNS(this._activeElement.getElem(), 'id');
    this._activeElement = null;
  }

  // Get the ID of the elem. If it doesn't have an ID, create one for it.
  var elem = displayable.getElem();
  var id = dvt.ToolkitUtils.getAttrNullNS(elem, 'id');
  if (!id) {
    id = displayable.getId();
    if (id) {
      // Apply the existing id
      dvt.ToolkitUtils.setAttrNullNS(elem, 'id', id);
    }
    else {
      // Generate a temporary id
      id = dvt.EventManager._getActiveElementId();
      dvt.ToolkitUtils.setAttrNullNS(elem, 'id', id);
      this._activeElement = displayable;
    }
  }

  // Ensure that aria properties have been written to the DOM
  displayable.applyAriaProperties();

  // Update the active descendant to point to the displayable
  if (this._role == 'application')
    this._parentDiv.setAttribute('aria-activedescendant', id);
};

/**
 * Sets the wai-aria label property on the containing div.
 * @param {string} ariaLabel
 */
dvt.Context.prototype.setAriaLabel = function(ariaLabel) {
  // Don't overwrite application set aria-label
  if (!this._parentDiv.getAttribute('aria-label')) {
    if (ariaLabel)
      this._parentDiv.setAttribute('aria-label', dvt.StringUtils.processAriaLabel(ariaLabel));
    else
      this._parentDiv.removeAttribute('aria-label');
  }
};

/**
 * Sets the wai-aria role property on the containing div.
 * @param {string} role
 */
dvt.Context.prototype.setAriaRole = function(role) {
  if (role)
    this._parentDiv.setAttribute('role', role);
  else
    this._parentDiv.removeAttribute('role');

  this._role = role;
};

/**
 * Sets the callback to be invoked when the tooltip is attached. Used in JET to support JET components in the custom
 * tooltips.
 * @param {function} callback
 */
dvt.Context.prototype.setTooltipAttachedCallback = function(callback) {
  this._tooltipAttachedCallback = callback;
};

/**
 * Returns the callback to be invoked when the tooltip is attached. Used in JET to support JET components in the custom
 * tooltips.
 * @return {?function}
 */
dvt.Context.prototype.getTooltipAttachedCallback = function() {
  return this._tooltipAttachedCallback;
};

/**
 * Sets the style class to use for the tooltip popup div
 * @param {String} styleClass The tooltip popup div style class
 */
dvt.Context.prototype.setTooltipStyleClass = function(styleClass) {
  this._tooltipStyleClass = styleClass;
};

/**
 * Returns the style class to use for the tooltip popup div
 * @return {String}
 */
dvt.Context.prototype.getTooltipStyleClass = function() {
  return this._tooltipStyleClass ? this._tooltipStyleClass : dvt.Context._TOOLTIP_POPUP_STYLE_CLASS;
};

/**
 * Sets the style class to use for the datatip popup div
 * @param {String} styleClass The datatip popup div style class
 */
dvt.Context.prototype.setDatatipStyleClass = function(styleClass) {
  this._datatipStyleClass = styleClass;
};

/**
 * Returns the style class to use for the datatip popup div
 * @return {String}
 */
dvt.Context.prototype.getDatatipStyleClass = function() {
  return this._datatipStyleClass ? this._datatipStyleClass : dvt.Context._DATATIP_POPUP_STYLE_CLASS;
};


/**
 * Sets an array of keyboard listeners that are connected through tabbing. The context will initially focus on
 * the first component in the array. Shift the focus to the next/previous component using nextKeyboardFocus() and
 * previousKeyboardFocus().
 * @param {array} displayables Array of keyboard listeners.
 */
dvt.Context.prototype.setKeyboardFocusArray = function(displayables) {
  this._keyboardFocusArray = displayables;
  this._keyboardFocusIndex = 0;

  if (displayables.length > 0) {
    var wrappingDiv = this._root.parentNode;
    wrappingDiv._currentObj = this._keyboardFocusArray[this._keyboardFocusIndex];
  }
};

/**
 * Returns the component of the current Keyboard Focus.
 * @return {dvt.Displayable} The current component.
 */
dvt.Context.prototype.getCurrentKeyboardFocus = function() {
  if (this._keyboardFocusArray.length <= this._keyboardFocusIndex) {
    return null;
  }
  else {
    return this._keyboardFocusArray[this._keyboardFocusIndex];
  }
};

/**
 * Sets the current Keyboard Focus.
 * @param {dvt.Displayable} newKeyboardFocus component that the current keyboard focus will be set to.
 * @return {boolean} Whether the Focus was successfully set.
 */
dvt.Context.prototype.setCurrentKeyboardFocus = function(newKeyboardFocus) {
  var newFocusIndex = dvt.ArrayUtils.getIndex(this._keyboardFocusArray, newKeyboardFocus);
  if (newFocusIndex == -1) {
    return false;
  }
  var currentObj = this._keyboardFocusArray[newFocusIndex];
  this._keyboardFocusIndex = newFocusIndex;
  var wrappingDiv = this._root.parentNode;
  wrappingDiv._currentObj = currentObj;
  return true;
};


/**
 * Shifts the keyboard focus to the next component and returns the component.
 * @return {dvt.Displayable} The next component.
 */
dvt.Context.prototype.nextKeyboardFocus = function() {
  var currentObj = this._keyboardFocusArray[this._keyboardFocusIndex + 1];
  if (currentObj) {
    this._keyboardFocusIndex++;
    var wrappingDiv = this._root.parentNode;
    wrappingDiv._currentObj = currentObj;
    return currentObj;
  }
  else
    return null;
};

/**
 * Shifts the keyboard focus to the previous component and returns the component.
 * @return {dvt.Displayable} The next component.
 */
dvt.Context.prototype.previousKeyboardFocus = function() {
  var currentObj = this._keyboardFocusArray[this._keyboardFocusIndex - 1];
  if (currentObj) {
    this._keyboardFocusIndex--;
    var wrappingDiv = this._root.parentNode;
    wrappingDiv._currentObj = currentObj;
    return currentObj;
  }
  else
    return null;
};

/**
 * Returns a number converter if it's set by the consuming framework layer. Supported options
 * are limited to minimumFractionDigits and maximumFractionDigits.
 * @param {object} options containing the minimumFractionDigits and maximumFractionDigits.
 * @return {object} the converter or null
 */
dvt.Context.prototype.getNumberConverter = function(options) {
  var localeHelpers = this.getLocaleHelpers();
  if (localeHelpers['numberConverterFactory'])
    return localeHelpers['numberConverterFactory']['createConverter'](options);

  return null;
};

/**
 * Returns the localeHelpers object or an empty object if none are defined.
 * @return {object}
 */
dvt.Context.prototype.getLocaleHelpers = function() {
  return this._localeHelpers ? this._localeHelpers : {};
};

/**
 * Sets the localeHelpers object, which may contain isoToDateConverter, dateToIsoConverter, and numberConverterFactory.
 * @param {object} helpers
 */
dvt.Context.prototype.setLocaleHelpers = function(helpers) {
  this._localeHelpers = helpers;
};

/**
 * Polyfill for requestAnimationFrame.
 * @param {function} callback The function that will be executed.
 * @return {number} A long integer value that uniquely identifies the entry in the callback list. This can be passed to
 *                  dvt.Context.cancelAnimationFrame to cancel the request.
 */
dvt.Context.requestAnimationFrame = function(callback) {
  if (window.requestAnimationFrame)
    return window.requestAnimationFrame(callback);
  else
    return window.setTimeout(callback, 1000 / 30);
};

/**
 * Polyfill for cancelAnimationFrame.
 * @param {number} requestId A long integer value that uniquely identifies the entry in the callback list.
 */
dvt.Context.cancelAnimationFrame = function(requestId) {
  if (window.cancelAnimationFrame)
    window.cancelAnimationFrame(requestId);
  else
    clearTimeout(requestId);
};

/**
 * Returns the parent div of the context
 * @return {Element}
 */
dvt.Context.prototype.getContainer = function() {
  return this._parentDiv;
};

/**
 * Returns a new div that is used to hold custom content that overlays
 * the component.
 * @return {Element}
 */
dvt.Context.prototype.createOverlayDiv = function() {
  var overlayDiv = document.createElement('div');
  overlayDiv.style.top = '-100%';
  overlayDiv.style.position = 'relative';
  return overlayDiv;
};

/**
 * Sets the callback to be invoked when the overlay is attached. Used in JET to support JET components in the custom
 * center content.
 * @param {function} callback
 */
dvt.Context.prototype.setOverlayAttachedCallback = function(callback) {
  this._overlayAttachedCallback = callback;
};

/**
 * Returns the callback to be invoked when the overlay is attached. Used in JET to support JET components in the custom
 * center content.
 * @return {?function}
 */
dvt.Context.prototype.getOverlayAttachedCallback = function() {
  return this._overlayAttachedCallback;
};
/**
 * A base class for shape fills, strokes, shadows, etc.
 * {@link DvtLockable}.
 * @extends {dvt.Obj}
 * @class DvtLockable  A base class for shape fills, strokes,shadows, etc.
 * @constructor  Do not create/use directly.
 */
var DvtLockable = function() {
  this._Init();
};

dvt.Obj.createSubclass(DvtLockable, dvt.Obj);


/**
 * @private
 */
DvtLockable.prototype._Init = function() {
  this._bLocked = false;
};


/**
 *  Returns true if the fill object is immutable, else false.
 *  @type {Boolean}
 */
DvtLockable.prototype.isLocked = function() {
  return this._bLocked;
};


/**
 *  Makes the property set immutable.  The only way to change the object's
 *  properties once it is immutable is to clone it and apply property changes
 *  to the cloned object.  This method should not be called by application code
 *  and should only be used by toolkit code.
 *  @private
 */
DvtLockable.prototype.__lock = function() {
  this._bLocked = true;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an item that can be scheduled to run with a scheduler.
  * @extends {dvt.Obj}
  * @class DvtScheduled
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param {DvtScheduler}  scheduler  scheduler used to run this item
  * @param {number}  duration  length of time to run item, in seconds
  * @param {number}  delay  time to delay start of item, in seconds
  * @param {function}  easing  easing function to use with this item
  */
var DvtScheduled = function(context, scheduler, duration, delay, easing)
{
  this.Init(context, scheduler, duration, delay, easing);
};

dvt.Obj.createSubclass(DvtScheduled, dvt.Obj);


/**
  * @private
  * State: initialize.
  */
DvtScheduled._STATE_INITIALIZE = 0;


/**
  * @private
  * State: begin.
  */
DvtScheduled._STATE_BEGIN = 1;


/**
  * @private
  * State: run.
  */
DvtScheduled._STATE_RUN = 2;


/**
  * @protected
  * Calculate the percent progress of the given value between the min and max.
  *
  * @param {number}  val  current value
  * @param {number}  min  minimum value
  * @param {number}  max  maximum value
  * @type {number}
  */
DvtScheduled.CalcProgress = function(val, min, max)
{
  var diff = (max - min);
  if (diff == 0)
  {
    return 0.5;
  }
  else
  {
    var ret = ((val - min) / diff);
    if (ret > 1)
    {
      ret = 1;
    }
    return ret;
  }
};


/**
  * @protected
  */
DvtScheduled.prototype.Init = function(context, scheduler, duration, delay, easing)
{
  this._context = context;

  this._scheduler = scheduler;
  this.setDuration(duration); //in seconds
  this.setDelay(delay); //in seconds
  this.setEasing(easing);

  this._bRunning = false;
  this._startTime = null;
  this._progress = 0;
  this._state = DvtScheduled._STATE_INITIALIZE;

  this._onInit = null;
  this._onInitObj = null;
  this._onStart = null;
  this._onStartObj = null;
  this._onEnd = null;
  this._onEndObj = null;
  this._onStep = null;
  this._onStepObj = null;
};


/**
  * Get the duration of this item, in seconds.
  *
  * @type {number}
  */
DvtScheduled.prototype.getDuration = function()
{
  return this._duration;
};


/**
  * Set the duration of this item.
  *
  * @param {number}  duration  duration of this item, in seconds
  */
DvtScheduled.prototype.setDuration = function(duration)
{
  this._duration = (duration ? duration : 0.5);
};


/**
  * Get the delay for the start of this item, in seconds.
  *
  * @type {number}
  */
DvtScheduled.prototype.getDelay = function()
{
  return this._delay;
};


/**
  * Set the delay for the start of this item.
  *
  * @param {number}  delay  delay for the start of this item, in seconds
  */
DvtScheduled.prototype.setDelay = function(delay)
{
  this._delay = (delay ? delay : 0);
};


/**
  * Get the easing function for this animation.
  *
  * @type {function}
  */
DvtScheduled.prototype.getEasing = function()
{
  return this._easing;
};


/**
  * Set the easing function for this animation.
  *
  * @param {function}  easing  easing function
  */
DvtScheduled.prototype.setEasing = function(easing)
{
  this._easing = (easing ? easing : dvt.Easing.cubicInOut);
};


/**
  * Set the function to call when this item initializes.
  *
  * @param {function}  onInit  function to call when this item initializes
  * @param {object}  onInitObj  optional reference to object instance on which the
  *        function is defined
  */
DvtScheduled.prototype.setOnInit = function(onInit, onInitObj)
{
  this._onInit = onInit;
  if (onInitObj)
  {
    this._onInitObj = onInitObj;
  }
  else
  {
    this._onInitObj = null;
  }
};


/**
  * Get the function to call when this item initializes.
  * Returns an array of two elements:
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  *
  * @type {array}
  */
DvtScheduled.prototype.getOnInit = function()
{
  return [this._onInit, this._onInitObj];
};


/**
  * Set the function to call when this item starts.
  *
  * @param {function}  onStart  function to call when this item starts
  * @param {object}  onStartObj  optional reference to object instance on which the
  *        function is defined
  */
DvtScheduled.prototype.setOnStart = function(onStart, onStartObj)
{
  this._onStart = onStart;
  if (onStartObj)
  {
    this._onStartObj = onStartObj;
  }
  else
  {
    this._onStartObj = null;
  }
};


/**
  * Get the function to call when this item starts.
  * Returns an array of two elements:
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  *
  * @type {array}
  */
DvtScheduled.prototype.getOnStart = function()
{
  return [this._onStart, this._onStartObj];
};


/**
  * Set the function to call when this item ends.
  *
  * @param {function}  onEnd  function to call when this item ends
  * @param {object}  onEndObj  optional reference to object instance on which the
  *        function is defined
  */
DvtScheduled.prototype.setOnEnd = function(onEnd, onEndObj)
{
  this._onEnd = onEnd;
  if (onEndObj)
  {
    this._onEndObj = onEndObj;
  }
  else
  {
    this._onEndObj = null;
  }
};


/**
  * Get the function to call when this item ends.
  * Returns an array of two elements:
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  *
  * @type {array}
  */
DvtScheduled.prototype.getOnEnd = function()
{
  return [this._onEnd, this._onEndObj];
};


/**
  * Set the function to call at each step of this item.
  *
  * @param {function}  onStep  function to call at each step of this item
  * @param {object}  onStepObj  optional reference to object instance on which the
  *        function is defined
  */
DvtScheduled.prototype.setOnStep = function(onStep, onStepObj)
{
  this._onStep = onStep;
  if (onStepObj)
  {
    this._onSepObj = onStepObj;
  }
  else
  {
    this._onStepObj = null;
  }
};


/**
  * Get the function to call at each step of this item.
  * Returns an array of two elements:
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  *
  * @type {array}
  */
DvtScheduled.prototype.getOnStep = function()
{
  return [this._onStep, this._onStepObj];
};


/**
  * Determine if this item is running.
  *
  * @type {boolean}
  */
DvtScheduled.prototype.isRunning = function()
{
  return this._bRunning;
};


/**
  * Play this item.
  * @param {boolean} bImmediate true to begin the animation immediately.  This should generally be false when used by
  *                             components, so that the animation is started after the browser rendering is complete.
  */
DvtScheduled.prototype.play = function(bImmediate)
{
  if (bImmediate)
    this._play();
  else // Play after a quick timeout allowing the browser to render the bulk of the DOM and any subsequent components.
    dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this._play));
};

/**
 * Called by play with an optional timeout to enable the animation to run more smoothly.
 * @private
 */
DvtScheduled.prototype._play = function() {
  if (!this._bRunning)
  {
    this._bRunning = true;
    this.ProcessPlay();
    this._scheduler.addScheduled(this);
  }

  // If offscreen, stop the animation immediately and jump to end
  if (this._context.isOffscreen())
    this.stop(true);
};

/**
  * Stop this item.
  *
  * @param {boolean}  bJumpToEnd  true to jump to 100% progress,
  *        false to stop at current progress
  */
DvtScheduled.prototype.stop = function(bJumpToEnd)
{
  this._scheduler.removeScheduled(this);
  if (bJumpToEnd)
  {
    this.ProcessStep(1);
  }
  this.ProcessEnd();
};


/**
  * Pause this item.
  */
DvtScheduled.prototype.pause = function()
{
  this._bRunning = false;
  //this._scheduler.removeScheduled(this);
};


/**
  * Reset this item.
  */
DvtScheduled.prototype.reset = function()
{
  this._state = DvtScheduled._STATE_INITIALIZE;
};


/**
  * Process this item for the given timestamp.
  *
  * @param {number}  time  current timestamp, in milliseconds
  */
DvtScheduled.prototype.processTime = function(time)
{
  if (!this._bRunning)
  {
    return;
  }

  var elapsedTime = time - this._startTime;
  if (elapsedTime < 0)
  {
    return false;
  }

  var duration = 1000 * this.GetTotalDuration();
  var progress = 1;
  if (duration != 0)
  {
    progress = elapsedTime / duration;
  }
  if (progress > 1)
  {
    progress = 1;
  }
  this.ProcessStep(progress);

  var bDone = (progress >= 1);
  if (bDone)
  {
    this.ProcessEnd();
  }
  return bDone;
};


/**
  * @protected
  * Get the total duration of this item, in seconds.
  *
  * @type {number}
  */
DvtScheduled.prototype.GetTotalDuration = function()
{
  return this._delay + this._duration;
};


/**
  * @protected
  * Process when this item is played.
  */
DvtScheduled.prototype.ProcessPlay = function()
{
  if (this._state == DvtScheduled._STATE_INITIALIZE)
  {
    this.ProcessInitialize();
  }

  if (this._state == DvtScheduled._STATE_BEGIN)
  {
    this._startTime = new Date().getTime();
    this.ProcessStart();
  }
  else
  {
    var elapsedTime = this._progress * 1000 * this.GetTotalDuration();
    this._startTime = new Date().getTime() - elapsedTime;
  }

  this._state = DvtScheduled._STATE_RUN;
};


/**
  * @protected
  * Process initialization of this item when it starts to play.
  */
DvtScheduled.prototype.ProcessInitialize = function()
{
  if (this._onInit)
  {
    this._onInit.call(this._onInitObj);
  }
  this.Initialize();
  this._state = DvtScheduled._STATE_BEGIN;
};


/**
  * @protected
  * Process the start of this item after it initializes.
  */
DvtScheduled.prototype.ProcessStart = function()
{
  this._bRunning = true;
  this._progress = 0;
  this.Start();
  if (this._onStart)
  {
    this._onStart.call(this._onStartObj);
  }
};


/**
  * @protected
  * Process a step of this item as it plays.
  *
  * @param {number}  progress  percent progress of this item
  */
DvtScheduled.prototype.ProcessStep = function(progress)
{
  this._progress = progress;
  var prog = progress;
  if (this._delay > 0)
  {
    prog = DvtScheduled.CalcProgress(progress, this._delay / this.GetTotalDuration(), 1);
  }
  if (prog >= 0)
  {
    if (this._easing)
    {
      prog = this._easing(prog);
    }
    this.Step(prog);

    if (this._onStep)
    {
      this._onStep.call(this._onStepObj, prog);
    }
  }
};


/**
  * @protected
  * Process when this item stops.
  */
DvtScheduled.prototype.ProcessEnd = function()
{
  //only process end if still running
  if (this._bRunning)
  {
    this._bRunning = false;
    this._progress = 1;
    this.End();
    this._state = DvtScheduled._STATE_BEGIN;
    if (this._onEnd)
    {
      this._onEnd.call(this._onEndObj);
    }
  }
};


/**
  * @protected
  * Initialize this item.
  */
DvtScheduled.prototype.Initialize = function()
{
  //do nothing; subclasses should implement
};


/**
  * @protected
  * Start playing this item.
  */
DvtScheduled.prototype.Start = function()
{
  //do nothing; subclasses should implement
};


/**
  * @protected
  * Step this item.
  *
  * @param {number}  progress  percent progress of this item
  */
DvtScheduled.prototype.Step = function(progress)
{
  //do nothing; subclasses should implement
};


/**
  * @protected
  * End this item.
  */
DvtScheduled.prototype.End = function()
{
  //do nothing; subclasses should implement
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing a scheduling service.
  * @extends {dvt.Obj}
  * @class DvtScheduler
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  */
var DvtScheduler = function(context)
{
  this.Init(context);
};

dvt.Obj.createSubclass(DvtScheduler, dvt.Obj);


/**
  * @protected
  */
DvtScheduler.prototype.Init = function(context)
{
  this._scheduledItems = new Array();
  this._bRunning = false;
};

/**
  * @protected
  * Handle a timer tick.
  */
DvtScheduler.prototype.HandleTimer = function()
{
  var time = new Date().getTime();
  for (var i = 0; i < this._scheduledItems.length; i++)
  {
    var scheduled = this._scheduledItems[i];
    if (scheduled.processTime(time))
      this.removeScheduled(scheduled);
  }

  if (this._scheduledItems.length < 1)
    this.pause();
  else
    this._animationRequestId = dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this.HandleTimer));

  // Private flag for animation testing. Do not remove.
  DvtScheduler._frameCount++;
};


/**
  * Add a scheduled item to be run.
  *
  * @param {DvtScheduled}  scheduled  item to add
  */
DvtScheduler.prototype.addScheduled = function(scheduled)
{
  var i = dvt.ArrayUtils.getIndex(this._scheduledItems, scheduled);
  if (i < 0)
  {
    this._scheduledItems.push(scheduled);
  }

  this.play();
};


/**
  * Remove a scheduled item.
  *
  * @param {DvtScheduled}  scheduled  item to remove
  */
DvtScheduler.prototype.removeScheduled = function(scheduled)
{
  var i = dvt.ArrayUtils.getIndex(this._scheduledItems, scheduled);
  if (i >= 0)
  {
    this._scheduledItems.splice(i, 1);
  }
};

/**
  * Play the scheduler.
  */
DvtScheduler.prototype.play = function()
{
  if (!this._bRunning)
  {
    for (var i = 0; i < this._scheduledItems.length; i++)
    {
      var scheduled = this._scheduledItems[i];
      if (!scheduled.isRunning())
      {
        scheduled.play();
      }
    }

    this._bRunning = true;

    this._animationRequestId = dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this.HandleTimer));
  }
};


/**
  * Pause the scheduler.
  */
DvtScheduler.prototype.pause = function()
{
  if (this._bRunning)
  {
    this._bRunning = false;

    if (this._animationRequestId)
      dvt.Context.cancelAnimationFrame(this._animationRequestId);

    for (var i = 0; i < this._scheduledItems.length; i++)
    {
      var scheduled = this._scheduledItems[i];
      if (scheduled.isRunning())
      {
        scheduled.pause();
      }
    }
  }
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Class representing an animator that animates a property change.
 * @extends {DvtScheduled}
 * @class dvt.Animator
 * @constructor
 *
 * @param {dvt.Context}  context  platform specific context object
 * @param {number}  duration  length of animation, in seconds
 * @param {number}  delay  time to delay start of animation, in seconds
 * @param {function}  easing  easing function to use with this animation
 */
dvt.Animator = function(context, duration, delay, easing) {
  this.Init(context, duration, delay, easing);
};

dvt.Obj.createSubclass(dvt.Animator, DvtScheduled);


/**
 * Property type: number.
 */
dvt.Animator.TYPE_NUMBER = 'typeNumber';


/**
 * Property type: matrix.
 */
dvt.Animator.TYPE_MATRIX = 'typeMatrix';


/**
 * Property type: array of numbers.
 */
dvt.Animator.TYPE_NUMBER_ARRAY = 'typeNumberArray';


/**
 * Property type: color.
 */
dvt.Animator.TYPE_COLOR = 'typeColor';


/**
 * Property type: array of colors.
 */
dvt.Animator.TYPE_COLOR_ARRAY = 'typeColorArray';


/**
 * Property type: grow polyline points.
 */
dvt.Animator.TYPE_GROW_POLYLINE = 'typeGrowPolyline';


/**
 * Property type: rectangle.
 */
dvt.Animator.TYPE_RECTANGLE = 'typeRectangle';


/**
 * Property type: point.
 */
dvt.Animator.TYPE_POINT = 'typePoint';


/**
 * Property type: path.
 */
dvt.Animator.TYPE_PATH = 'typePath';


/**
 * Property type: grow path points.
 */
dvt.Animator.TYPE_GROW_PATH = 'typeGrowPath';


/**
 * Property type: fill.
 */
dvt.Animator.TYPE_FILL = 'typeFill';


/**
 * Property type: stroke.
 */
dvt.Animator.TYPE_STROKE = 'typeStroke';


/**
 * Property type: polyline.
 */
dvt.Animator.TYPE_POLYLINE = 'typePolyline';

dvt.Animator._KEY_PREFIX = 'dvtAnimPropMap_';


/**
 * @protected
 */
dvt.Animator.prototype.Init = function(context, duration, delay, easing) {
  dvt.Animator.superclass.Init.call(this, context, context.getScheduler(), duration, delay, easing);

  this._context = context;
  this._props = {};
};


/**
 * Add a property to animate.
 *
 * @param {string}  type  type of property
 * @param {object}  obj  object being animated
 * @param {function}  getter  getter function for property being animated
 * @param {function}  setter  setter function for property being animated
 * @param  destVal  destination value to animate to
 */
dvt.Animator.prototype.addProp = function(type, obj, getter, setter, destVal) {
  var item = this.GetPropItem(obj, getter);
  if (item) {
    item.destVal = destVal;
  }
  else {
    var item = new DvtAnimatorPropItem(type, obj, getter, setter, destVal);
    //map keys must be strings, so always generate a string key for objects
    //and functions
    var keyObj = dvt.Animator.GetKey(obj);
    if (!this._props[keyObj]) {
      this._props[keyObj] = {};
    }
    this._props[keyObj][dvt.Animator.GetKey(getter)] = item;
  }
};


/**
 * Removes a property to animate.
 *
 * @param {object}  obj  object being animated
 * @param {function}  getter  getter function for property being animated
 */
dvt.Animator.prototype.removeProp = function(obj, getter) {
  var item = this.GetPropItem(obj, getter);
  if (item) {
    var destVal = item.destVal;
    delete this._props[dvt.Animator.GetKey(obj)][dvt.Animator.GetKey(getter)];
    return destVal;
  }
  return null;
};


/**
 * Get the destination value for a property being animated.
 *
 * @param {object}  obj  object being animated
 * @param {function}  getter  getter function for property being animated
 * @param {boolean} callGetter (optional) If no destination value is found, indicates whether the getter should be called directly rather than returning null
 */
dvt.Animator.prototype.getDestVal = function(obj, getter, callGetter) {
  var item = this.GetPropItem(obj, getter);
  if (item) {
    return item.destVal;
  }
  //if not part of the animation, return null
  return callGetter ? getter.call(obj) : null;
};


/**
 * @protected
 * Get the index of the given property in the storage array,
 * or -1 if the property is not found.
 *
 * @param {object}  obj  object being animated
 * @param {function}  getter  getter function for property being animated
 */
dvt.Animator.prototype.GetPropItem = function(obj, getter) {
  var keyObj = dvt.Animator.GetKey(obj);
  if (this._props[keyObj]) {
    return this._props[keyObj][dvt.Animator.GetKey(getter)];
  }
  return null;
};


/**
 * @protected
 * Get the key to use for the given obj in the prop map.
 */
dvt.Animator.GetKey = function(obj) {
  if (!obj._dvtAnimPropMapKey) {
    obj._dvtAnimPropMapKey = dvt.Animator._KEY_PREFIX + Math.random();//@RandomNumberOk
  }
  return obj._dvtAnimPropMapKey;
};


/**
 * @protected
 * @override
 */
dvt.Animator.prototype.Initialize = function() {
  for (var keyObj in this._props) {
    for (var keyGetter in this._props[keyObj]) {
      var item = this._props[keyObj][keyGetter];
      item.startVal = item.getter.call(item.obj);
    }
  }
};


/**
 * @protected
 * @override
 */
dvt.Animator.prototype.Step = function(progress) {
  for (var keyObj in this._props) {
    for (var keyGetter in this._props[keyObj]) {
      var item = this._props[keyObj][keyGetter];
      var type = item.type;
      var obj = item.obj;
      var setter = item.setter;
      var destVal = item.destVal;

      var startVal = item.startVal;
      var interpVal = DvtInterpolator.interpolate(this._context, type, startVal, destVal, progress);
      setter.call(obj, interpVal);
    }
  }
};

// Nested class begin //////////////////////////////////////

var DvtAnimatorPropItem = function(type, obj, getter, setter, destVal) {
  this.type = type;
  this.obj = obj;
  this.getter = getter;
  this.setter = setter;
  this.destVal = destVal;
  this.startVal = null;
};

dvt.Obj.createSubclass(DvtAnimatorPropItem, dvt.Obj);

// Nested class end ////////////////////////////////////////
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Abstract base class representing something that can be played, like an animation.
  * @extends {dvt.Obj}
  * @class dvt.Playable
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  */
dvt.Playable = function(context)
{
  this.Init(context);
};

dvt.Obj.createSubclass(dvt.Playable, dvt.Obj);


/**
  * Append a function to the end of the given playable's current onEnd function.
  *
  * @param {dvt.Playable}  playable  playable to append onEnd function to
  * @param {function}  onEnd  new function to append to current onEnd function
  * @param {object}  onEndObj  optional reference to object instance on which the new
  *        onEnd function is defined
  */
dvt.Playable.appendOnEnd = function(playable, onEnd, onEndObj)
{
  if (!playable || !onEnd)
  {
    return;
  }

  var arOnEnd = playable.getOnEnd();
  if (!arOnEnd || !arOnEnd[0])
  {
    playable.setOnEnd(onEnd, onEndObj);
  }
  else
  {
    var newOnEnd = function() 
        {
      arOnEnd[0].call(arOnEnd[1]);
      onEnd.call(onEndObj);
    };
    playable.setOnEnd(newOnEnd);
  }
};


/**
  * Prepend a function to the start of the given playable's current onEnd function.
  *
  * @param {dvt.Playable}  playable  playable to prepend onEnd function to
  * @param {function}  onEnd  new function to prepend to current onEnd function
  * @param {object}  onEndObj  optional reference to object instance on which the new
  *        onEnd function is defined
  */
dvt.Playable.prependOnEnd = function(playable, onEnd, onEndObj)
{
  if (!playable || !onEnd)
  {
    return;
  }

  var arOnEnd = playable.getOnEnd();
  if (!arOnEnd || !arOnEnd[0])
  {
    playable.setOnEnd(onEnd, onEndObj);
  }
  else
  {
    var newOnEnd = function() 
        {
      onEnd.call(onEndObj);
      arOnEnd[0].call(arOnEnd[1]);
    };
    playable.setOnEnd(newOnEnd);
  }
};


/**
  * Append a function to the end of the given playable's current onStart function.
  *
  * @param {dvt.Playable}  playable  playable to append onStart function to
  * @param {function}  onStart  new function to append to current onStart function
  * @param {object}  onStartObj  optional reference to object instance on which the new
  *        onStart function is defined
  */
dvt.Playable.appendOnStart = function(playable, onStart, onStartObj)
{
  if (!playable || !onStart || !playable.getOnStart || !playable.setOnStart)
  {
    return;
  }

  var arOnStart = playable.getOnStart();
  if (!arOnStart || !arOnStart[0])
  {
    playable.setOnStart(onStart, onStartObj);
  }
  else
  {
    var newOnStart = function() 
        {
      arOnStart[0].call(arOnStart[1]);
      onStart.call(onStartObj);
    };
    playable.setOnStart(newOnStart);
  }
};


/**
  * Prepend a function to the start of the given playable's current onStart function.
  *
  * @param {dvt.Playable}  playable  playable to prepend onStart function to
  * @param {function}  onStart  new function to prepend to current onStart function
  * @param {object}  onStartObj  optional reference to object instance on which the new
  *        onStart function is defined
  */
dvt.Playable.prependOnStart = function(playable, onStart, onStartObj)
{
  if (!playable || !onStart || !playable.getOnStart || !playable.setOnStart)
  {
    return;
  }

  var arOnStart = playable.getOnStart();
  if (!arOnStart || !arOnStart[0])
  {
    playable.setOnStart(onStart, onStartObj);
  }
  else
  {
    var newOnStart = function() 
        {
      onStart.call(onStartObj);
      arOnStart[0].call(arOnStart[1]);
    };
    playable.setOnStart(newOnStart);
  }
};


/**
  * Append a function to the end of the given playable's current onInit function.
  *
  * @param {dvt.Playable}  playable  playable to append onInit function to
  * @param {function}  onInit  new function to append to current onInit function
  * @param {object}  onInitObj  optional reference to object instance on which the new
  *        onInit function is defined
  */
dvt.Playable.appendOnInit = function(playable, onInit, onInitObj)
{
  if (!playable || !onInit || !playable.getOnInit || !playable.setOnInit)
  {
    return;
  }

  var arOnInit = playable.getOnInit();
  if (!arOnInit || !arOnInit[0])
  {
    playable.setOnInit(onInit, onInitObj);
  }
  else
  {
    var newOnInit = function() 
        {
      arOnInit[0].call(arOnInit[1]);
      onInit.call(onInitObj);
    };
    playable.setOnInit(newOnInit);
  }
};


/**
  * Prepend a function to the start of the given playable's current onInit function.
  *
  * @param {dvt.Playable}  playable  playable to prepend onInit function to
  * @param {function}  onInit  new function to prepend to current onInit function
  * @param {object}  onInitObj  optional reference to object instance on which the new
  *        onInit function is defined
  */
dvt.Playable.prependOnInit = function(playable, onInit, onInitObj)
{
  if (!playable || !onInit || !playable.getOnInit || !playable.setOnInit)
  {
    return;
  }

  var arOnInit = playable.getOnInit();
  if (!arOnInit || !arOnInit[0])
  {
    playable.setOnInit(onInit, onInitObj);
  }
  else
  {
    var newOnInit = function() 
        {
      onInit.call(onInitObj);
      arOnInit[0].call(arOnInit[1]);
    };
    playable.setOnInit(newOnInit);
  }
};


/**
  * @protected
  */
dvt.Playable.prototype.Init = function(context)
{
  this.Context = context;
  this._onEnd = null;
  this._onEndObj = null;
};

/**
  * Set the function to call when this playable ends.
  *
  * @param {function}  onEnd  function to call when this playable ends
  * @param {object}  onEndObj  optional reference to object instance on which the
  *        onEnd function is defined
  */
dvt.Playable.prototype.setOnEnd = function(onEnd, onEndObj)
{
  this._onEnd = onEnd;
  if (onEndObj)
  {
    this._onEndObj = onEndObj;
  }
  else
  {
    this._onEndObj = null;
  }
  this.OnEndUpdated();
};


/**
  * Get the function to call when this playable ends.
  * Returns an array of two elements:
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  *
  * @type {array}
  */
dvt.Playable.prototype.getOnEnd = function()
{
  return [this._onEnd, this._onEndObj];
};


/**
  * @protected
  * Called when the onEnd funciton on this playable is set.
  */
dvt.Playable.prototype.OnEndUpdated = function()
{
  //subclasses must override
};

/**
  * Returns the duration of this animation, in seconds.
  * @type {number}
  */
dvt.Playable.prototype.getDuration = function()
{
  //subclasses must override
  return 0;
};

/**
 * Initializes the start and end states of the animation.  This should be called prior to deferring the animation on a
 * timeout or request animation frame.
 */
dvt.Playable.prototype.initialize = function() {
  //subclasses must override if they are supporting the bImmediate flag in play()
};

/**
  * Play this item.
  * @param {boolean} bImmediate true to begin the animation immediately.  This should generally be false when used by
  *                             components, so that the animation is started after the browser rendering is complete.
  */
dvt.Playable.prototype.play = function(bImmediate)
{
  //subclasses must override
};

/**
  * Stop this playable.
  */
dvt.Playable.prototype.stop = function(bJumpToEnd)
{
  //subclasses must override
};


/**
  * Pause this playable.
  */
dvt.Playable.prototype.pause = function()
{
  //subclasses must override
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing a set of DvtPlayables that are played at the same time.
  * The playables should be passed into the constructor as either:
  * 1) individual arguments, for example:
  *    new dvt.ParallelPlayable(context, playable1, playable2, ...), or
  * 2) a single Array, for example:
  *    new dvt.ParallelPlayable(context, [playable1, playable2, ...]);
  * @extends {dvt.Playable}
  * @class dvt.ParallelPlayable
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  */
dvt.ParallelPlayable = function(context)
{
  var arPlayables;
  if (arguments && arguments.length > 1 && arguments[1] instanceof Array)
  {
    arPlayables = arguments[1];
  }
  else
  {
    arPlayables = dvt.ArrayUtils.argsToArray(arguments);
    //remove the context from the arPlayables array
    arPlayables.splice(0, 1);
  }

  this.Init(context, arPlayables);
};

dvt.Obj.createSubclass(dvt.ParallelPlayable, dvt.Playable);


/**
  * @protected
  * @override
  */
dvt.ParallelPlayable.prototype.Init = function(context, arPlayables)
{
  dvt.ParallelPlayable.superclass.Init.call(this, context);

  this._runningCounter = 0;
  this._arPlayables = arPlayables ? arPlayables : [];
  this._bStarted = false;
};


/**
  * Get the list of playables.
  * @return {array}
  */
dvt.ParallelPlayable.prototype.getPlayables = function()
{
  return this._arPlayables;
};

/**
 * @override
 */
dvt.ParallelPlayable.prototype.getDuration = function()
{
  var duration = 0;
  for (var i = 0; i < this._arPlayables.length; i++) {
    var playable = this._arPlayables[i];
    if (playable instanceof dvt.Playable)
      duration = Math.max(duration, playable.getDuration());
  }
  return duration;
};

/**
 * @override
 */
dvt.ParallelPlayable.prototype.initialize = function() {
  for (var i = 0; i < this._arPlayables.length; i++)
  {
    if (this._arPlayables[i] instanceof dvt.Playable)
      this._arPlayables[i].initialize();
  }
};

/**
  * @override
  */
dvt.ParallelPlayable.prototype.play = function(bImmediate)
{
  if (this._arPlayables.length > 0)
  {
    if (bImmediate)
      this._play();
    else {
      // Play after a quick timeout allowing the browser to render the bulk of the DOM and any subsequent components.
      this.initialize();
      dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this._play));
    }
  }
  else {
    // The onEnd listener should still be called.
    dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this.DoEnd));
  }
};

/**
 * Called by play with an optional timeout to enable the animation to run more smoothly.
 * @private
 */
dvt.ParallelPlayable.prototype._play = function() {
  var playable;
  for (var i = 0; i < this._arPlayables.length; i++)
  {
    playable = this._arPlayables[i];
    if (playable instanceof dvt.Playable)
    {
      if (!this._bStarted)
      {
        this._runningCounter++;

        //call internal onEnd function when each Playable ends
        dvt.Playable.appendOnEnd(playable, this.OnPlayableEnd, this);
      }

      // Perform the animation immediately since this is not part of a slow component render operation.
      playable.play(true);
    }
  }

  this._bStarted = true;
};

/**
  * @override
  */
dvt.ParallelPlayable.prototype.stop = function(bJumpToEnd)
{
  var playable;
  for (var i = 0; i < this._arPlayables.length; i++)
  {
    playable = this._arPlayables[i];
    if (playable instanceof dvt.Playable)
    {
      playable.stop(bJumpToEnd);
    }
  }
};


/**
  * @override
  */
dvt.ParallelPlayable.prototype.pause = function()
{
  for (var i = 0; i < this._arPlayables.length; i++)
  {
    var playable = this._arPlayables[i];
    if (playable instanceof dvt.Playable)
    {
      playable.pause();
    }
  }
};


/**
  * @protected
  * Called after each playable ends.
  */
dvt.ParallelPlayable.prototype.OnPlayableEnd = function()
{
  //decrement the count of running playables
  this._runningCounter--;

  //if no more running, call the onEnd function for this ParallelPlayable
  if (this._runningCounter < 1)
  {
    this.DoEnd();
  }
};


/**
  * @protected
  * Called after all the playables have finished.
  */
dvt.ParallelPlayable.prototype.DoEnd = function()
{
  if (this._onEnd)
  {
    this._onEnd.call(this._onEndObj);
  }
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing a set of DvtPlayables that are played one after another.
  * The playables should be passed into the constructor as either:
  * 1) individual arguments, for example:
  *    new dvt.ParallelPlayable(context, playable1, playable2, ...), or
  * 2) a single Array, for example:
  *    new dvt.ParallelPlayable(context, [playable1, playable2, ...]);
  * @extends {dvt.Playable}
  * @class dvt.ParallelPlayable
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  */
dvt.SequentialPlayable = function(context)
{
  var arPlayables;
  if (arguments && arguments.length > 1 && arguments[1] instanceof Array)
  {
    arPlayables = arguments[1];
  }
  else
  {
    arPlayables = dvt.ArrayUtils.argsToArray(arguments);
    //remove the context from the arPlayables array
    arPlayables.splice(0, 1);
  }

  this.Init(context, arPlayables);
};

dvt.Obj.createSubclass(dvt.SequentialPlayable, dvt.Playable);


/**
  * @protected
  * @override
  */
dvt.SequentialPlayable.prototype.Init = function(context, arPlayables)
{
  dvt.SequentialPlayable.superclass.Init.call(this, context);

  this._arPlayables = arPlayables ? arPlayables : [];
  this._currIndex = -1;
  this._bStarted = false;
};

/**
  * Get the list of playables.
  * @type {Array}
  */
dvt.SequentialPlayable.prototype.getPlayables = function()
{
  return this._arPlayables;
};

/**
 * @override
 */
dvt.SequentialPlayable.prototype.getDuration = function()
{
  var duration = 0;
  for (var i = 0; i < this._arPlayables.length; i++) {
    var playable = this._arPlayables[i];
    if (playable instanceof dvt.Playable)
      duration += playable.getDuration();
  }
  return duration;
};

/**
 * @override
 */
dvt.SequentialPlayable.prototype.initialize = function() {
  if (this._arPlayables.length > 0 && this._arPlayables[0] instanceof dvt.Playable)
    this._arPlayables[0].initialize();
};

/**
  * @override
  */
dvt.SequentialPlayable.prototype.play = function(bImmediate)
{
  if (this._arPlayables && this._arPlayables.length > 0)
  {
    if (bImmediate)
      this._play();
    else {
      // Play after a quick timeout allowing the browser to render the bulk of the DOM and any subsequent components.
      this.initialize();
      dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this._play));
    }
  }
  else {
    // The onEnd listener should still be called.
    dvt.Context.requestAnimationFrame(dvt.Obj.createCallback(this, this.DoEnd));
  }
};

/**
 * Called by play with an optional timeout to enable the animation to run more smoothly.
 * @private
 */
dvt.SequentialPlayable.prototype._play = function() {
  if (this._bStarted)
  {
    var currPlayable = this._arPlayables[this._currIndex];
    if (currPlayable instanceof dvt.Playable)
    {
      // Perform the animation immediately since this is not part of a slow component render operation.
      currPlayable.play(true);
    }
    return;
  }

  var firstPlayable;
  if (this._arPlayables[0] instanceof dvt.Playable)
    firstPlayable = this._arPlayables[0];

  var lastPlayable;
  if (this._arPlayables[this._arPlayables.length - 1] instanceof dvt.Playable)
    lastPlayable = this._arPlayables[this._arPlayables.length - 1];

  var playable;
  for (var i = 0; i < this._arPlayables.length - 1; i++)
  {
    playable = this._arPlayables[i];
    if (playable instanceof dvt.Playable)
    {
      //at the end of each playable, play the next one
      dvt.Playable.appendOnEnd(playable, this.DoSequenceStep, this);
    }
  }

  //call the onEnd function for this dvt.SequentialPlayable at the very
  //end of the sequence
  //if (playable)
  //  dvt.Playable.appendOnEnd(playable, this.DoEnd, this);
  if (lastPlayable)
    dvt.Playable.appendOnEnd(lastPlayable, this.DoEnd, this);

  this._bStarted = true;
  this._currIndex = 0;

  // Perform the animation immediately since this is not part of a slow component render operation.
  if (firstPlayable)
    firstPlayable.play(true);
};

/**
  * @protected
  * Called after each playable, except the last one, ends.
  */
dvt.SequentialPlayable.prototype.DoSequenceStep = function()
{
  var playable = this._arPlayables[++this._currIndex];
  if (playable instanceof dvt.Playable)
  {
    // Perform the animation immediately since this is not part of a slow component render operation.
    playable.play(true);
  }
  else
  {
    this.DoSequenceStep();
  }
};


/**
  * @override
  */
dvt.SequentialPlayable.prototype.stop = function(bJumpToEnd)
{
  if (this._arPlayables)
  {
    var playable;
    for (var i = this._currIndex; i < this._arPlayables.length; i++)
    {
      playable = this._arPlayables[i];
      if (playable && playable instanceof dvt.Playable)
      {
        playable.stop(bJumpToEnd);
      }
    }
  }
};


/**
  * @override
  */
dvt.SequentialPlayable.prototype.pause = function()
{
  if (this._arPlayables)
  {
    var playable = this._arPlayables[this._currIndex];
    if (playable instanceof dvt.Playable)
    {
      playable.pause();
    }
  }
};


/**
  * @protected
  * Called after the last playable has finished.
  */
dvt.SequentialPlayable.prototype.DoEnd = function()
{
  if (this._onEnd)
  {
    this._onEnd.call(this._onEndObj);
  }
};
/**
 * Animation handler for black box animations.
 * @class dvt.BlackBoxAnimationHandler
 */
dvt.BlackBoxAnimationHandler = function() {};

dvt.Obj.createSubclass(dvt.BlackBoxAnimationHandler, dvt.Obj);

// Black Box Animation Types
dvt.BlackBoxAnimationHandler.ALPHA_FADE = 'alphaFade';
dvt.BlackBoxAnimationHandler.CONVEYOR_FROM_RIGHT = 'conveyorFromRight';
dvt.BlackBoxAnimationHandler.CONVEYOR_FROM_LEFT = 'conveyorFromLeft';
dvt.BlackBoxAnimationHandler.CUBE_TO_RIGHT = 'cubeToRight';
dvt.BlackBoxAnimationHandler.CUBE_TO_LEFT = 'cubeToLeft';
dvt.BlackBoxAnimationHandler.FLIP_RIGHT = 'flipRight';
dvt.BlackBoxAnimationHandler.FLIP_LEFT = 'flipLeft';
dvt.BlackBoxAnimationHandler.TRANSITION_TO_RIGHT = 'transitionToRight';
dvt.BlackBoxAnimationHandler.TRANSITION_TO_LEFT = 'transitionToLeft';
dvt.BlackBoxAnimationHandler.SLIDE_TO_RIGHT = 'slideToRight';
dvt.BlackBoxAnimationHandler.SLIDE_TO_LEFT = 'slideToLeft';
dvt.BlackBoxAnimationHandler.ZOOM = 'zoom';


/**
 * Returns true if the specified animation type should be handled by a black box animation.
 * @param {string} type The animation type.
 * @return {boolean}
 */
dvt.BlackBoxAnimationHandler.isSupported = function(type) {
  return (type == dvt.BlackBoxAnimationHandler.ALPHA_FADE ||
          type == dvt.BlackBoxAnimationHandler.CONVEYOR_FROM_RIGHT ||
          type == dvt.BlackBoxAnimationHandler.CONVEYOR_FROM_LEFT ||
          type == dvt.BlackBoxAnimationHandler.CUBE_TO_RIGHT ||
          type == dvt.BlackBoxAnimationHandler.CUBE_TO_LEFT ||
          type == dvt.BlackBoxAnimationHandler.FLIP_RIGHT ||
          type == dvt.BlackBoxAnimationHandler.FLIP_LEFT ||
          type == dvt.BlackBoxAnimationHandler.TRANSITION_TO_RIGHT ||
          type == dvt.BlackBoxAnimationHandler.TRANSITION_TO_LEFT ||
          type == dvt.BlackBoxAnimationHandler.SLIDE_TO_RIGHT ||
          type == dvt.BlackBoxAnimationHandler.SLIDE_TO_LEFT ||
          type == dvt.BlackBoxAnimationHandler.ZOOM);
};


/**
 * Creates and returns the specified black box animation for the displayables.
 * @param {dvt.Context} context The platform specific context object.
 * @param {string} type The animation type.
 * @param {object} objs The displayable or array of displayables.
 * @param {dvt.Rectangle} bounds The bounds of the objects to animate.
 * @param {number} duration The duration of the animation
 * @return {dvt.Playable} The animation from the old object to the new object.
 */
dvt.BlackBoxAnimationHandler.getInAnimation = function(context, type, objs, bounds, duration) {
  if (type == dvt.BlackBoxAnimationHandler.ALPHA_FADE)
    return new dvt.AnimFadeIn(context, objs, duration);
  else if (type == dvt.BlackBoxAnimationHandler.CONVEYOR_FROM_RIGHT)
    return new DvtAnimConveyorIn(context, objs, dvt.BaseAnimation.DIR_E, duration);
  else if (type == dvt.BlackBoxAnimationHandler.CONVEYOR_FROM_LEFT)
    return new DvtAnimConveyorIn(context, objs, dvt.BaseAnimation.DIR_W, duration);
  else if (type == dvt.BlackBoxAnimationHandler.CUBE_TO_RIGHT)
    return new DvtAnimCubeIn(context, objs, dvt.BaseAnimation.AXIS_Y, dvt.BaseAnimation.ROT_DIR_CLOCKWISE, duration);
  else if (type == dvt.BlackBoxAnimationHandler.CUBE_TO_LEFT)
    return new DvtAnimCubeIn(context, objs, dvt.BaseAnimation.AXIS_Y, dvt.BaseAnimation.ROT_DIR_COUNTERCLOCKWISE, duration);
  else if (type == dvt.BlackBoxAnimationHandler.FLIP_RIGHT)
    return new DvtAnimFlipIn(context, objs, dvt.BaseAnimation.AXIS_Y, dvt.BaseAnimation.ROT_DIR_CLOCKWISE, duration);
  else if (type == dvt.BlackBoxAnimationHandler.FLIP_LEFT)
    return new DvtAnimFlipIn(context, objs, dvt.BaseAnimation.AXIS_Y, dvt.BaseAnimation.ROT_DIR_COUNTERCLOCKWISE, duration);
  else if (type == dvt.BlackBoxAnimationHandler.TRANSITION_TO_RIGHT)
    return new dvt.AnimScaleFadeIn(context, objs, bounds, dvt.BaseAnimation.DIR_NW, 0.5, duration);
  else if (type == dvt.BlackBoxAnimationHandler.TRANSITION_TO_LEFT)
    return new dvt.AnimScaleFadeIn(context, objs, bounds, dvt.BaseAnimation.DIR_NE, 0.5, duration);
  else if (type == dvt.BlackBoxAnimationHandler.SLIDE_TO_RIGHT) {
    dvt.BlackBoxAnimationHandler._offsetObjects(objs, -bounds.w, 0);
    return new dvt.AnimMoveBy(context, objs, new dvt.Point(bounds.w, 0), duration);
  }
  else if (type == dvt.BlackBoxAnimationHandler.SLIDE_TO_LEFT) {
    dvt.BlackBoxAnimationHandler._offsetObjects(objs, bounds.w, 0);
    return new dvt.AnimMoveBy(context, objs, new dvt.Point(-bounds.w, 0), duration);
  }
  else if (type == dvt.BlackBoxAnimationHandler.ZOOM)
    return new dvt.AnimScaleFadeIn(context, objs, bounds, dvt.BaseAnimation.DIR_C, 0.5, duration);
  else
    return null;
};


/**
 * Creates and returns the specified black box animation between the old displayable and
 * the new displayable.
 * @param {dvt.Context} context The platform specific context object.
 * @param {string} type The animation type.
 * @param {object} outObjs The displayable or array of displayables to animate out.
 * @param {object} inObjs The displayable or array of displayables to animate in.
 * @param {dvt.Rectangle} bounds The bounds of the objects to animate.
 * @param {number} duration The duration of the animation (in seconds).
 * @return {dvt.Playable} The animation from the old object to the new object.
 */
dvt.BlackBoxAnimationHandler.getCombinedAnimation = function(context, type, outObjs, inObjs, bounds, duration) {
  if (type == dvt.BlackBoxAnimationHandler.ALPHA_FADE)
    return new DvtCombinedAnimFade(context, outObjs, inObjs, duration);
  else if (type == dvt.BlackBoxAnimationHandler.CONVEYOR_FROM_RIGHT)
    return new DvtCombinedAnimConveyor(context, outObjs, inObjs, dvt.BaseAnimation.DIR_W, dvt.BaseAnimation.DIR_E, duration);
  else if (type == dvt.BlackBoxAnimationHandler.CONVEYOR_FROM_LEFT)
    return new DvtCombinedAnimConveyor(context, outObjs, inObjs, dvt.BaseAnimation.DIR_E, dvt.BaseAnimation.DIR_W, duration);
  else if (type == dvt.BlackBoxAnimationHandler.CUBE_TO_RIGHT)
    return new dvt.CombinedAnimCube(context, outObjs, inObjs, dvt.BaseAnimation.AXIS_Y, dvt.BaseAnimation.ROT_DIR_CLOCKWISE, duration);
  else if (type == dvt.BlackBoxAnimationHandler.CUBE_TO_LEFT)
    return new dvt.CombinedAnimCube(context, outObjs, inObjs, dvt.BaseAnimation.AXIS_Y, dvt.BaseAnimation.ROT_DIR_COUNTERCLOCKWISE, duration);
  else if (type == dvt.BlackBoxAnimationHandler.FLIP_RIGHT)
    return new dvt.CombinedAnimFlip(context, outObjs, inObjs, dvt.BaseAnimation.AXIS_Y, dvt.BaseAnimation.ROT_DIR_CLOCKWISE, duration);
  else if (type == dvt.BlackBoxAnimationHandler.FLIP_LEFT)
    return new dvt.CombinedAnimFlip(context, outObjs, inObjs, dvt.BaseAnimation.AXIS_Y, dvt.BaseAnimation.ROT_DIR_COUNTERCLOCKWISE, duration);
  else if (type == dvt.BlackBoxAnimationHandler.TRANSITION_TO_RIGHT)
    return new DvtCombinedAnimScaleFade(context, outObjs, inObjs, bounds, dvt.BaseAnimation.DIR_SE, dvt.BaseAnimation.DIR_NW, 0.5, duration);
  else if (type == dvt.BlackBoxAnimationHandler.TRANSITION_TO_LEFT)
    return new DvtCombinedAnimScaleFade(context, outObjs, inObjs, bounds, dvt.BaseAnimation.DIR_SW, dvt.BaseAnimation.DIR_NE, 0.5, duration);
  else if (type == dvt.BlackBoxAnimationHandler.SLIDE_TO_RIGHT) {
    dvt.BlackBoxAnimationHandler._offsetObjects(inObjs, -bounds.w, 0);
    return new dvt.CombinedAnimMoveBy(context, outObjs, inObjs, new dvt.Point(bounds.w, 0), new dvt.Point(bounds.w, 0), duration);
  }
  else if (type == dvt.BlackBoxAnimationHandler.SLIDE_TO_LEFT) {
    dvt.BlackBoxAnimationHandler._offsetObjects(inObjs, bounds.w, 0);
    return new dvt.CombinedAnimMoveBy(context, outObjs, inObjs, new dvt.Point(-bounds.w, 0), new dvt.Point(-bounds.w, 0), duration);
  }
  else if (type == dvt.BlackBoxAnimationHandler.ZOOM)
    return new DvtCombinedAnimScaleFade(context, outObjs, inObjs, bounds, dvt.BaseAnimation.DIR_C, dvt.BaseAnimation.DIR_C, 0.5, duration);
  else
    return null;
};


/**
 * Adjusts the objects by the specified offset.
 * @param {object} objs The displayable or array of displayables.
 * @param {number} offsetX The x offset to add.
 * @param {number} offsetY The y offset to add.
 @private
 */
dvt.BlackBoxAnimationHandler._offsetObjects = function(objs, offsetX, offsetY) {
  if (objs.length) {
    for (var i = 0; i < objs.length; i++)
      dvt.BlackBoxAnimationHandler._offsetObjects(objs[i], offsetX, offsetY);
  }
  else if (objs) {
    // Adjust the displayable
    objs.setTranslate(objs.getTranslateX() + offsetX, objs.getTranslateY() + offsetY);
  }
};
/**
 * Animation handler for data objects.
 * @param {dvt.Context} context The platform specific context object.
 * @param {dvt.Container} deleteContainer The container where deletes should be moved for animation.
 * @class dvt.DataAnimationHandler
 * @constructor
 */
dvt.DataAnimationHandler = function(context, deleteContainer) {
  this.Init(context, deleteContainer);
};

dvt.Obj.createSubclass(dvt.DataAnimationHandler, dvt.Obj);

// TODO Document the expected interface for animatable objects:
// getId()
// animateUpdate(oldObj)
// animateDelete()
// animateInsert()

/**
 * The percentage of overlap for animation phases when overlap is enabled.
 * @const
 * @private
 */
dvt.DataAnimationHandler._OVERLAP_RATIO = 0.4;


/**
 * Initializes the handler.
 * @param {dvt.Context} context The platform specific context object.
 * @param {dvt.Container} deleteContainer The container where deletes should be moved for animation.
 * @protected
 */
dvt.DataAnimationHandler.prototype.Init = function(context, deleteContainer) {
  this._context = context;
  this._deleteContainer = deleteContainer;
  this._playables = [];
};


/**
 * Returns the dvt.Context associated with this animation handler.
 * @return {dvt.Context}
 */
dvt.DataAnimationHandler.prototype.getCtx = function() {
  return this._context;
};


/**
 * Constructs an animation between two lists of logical objects.  This function
 * delegates the specific animation behavior to the logical objects.  The animation
 * can be retrieved using getAnimation().
 * @param {array} oldList The list to animate from.
 * @param {array} newList The list to animate to.
 */
dvt.DataAnimationHandler.prototype.constructAnimation = function(oldList, newList) {
  if (!newList || this._context.isOffscreen())
    return;

  // Copy the new objects list, since we will modify it
  newList = newList.slice(0);

  // Loop through the two lists and diff the changes.
  // Note: This implementation considers changes in order to be updates.
  if (oldList) {
    for (var oldIndex = 0; oldIndex < oldList.length; oldIndex++) {
      var oldItem = oldList[oldIndex];
      if (!oldItem) // oldItem must exist for update or delete
        continue;

      // Loop through the new list looking for a match
      var oldId = oldItem.getId();
      var bMatchFound = false;
      for (var newIndex = 0; newIndex < newList.length; newIndex++) {
        var newItem = newList[newIndex];
        if (!newItem) // newItem must exist for update
          continue;

        var newId = newItem.getId();
        if ((oldId === newId) || (oldId && oldId.equals && oldId.equals(newId))) {
          // Match found, remove the item from the new list since it's handled
          newItem.animateUpdate(this, oldItem);
          newList.splice(newIndex, 1);
          bMatchFound = true;
          break;
        }
      }

      // If no match found, it was a delete.  Pass in the delete container so that
      // the object can choose whether to move to the new container.
      if (!bMatchFound) {
        oldItem.animateDelete(this, this._deleteContainer);
      }
    }
  }

  // All remaining objects in newList are inserts
  for (var i = 0; i < newList.length; i++) {
    if (newList[i]) // must be valid object for insert
      newList[i].animateInsert(this);
  }
};


/**
 * Adds the specified playable to this handler's animation.
 * @param {dvt.Playable} playable The playable to add to this animation.
 * @param {number} index The relative ordering of the animation, beginning at 0.
 */
dvt.DataAnimationHandler.prototype.add = function(playable, index) {
  if (!playable)
    return;

  if (!index)
    index = 0;

  // Make sure the playables array is large enough
  while (this._playables.length <= index)
    this._playables.push(new Array());

  // Add the playable to the array
  this._playables[index].push(playable);
};


/**
 * Returns the animation constructed by this handler.
 * @param {boolean=} bOverlap true if the animation phases should be slightly overlapped.  This produces a smoother
 *                             result as long as the objects in each phase are distinct.
 * @return {dvt.Playable} The animation constructed by this handler.
 */
dvt.DataAnimationHandler.prototype.getAnimation = function(bOverlap) {
  // Construct a parallel playable for each phase of the animation
  var playables = [];
  for (var i = 0; i < this._playables.length; i++) {
    // Construct and add the playable for this index in the sequence
    if (this._playables[i].length > 0) {
      var playable = new dvt.ParallelPlayable(this._context, this._playables[i]);
      playables.push(playable);
    }
  }

  if (bOverlap) {
    // Overlap the animation phases for a smoother effect
    var phases = [];
    var startTime = 0;
    for (var phaseIndex = 0; phaseIndex < playables.length; phaseIndex++) {
      if (startTime > 0) {
        // Create the overlap using a sequential playable with empty custom animation for the delay. This is the easiest
        // way to force a delay without introducing delay onto Playable itself.
        var delayPlayable = new dvt.CustomAnimation(this._context, null, startTime);
        phases.push(new dvt.SequentialPlayable(this._context, [delayPlayable, playables[phaseIndex]]));
      }
      else
        phases.push(playables[phaseIndex]);

      // Update the startTime for the next phase
      startTime += (1 - dvt.DataAnimationHandler._OVERLAP_RATIO) * playables[phaseIndex].getDuration();
    }
    return new dvt.ParallelPlayable(this._context, phases);
  }
  else
    return new dvt.SequentialPlayable(this._context, playables);
};


/**
 * Returns the number of playables in this animation.
 * @return {Number} the number of playables in this animation.
 */
dvt.DataAnimationHandler.prototype.getNumPlayables = function()
{
  return this._playables.length;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class defining easing functions for animations.
  * @extends {dvt.Obj}
  * @class dvt.Easing
  * @constructor
  */
dvt.Easing = function()
{
  this.Init();
};

dvt.Obj.createSubclass(dvt.Easing, dvt.Obj);


/**
  * Linear easing function.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type {number}
  */
dvt.Easing.linear = function(progress)
{
  return progress;
};


/**
  * Quadratic easing function that starts slow and speeds up at the beginning.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type {number}
  */
dvt.Easing.quadraticIn = function(progress)
{
  return dvt.Easing.PolyIn(progress, 2);
};


/**
  * Quadratic easing function that starts fast and slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type {number}
  */
dvt.Easing.quadraticOut = function(progress)
{
  return dvt.Easing.PolyOut(progress, 2);
};


/**
  * Quadratic easing function that starts slow, speeds up, and then slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type {number}
  */
dvt.Easing.quadraticInOut = function(progress)
{
  return dvt.Easing.PolyInOut(progress, 2);
};


/**
  * Cubic easing function that starts slow and speeds up at the beginning.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type {number}
  */
dvt.Easing.cubicIn = function(progress)
{
  return dvt.Easing.PolyIn(progress, 3);
};


/**
  * Cubic easing function that starts fast and slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type {number}
  */
dvt.Easing.cubicOut = function(progress)
{
  return dvt.Easing.PolyOut(progress, 3);
};


/**
  * Cubic easing function that starts slow, speeds up, and then slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type {number}
  */
dvt.Easing.cubicInOut = function(progress)
{
  return dvt.Easing.PolyInOut(progress, 3);
};


/**
  * Cubic easing function that starts fast and slows down at the end,
  * overshooting the target and then coming back.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  overshoot  value to overshoot, with higher values
  *        overshooting more (value of 0 means no overshoot,
  *        default value of 1.7 overshoots by about 10%)
  * @type {number}
  */
dvt.Easing.backOut = function(progress, overshoot)
{
  //t = progress, s = overshoot
  //(s+1)*t^3 - s*t^2
  if (!overshoot)
  {
    overshoot = 1.70158;
  }
  progress = 1 - progress;
  return 1 - progress * progress * ((overshoot + 1) * progress - overshoot);
};


/**
  * Cubic easing function that starts slow and speeds up at the beginning,
  * overshooting the starting value in the opposite direction and then
  * proceeding forward.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  overshoot  value to overshoot, with higher values
  *        overshooting more (value of 0 means no overshoot,
  *        default value of 1.7 overshoots by about 10%)
  * @type {number}
  */
dvt.Easing.backIn = function(progress, overshoot)
{
  //t = progress, s = overshoot
  //(s+1)*t^3 - s*t^2
  if (!overshoot)
  {
    overshoot = 1.70158;
  }
  return progress * progress * ((overshoot + 1) * progress - overshoot);
};


/**
  * Easing function that oscillates at the start with an exponentially
  * decaying sine wave.
  *
  * @param {number}  progress  percent progress of the animation
  * @param {number}  amplitude  amplitude of the sine wave
  * @param {number}  period  period of the sine wave
  * @type {number}
  */
dvt.Easing.elasticIn = function(progress, amplitude, period)
{
  if (progress <= 0 || progress >= 1)
  {
    return progress;
  }
  if (!period)
  {
    period = 0.45;
  }
  var s;
  if (!amplitude || amplitude < 1)
  {
    amplitude = 1;
    s = period / 4;
  }
  else
  {
    s = period / (2 * Math.PI) * Math.asin(1 / amplitude);
  }
  return -(amplitude * Math.pow(2, 10 * (progress -= 1)) * Math.sin((progress - s) * (2 * Math.PI) / period));
};


/**
  * Easing function that oscillates at the end with an exponentially
  * decaying sine wave.
  *
  * @param {number}  progress  percent progress of the animation
  * @param {number}  amplitude  amplitude of the sine wave
  * @param {number}  period  period of the sine wave
  * @type {number}
  */
dvt.Easing.elasticOut = function(progress, amplitude, period) {
  return 1 - dvt.Easing.elasticIn(1 - progress, amplitude, period);
};


/**
  * @protected
  * Polynomial easing function that starts slow and speeds up at the beginning.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  exp  exponent of the polynomial
  * @type {number}
  */
dvt.Easing.PolyIn = function(progress, exp)
{
  if (progress < 0)
  {
    return 0;
  }
  if (progress > 1)
  {
    return 1;
  }
  else
  {
    return Math.pow(progress, exp);
  }
};


/**
  * @protected
  * Polynomial easing function that starts fast and slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  exp  exponent of the polynomial
  * @type {number}
  */
dvt.Easing.PolyOut = function(progress, exp)
{
  if (progress < 0)
  {
    return 0;
  }
  if (progress > 1)
  {
    return 1;
  }
  else
  {
    return 1 - Math.pow(1 - progress, exp);
  }
};


/**
  * @protected
  * Polynomial easing function that starts slow, speeds up, and then slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  exp  exponent of the polynomial
  * @type {number}
  */
dvt.Easing.PolyInOut = function(progress, exp)
{
  if (progress < 0)
  {
    return 0;
  }
  if (progress > 1)
  {
    return 1;
  }
  if (progress < .5)
  {
    return .5 * Math.pow(2 * progress, exp);
  }
  else
  {
    return .5 * (2 - Math.pow(2 * (1 - progress), exp));
  }
};


/**
  * @protected
  */
dvt.Easing.prototype.Init = function()
{
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class defining interpolation functions for animations.
  * @extends {dvt.Obj}
  * @class DvtInterpolator
  * @constructor
  */
var DvtInterpolator = function()
{
  this.Init();
};

dvt.Obj.createSubclass(DvtInterpolator, dvt.Obj);


/**
  * Add an interpolator function to use for a given type of value.
  * @param {string}  type  type of value to use interpolator for
  * @param {function}  func  interpolator function
  */
DvtInterpolator.addInterpolator = function(type, func) {
  DvtInterpolator._map[type] = func;
};


/**
  * Remove an interpolator function.
  * @param {string}  type  type of value to remove interpolator for
  */
DvtInterpolator.removeInterpolator = function(type) {
  delete DvtInterpolator._map[type];
};


/**
  * Interpolate a value between the original and destination values for the
  * given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {string}  type  type of value being interpolated
  * @param  origVal  original property value
  * @param  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  */
DvtInterpolator.interpolate = function(context, type, origVal, destVal, progress)
{
  //don't pin progress, so that we can do elastic type easing functions,
  //like backIn and backOut for popIn and popOut anims
  /*if (progress <= 0)
  {
    return origVal;
  }

  if (progress >= 1)
  {
    return destVal;
  }*/

  var interpolatorFunc = DvtInterpolator._getInterpolator(type);
  if (interpolatorFunc) {
    return interpolatorFunc(context, origVal, destVal, progress);
  }

  return destVal;
};


/**
  * @private
  * Get the interpolator to use for the given type of value.
  * @param {string}  type  type of value to interpolate
  * @type {function}
  */
DvtInterpolator._getInterpolator = function(type) {
  return DvtInterpolator._map[type];
};


/**
  * Interpolate a number between the original and destination values for the
  * given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {number}
  * @protected
  */
DvtInterpolator.InterpolateNumber = function(context, origVal, destVal, progress)
{
  //return (origVal + progress * (destVal - origVal));
  return dvt.Math.interpolateNumber(origVal, destVal, progress);
};


/**
  * Interpolate an array of numbers between the original and destination
  * values for the given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {array}
  * @protected
  */
DvtInterpolator.InterpolateNumberArray = function(context, origVal, destVal, progress)
{
  var origLength = origVal.length;
  var destLength = destVal.length;
  var array = [];
  for (var i = 0; i < Math.max(origLength, destLength); i++)
  {
    //if one array is shorter than the other, use the last actual value
    //from the shorter array to interpolate with all the extra elements
    //in the longer array
    var n1;
    var n2;
    if (i < origLength)
    {
      n1 = origVal[i];
    }
    else
    {
      n1 = origVal[origLength - 1];
    }
    if (i < destLength)
    {
      n2 = destVal[i];
    }
    else
    {
      n2 = destVal[destLength - 1];
    }
    array.push(DvtInterpolator.InterpolateNumber(context, n1, n2, progress));
  }
  return array;
};


/**
  * Interpolate a matrix between the original and destination values for the
  * given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {dvt.Matrix}  origVal  original property value
  * @param {dvt.Matrix}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {dvt.Matrix}
  * @protected
  */
DvtInterpolator.InterpolateMatrix = function(context, origVal, destVal, progress)
{
  var newA = DvtInterpolator.InterpolateNumber(context, origVal.getA(), destVal.getA(), progress);
  var newB = DvtInterpolator.InterpolateNumber(context, origVal.getB(), destVal.getB(), progress);
  var newC = DvtInterpolator.InterpolateNumber(context, origVal.getC(), destVal.getC(), progress);
  var newD = DvtInterpolator.InterpolateNumber(context, origVal.getD(), destVal.getD(), progress);
  var newTx = DvtInterpolator.InterpolateNumber(context, origVal.getTx(), destVal.getTx(), progress);
  var newTy = DvtInterpolator.InterpolateNumber(context, origVal.getTy(), destVal.getTy(), progress);

  return new dvt.Matrix(newA, newB, newC, newD, newTx, newTy);
};


/**
  * Interpolate a color between the original and destination values for the
  * given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @protected
  */
DvtInterpolator.InterpolateColor = function(context, origVal, destVal, progress)
{
  return dvt.ColorUtils.interpolateColor(origVal, destVal, progress);
};


/**
  * Interpolate an array of colors between the original and destination
  * values for the given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {array}
  * @protected
  */
DvtInterpolator.InterpolateColorArray = function(context, origVal, destVal, progress)
{
  var origLength = origVal.length;
  var destLength = destVal.length;
  var array = [];
  for (var i = 0; i < Math.max(origLength, destLength); i++)
  {
    //if one array is shorter than the other, use the last actual value
    //from the shorter array to interpolate with all the extra elements
    //in the longer array
    var n1;
    var n2;
    if (i < origLength)
    {
      n1 = origVal[i];
    }
    else
    {
      n1 = origVal[origLength - 1];
    }
    if (i < destLength)
    {
      n2 = destVal[i];
    }
    else
    {
      n2 = destVal[destLength - 1];
    }
    array.push(DvtInterpolator.InterpolateColor(context, n1, n2, progress));
  }
  return array;
};


/**
  * Interpolate an array of polyline points between the original and
  * destination values for the given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {array}
  * @protected
  */
DvtInterpolator.InterpolateGrowPolyline = function(context, origVal, destVal, progress)
{
  if (progress === 0)
  {
    return [destVal[0], destVal[1]];
  }
  else if (progress === 1)
  {
    return destVal;
  }

  var destLength = destVal.length;
  var array = [destVal[0], destVal[1]];
  var totalLength = DvtInterpolator.CalcPolylineLength(destVal);
  var partialLength = progress * totalLength;
  var accumLength = 0;
  var currSegLength;
  for (var i = 2; i < destLength - 1; i += 2)
  {
    var x1 = destVal[i - 2];
    var y1 = destVal[i - 1];
    var x2 = destVal[i];
    var y2 = destVal[i + 1];

    currSegLength = DvtInterpolator.CalcPolylineLength([x1, y1, x2, y2]);

    if (accumLength + currSegLength > partialLength)
    {
      var ratio = (partialLength - accumLength) / currSegLength;
      var diffX = x2 - x1;
      var diffY = y2 - y1;
      array.push(x1 + ratio * diffX);
      array.push(y1 + ratio * diffY);
      break;
    }
    else
    {
      accumLength += currSegLength;

      array.push(x2);
      array.push(y2);
    }
  }
  return array;
};


/**
  * Interpolate an array of path commands between the original and
  * destination values for the given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {array}
  * @protected
  */
DvtInterpolator.InterpolateGrowPath = function(context, origVal, destVal, progress)
{
  if (progress === 0)
  {
    return [destVal[0], destVal[1]];
  }
  else if (progress === 1)
  {
    return destVal;
  }

  var destLength = destVal.length;
  var array = [];
  var totalLength = DvtInterpolator.CalcPathLength(destVal);
  var partialLength = progress * totalLength;
  var accumLength = 0;
  var currSegLength;
  var x1;
  var y1;
  var cpx1;
  var cpy1;
  var cpx2;
  var cpy2;
  var prevX;
  var prevY;
  for (var i = 0; i < destLength; i++)
  {
    var cmd = destVal[i];
    var segArray;
    switch (cmd)
    {
      case 'M':
        x1 = destVal[++i];
        y1 = destVal[++i];
        prevX = x1;
        prevY = y1;
        segArray = [prevX, prevY, prevX, prevY];
        break;
      case 'L':
        x1 = destVal[++i];
        y1 = destVal[++i];
        segArray = [prevX, prevY, x1, y1];
        break;
      case 'Q':
        cpx1 = destVal[++i];
        cpy1 = destVal[++i];
        x1 = destVal[++i];
        y1 = destVal[++i];
        segArray = [prevX, prevY, x1, y1];
        break;
      case 'C':
        cpx1 = destVal[++i];
        cpy1 = destVal[++i];
        cpx2 = destVal[++i];
        cpy2 = destVal[++i];
        x1 = destVal[++i];
        y1 = destVal[++i];
        segArray = [prevX, prevY, x1, y1];
        break;
    }

    currSegLength = DvtInterpolator.CalcPolylineLength(segArray);

    if (accumLength + currSegLength > partialLength)
    {
      var ratio = (partialLength - accumLength) / currSegLength;

      array.push(cmd);
      switch (cmd)
      {
        case 'Q':
          array.push(prevX + ratio * (cpx1 - prevX),
                     prevY + ratio * (cpy1 - prevY));
          break;
        case 'C':
          array.push(prevX + ratio * (cpx1 - prevX),
                     prevY + ratio * (cpy1 - prevY),
                     prevX + ratio * (cpx2 - prevX),
                     prevY + ratio * (cpy2 - prevY));
          break;
      }
      array.push(prevX + ratio * (x1 - prevX),
                 prevY + ratio * (y1 - prevY));
      break;
    }
    else
    {
      accumLength += currSegLength;

      array.push(cmd);
      switch (cmd)
      {
        case 'Q':
          array.push(cpx1, cpy1);
          break;
        case 'C':
          array.push(cpx1, cpy1, cpx2, cpy2);
          break;
      }
      array.push(x1);
      array.push(y1);
    }
    prevX = x1;
    prevY = y1;
  }
  return array;
};

DvtInterpolator.CalcPolylineLength = function(arPoints)
{
  var length = 0;
  var oldX;
  var oldY;
  var xx;
  var yy;
  for (var i = 0; i < arPoints.length; i += 2)
  {
    xx = arPoints[i];
    yy = arPoints[i + 1];

    if (i > 0)
    {
      if (xx === oldX)
      {
        length += (Math.abs(yy - oldY));
      }
      else if (yy === oldY)
      {
        length += (Math.abs(xx - oldX));
      }
      else
      {
        var diffX = Math.abs(xx - oldX);
        var diffY = Math.abs(yy - oldY);
        length += Math.sqrt((diffX * diffX) + (diffY * diffY));
      }
    }

    oldX = xx;
    oldY = yy;
  }
  return length;
};

DvtInterpolator.CalcPathLength = function(arPoints)
{
  var length = 0;
  var oldX;
  var oldY;
  var xx;
  var yy;
  var cmd;
  for (var i = 0; i < arPoints.length; )
  {
    cmd = arPoints[i];
    switch (cmd)
    {
      case 'M':
        xx = arPoints[i + 1];
        yy = arPoints[i + 2];
        oldX = xx;
        oldY = yy;
        i += 3;
        continue;
        break;
      case 'L':
        xx = arPoints[i + 1];
        yy = arPoints[i + 2];
        i += 3;
        break;
      case 'Q':
        xx = arPoints[i + 3];
        yy = arPoints[i + 4];
        i += 5;
        break;
      case 'C':
        xx = arPoints[i + 5];
        yy = arPoints[i + 6];
        i += 7;
        break;
    }

    if (i > 0)
    {
      if (xx === oldX)
      {
        length += (Math.abs(yy - oldY));
      }
      else if (yy === oldY)
      {
        length += (Math.abs(xx - oldX));
      }
      else
      {
        var diffX = Math.abs(xx - oldX);
        var diffY = Math.abs(yy - oldY);
        length += Math.sqrt((diffX * diffX) + (diffY * diffY));
      }
    }

    oldX = xx;
    oldY = yy;
  }
  return length;
};


/**
  * Interpolate a rectangle between the original and destination values for
  * the given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {dvt.Rectangle}  origVal  original property value
  * @param {dvt.Rectangle}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {dvt.Rectangle}
  * @protected
  */
DvtInterpolator.InterpolateRectangle = function(context, origVal, destVal, progress)
{
  var newX = DvtInterpolator.InterpolateNumber(context, origVal.x, destVal.x, progress);
  var newY = DvtInterpolator.InterpolateNumber(context, origVal.y, destVal.y, progress);
  var newW = DvtInterpolator.InterpolateNumber(context, origVal.w, destVal.w, progress);
  var newH = DvtInterpolator.InterpolateNumber(context, origVal.h, destVal.h, progress);

  return new dvt.Rectangle(newX, newY, newW, newH);
};


/**
  * Interpolate a point between the original and destination values for
  * the given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {dvt.Point}  origVal  original property value
  * @param {dvt.Point}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {dvt.Point}
  * @protected
  */
DvtInterpolator.InterpolatePoint = function(context, origVal, destVal, progress)
{
  var newX = DvtInterpolator.InterpolateNumber(context, origVal.x, destVal.x, progress);
  var newY = DvtInterpolator.InterpolateNumber(context, origVal.y, destVal.y, progress);

  return new dvt.Point(newX, newY);
};


/**
  * Interpolate a path between the original and destination
  * values for the given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {array}
  * @protected
  */
DvtInterpolator.InterpolatePath = function(context, origVal, destVal, progress)
{
  var origLength = origVal.length;
  var destLength = destVal.length;
  //TO DO:
  //for now, if the paths are not of equal length, just return the dest val
  if (origLength != destLength)
  {
    return destVal;
  }

  var array = [];
  var i = 0;
  var j = 0;
  for (; i < origLength && j < destLength; )
  {
    var n1 = origVal[i];
    var n2 = destVal[j];
    var bNumberN1 = !isNaN(n1);
    var bNumberN2 = !isNaN(n2);
    if (!bNumberN1 && !bNumberN2)
    {
      if (n1 === n2)
      {
        array.push(n1);
      }
      //TO DO: handle case where commands are different
    }
    else if (bNumberN1 && bNumberN2)
    {
      array.push(DvtInterpolator.InterpolateNumber(context, n1, n2, progress));
    }
    i++;
    j++;
  }
  return array;
};


/**
  * Interpolate a fill between the original and destination values for the
  * given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @protected
  */
DvtInterpolator.InterpolateFill = function(context, origVal, destVal, progress)
{
  if (origVal instanceof dvt.SolidFill && destVal instanceof dvt.SolidFill) {
    var color = DvtInterpolator.InterpolateColor(context, origVal.getColor(), destVal.getColor(), progress);
    var alpha = DvtInterpolator.InterpolateNumber(context, origVal.getAlpha(), destVal.getAlpha(), progress);
    return new dvt.SolidFill(color, alpha);
  }

  return destVal;
};


/**
  * Interpolate a stroke between the original and destination values for the
  * given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @protected
  */
DvtInterpolator.InterpolateStroke = function(context, origVal, destVal, progress)
{
  if (origVal instanceof dvt.SolidStroke && destVal instanceof dvt.SolidStroke) {
    var color = DvtInterpolator.InterpolateColor(context, origVal.getColor(), destVal.getColor(), progress);
    var alpha = DvtInterpolator.InterpolateNumber(context, origVal.getAlpha(), destVal.getAlpha(), progress);
    var width = DvtInterpolator.InterpolateNumber(context, origVal.getWidth(), destVal.getWidth(), progress);
    //clone the destVal because it may have other properties set that
    //we can't interpolate between
    var stroke = destVal.clone();
    stroke.setColor(color);
    stroke.setAlpha(alpha);
    stroke.setWidth(width);
    return stroke;
  }

  return destVal;
};


/**
  * Interpolate an array of polyline coordinates between the original and
  * destination values for the given percent progress.
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type {array}
  * @protected
  */
DvtInterpolator.InterpolatePolyline = function(context, origVal, destVal, progress)
{
  var origLength = origVal.length;
  var destLength = destVal.length;
  var array = [];
  for (var i = 0; i < Math.max(origLength, destLength); i++)
  {
    //if one array is shorter than the other, use the last actual coords
    //from the shorter array to interpolate with all the extra coords
    //in the longer array
    //: use the last coordinate pair, not just the last
    //element in the array
    var endOffset = 2;
    if (i % 2 == 1) {
      endOffset = 1;
    }
    var n1;
    var n2;
    if (i < origLength)
    {
      n1 = origVal[i];
    }
    else
    {
      n1 = origVal[origLength - endOffset];
    }
    if (i < destLength)
    {
      n2 = destVal[i];
    }
    else
    {
      n2 = destVal[destLength - endOffset];
    }
    array.push(DvtInterpolator.InterpolateNumber(context, n1, n2, progress));
  }

  //trim the array to remove redundant coords at the end
  if (destLength < origLength) {
    var arLength = array.length;
    var lastX = array[arLength - 2];
    var lastY = array[arLength - 1];
    for (var i = arLength - 4; i >= 0; i -= 2) {
      var currX = array[i];
      var currY = array[i + 1];
      if (currX == lastX && currY == lastY) {
        array.splice(i, 2);
      }
      else {
        break;
      }
    }
  }

  return array;
};


/**
  * @protected
  */
DvtInterpolator.prototype.Init = function()
{
};


//need to define the map after the functions are defined above
/**
  * @private
  */
DvtInterpolator._map = {};
DvtInterpolator._map[dvt.Animator.TYPE_NUMBER] = DvtInterpolator.InterpolateNumber;
DvtInterpolator._map[dvt.Animator.TYPE_MATRIX] = DvtInterpolator.InterpolateMatrix;
DvtInterpolator._map[dvt.Animator.TYPE_NUMBER_ARRAY] = DvtInterpolator.InterpolateNumberArray;
DvtInterpolator._map[dvt.Animator.TYPE_COLOR] = DvtInterpolator.InterpolateColor;
DvtInterpolator._map[dvt.Animator.TYPE_COLOR_ARRAY] = DvtInterpolator.InterpolateColorArray;
DvtInterpolator._map[dvt.Animator.TYPE_GROW_POLYLINE] = DvtInterpolator.InterpolateGrowPolyline;
DvtInterpolator._map[dvt.Animator.TYPE_RECTANGLE] = DvtInterpolator.InterpolateRectangle;
DvtInterpolator._map[dvt.Animator.TYPE_POINT] = DvtInterpolator.InterpolatePoint;
DvtInterpolator._map[dvt.Animator.TYPE_PATH] = DvtInterpolator.InterpolatePath;
DvtInterpolator._map[dvt.Animator.TYPE_GROW_PATH] = DvtInterpolator.InterpolateGrowPath;
DvtInterpolator._map[dvt.Animator.TYPE_FILL] = DvtInterpolator.InterpolateFill;
DvtInterpolator._map[dvt.Animator.TYPE_STROKE] = DvtInterpolator.InterpolateStroke;
DvtInterpolator._map[dvt.Animator.TYPE_POLYLINE] = DvtInterpolator.InterpolatePolyline;
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing a timer.
  * @extends {dvt.Obj}
  * @class dvt.Timer
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param {number}  interval  interval between timer ticks, in milliseconds
  * @param {function}  callback  function to call for each timer tick
  * @param {object}  callbackObj  optional object instance that callback function is defined on
  * @param {number}  repeatCount  optional number of times for timer to repeat;
  *        timer repeats indefinitely if 0 or undefined
  */
dvt.Timer = function(context, interval, callback, callbackObj, repeatCount)
{
  this.Init(context, interval, callback, callbackObj, repeatCount);
};

dvt.Obj.createSubclass(dvt.Timer, dvt.Obj);


/**
  * @protected
  */
dvt.Timer.prototype.Init = function(context, interval, callback, callbackObj, repeatCount)
{
  this._interval = interval; //in ms
  this._callback = callback;
  this._callbackObj = callbackObj;

  this._repeatCount = repeatCount;
  this._bRunning = false;
  this._numIterations = 0;
};


/**
  * Start this timer.
  */
dvt.Timer.prototype.start = function()
{
  if (!this._bRunning)
  {
    this._bRunning = true;
    this.StartTimer();
  }
};


/**
  * Stop this timer.
  */
dvt.Timer.prototype.stop = function()
{
  if (this._bRunning)
  {
    this._bRunning = false;
    this.StopTimer();
  }
};


/**
 * Reset this timer.
 */
dvt.Timer.prototype.reset = function()
{
  if (this._bRunning) {
    this.stop();
  }

  this._numIterations = 0;
};


/**
  * Determine if this timer is running.
  * @type {boolean}
  */
dvt.Timer.prototype.isRunning = function()
{
  return this._bRunning;
};


/**
  * @protected
  * Handle a timer tick.
  */
dvt.Timer.prototype.HandleTimer = function()
{
  if (this._callback)
  {
    this._callback.call(this._callbackObj);

    if (this._repeatCount)
    {
      this._numIterations++;
      if (this._numIterations >= this._repeatCount)
      {
        this.stop();
      }
    }
  }
};


/**
  * Set the interval between timer ticks, in milliseconds.
  * @param {number}  interval  interval between timer ticks, in milliseconds
  */
dvt.Timer.prototype.setInterval = function(interval)
{
  var i = interval;
  if (i < 0)
  {
    i = 0;
  }
  var oldBRunning = this._bRunning;
  if (oldBRunning)
  {
    this.stop();
  }
  this._interval = i;
  if (oldBRunning)
  {
    this.start();
  }
};


/**
  * Get the interval between timer ticks.
  * @type {number}
  */
dvt.Timer.prototype.getInterval = function()
{
  return this._interval;
};


/**
 * Starts the internal timer implementation.  Called when the timer is started.
 * @protected
 */
dvt.Timer.prototype.StartTimer = function()
{
  var timer = this;
  var timerCallback = this.HandleTimer;
  this._timerId = window.setInterval(function() {timerCallback.call(timer)}, this.getInterval());
};


/**
 * Stops the internal timer implementation.  Called when the timer is stopped.
 * @protected
  */
dvt.Timer.prototype.StopTimer = function()
{
  if (this._timerId)
  {
    window.clearInterval(this._timerId);
    this._timerId = null;
  }
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Abstract base class representing an animation.
  * @extends {dvt.Playable}
  * @class dvt.BaseAnimation
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.BaseAnimation = function(context, objs, duration, delay)
{
  this.Init(context, objs, duration, delay);
};

dvt.Obj.createSubclass(dvt.BaseAnimation, dvt.Playable);


/**
  * Easing: linear.
  */
dvt.BaseAnimation.EASING_LINEAR = 1;


/**
  * Easing: cubic in and out.
  */
dvt.BaseAnimation.EASING_CUBIC_IN_OUT = 2;


/**
  * Easing: cubic in.
  */
dvt.BaseAnimation.EASING_CUBIC_IN = 3;


/**
  * Easing: cubic out.
  */
dvt.BaseAnimation.EASING_CUBIC_OUT = 4;


/**
  * Easing: quadratic in and out.
  */
dvt.BaseAnimation.EASING_QUADRATIC_IN_OUT = 5;


/**
  * Easing: quadratic in.
  */
dvt.BaseAnimation.EASING_QUADRATIC_IN = 6;


/**
  * Easing: quadratic out.
  */
dvt.BaseAnimation.EASING_QUADRATIC_OUT = 7;


/**
  * Easing: bounce in.
  */
dvt.BaseAnimation.EASING_BOUNCE_IN = 8;


/**
  * Easing: bounce out.
  */
dvt.BaseAnimation.EASING_BOUNCE_OUT = 9;


/**
  * Easing: elastic in.
  */
dvt.BaseAnimation.EASING_ELASTIC_IN = 10;


/**
  * Easing: elastic out.
  */
dvt.BaseAnimation.EASING_ELASTIC_OUT = 11;


/**
  * Direction: center.
  */
dvt.BaseAnimation.DIR_C = 1;


/**
  * Direction: north.
  */
dvt.BaseAnimation.DIR_N = 2;


/**
  * Direction: northeast.
  */
dvt.BaseAnimation.DIR_NE = 3;


/**
  * Direction: east.
  */
dvt.BaseAnimation.DIR_E = 4;


/**
  * Direction: southeast.
  */
dvt.BaseAnimation.DIR_SE = 5;


/**
  * Direction: south.
  */
dvt.BaseAnimation.DIR_S = 6;


/**
  * Direction: southwest.
  */
dvt.BaseAnimation.DIR_SW = 7;


/**
  * Direction: west.
  */
dvt.BaseAnimation.DIR_W = 8;


/**
  * Direction: northwest.
  */
dvt.BaseAnimation.DIR_NW = 9;


//axis constants
/**
 * Axis: x-axis
 */
dvt.BaseAnimation.AXIS_X = 1;


/**
 * Axis: y-axis
 */
dvt.BaseAnimation.AXIS_Y = 2;


//rotation directions
/**
 * Rotation direction: clockwise
 */
dvt.BaseAnimation.ROT_DIR_CLOCKWISE = 1;


/**
 * Rotation direction: counter-clockwise
 */
dvt.BaseAnimation.ROT_DIR_COUNTERCLOCKWISE = 2;


/**
  * @protected
  * Get the easing function corresponding to the given constant.
  * @param easing  constant representing the easing function
  * @type {function}
  */
dvt.BaseAnimation.GetEasingFunction = function(easing)
{
  switch (easing)
  {
    case dvt.BaseAnimation.EASING_LINEAR:
      return dvt.Easing.linear;
    case dvt.BaseAnimation.EASING_CUBIC_IN:
      return dvt.Easing.cubicIn;
    case dvt.BaseAnimation.EASING_CUBIC_OUT:
      return dvt.Easing.cubicOut;
    case dvt.BaseAnimation.EASING_QUADRATIC_IN_OUT:
      return dvt.Easing.quadraticInOut;
    case dvt.BaseAnimation.EASING_QUADRATIC_IN:
      return dvt.Easing.quadraticIn;
    case dvt.BaseAnimation.EASING_QUADRATIC_OUT:
      return dvt.Easing.quadraticOut;
    case dvt.BaseAnimation.EASING_BOUNCE_IN:
      return dvt.Easing.backIn;
    case dvt.BaseAnimation.EASING_BOUNCE_OUT:
      return dvt.Easing.backOut;
    case dvt.BaseAnimation.EASING_ELASTIC_IN:
      return dvt.Easing.elasticIn;
    case dvt.BaseAnimation.EASING_ELASTIC_OUT:
      return dvt.Easing.elasticOut;
    case dvt.BaseAnimation.EASING_CUBIC_IN_OUT:
    default:
      return dvt.Easing.cubicInOut;
  }
};


/**
  * @protected
  * Get the point corresponding to the given compass direction
  * on the given bounding box.
  * @param {dvt.Rectangle}  boundsRect  bounding box
  * @param direction  constant representing the compass direction
  * @type {dvt.Point}
  */
dvt.BaseAnimation.GetCompassPoint = function(boundsRect, direction)
{
  switch (direction)
  {
    case dvt.BaseAnimation.DIR_N:
      return new dvt.Point(boundsRect.x + 0.5 * boundsRect.w, boundsRect.y);
    case dvt.BaseAnimation.DIR_NE:
      return new dvt.Point(boundsRect.x + boundsRect.w, boundsRect.y);
    case dvt.BaseAnimation.DIR_E:
      return new dvt.Point(boundsRect.x + boundsRect.w, boundsRect.y + 0.5 * boundsRect.h);
    case dvt.BaseAnimation.DIR_SE:
      return new dvt.Point(boundsRect.x + boundsRect.w, boundsRect.y + boundsRect.h);
    case dvt.BaseAnimation.DIR_S:
      return new dvt.Point(boundsRect.x + 0.5 * boundsRect.w, boundsRect.y + boundsRect.h);
    case dvt.BaseAnimation.DIR_SW:
      return new dvt.Point(boundsRect.x, boundsRect.y + boundsRect.h);
    case dvt.BaseAnimation.DIR_W:
      return new dvt.Point(boundsRect.x, boundsRect.y + 0.5 * boundsRect.h);
    case dvt.BaseAnimation.DIR_NW:
      return new dvt.Point(boundsRect.x, boundsRect.y);
    case dvt.BaseAnimation.DIR_C:
    default:
      return new dvt.Point(boundsRect.x + 0.5 * boundsRect.w, boundsRect.y + 0.5 * boundsRect.h);
  }
};


/**
  * @protected
  * Get the point to position the given object rectangle so that it aligns to the
  * boundary rectangle in the compass direction.
  * @param {dvt.Rectangle}  objRect  object bounding box
  * @param {dvt.Rectangle}  boundsRect  bounding box
  * @param direction  constant representing the compass direction
  * @type {dvt.Point}
  */
dvt.BaseAnimation.GetAlignCompassPoint = function(objRect, boundsRect, direction)
{
  var compassPoint = dvt.BaseAnimation.GetCompassPoint(boundsRect, direction);
  switch (direction)
  {
    case dvt.BaseAnimation.DIR_N:
      return new dvt.Point(compassPoint.x - 0.5 * objRect.w, compassPoint.y);
    case dvt.BaseAnimation.DIR_NE:
      return new dvt.Point(compassPoint.x - objRect.w, compassPoint.y);
    case dvt.BaseAnimation.DIR_E:
      return new dvt.Point(compassPoint.x - objRect.w, compassPoint.y - 0.5 * objRect.h);
    case dvt.BaseAnimation.DIR_SE:
      return new dvt.Point(compassPoint.x - objRect.w, compassPoint.y - objRect.h);
    case dvt.BaseAnimation.DIR_S:
      return new dvt.Point(compassPoint.x - 0.5 * objRect.w, compassPoint.y - objRect.h);
    case dvt.BaseAnimation.DIR_SW:
      return new dvt.Point(compassPoint.x, compassPoint.y - objRect.h);
    case dvt.BaseAnimation.DIR_W:
      return new dvt.Point(compassPoint.x, compassPoint.y - 0.5 * objRect.h);
    case dvt.BaseAnimation.DIR_NW:
      return new dvt.Point(compassPoint.x, compassPoint.y);
    case dvt.BaseAnimation.DIR_C:
    default:
      return new dvt.Point(compassPoint.x - 0.5 * objRect.w, compassPoint.y - 0.5 * objRect.h);
  }
};


/**
  * @protected
  * @override
  */
dvt.BaseAnimation.prototype.Init = function(context, objs, duration, delay)
{
  dvt.BaseAnimation.superclass.Init.call(this, context);

  this._context = context;

  if (objs instanceof Array)
  {
    this._arObjects = objs;
  }
  else
  {
    this._arObjects = [objs];
  }

  this._duration = (duration ? duration : .5);
  this._delay = (delay ? delay : 0);
  this._easing = dvt.BaseAnimation.EASING_CUBIC_IN_OUT;
  this._bInitialized = false;

  this._bSaveAndRestoreOriginalMatrices = false;
  this._origMatrixArray = null;
  this._bHideObjectsOnEnd = false;

  this.CreateAnimator(context);
};


/**
  * @protected
  * Get the platform dependent context object.
  * @type {dvt.Context}
  */
dvt.BaseAnimation.prototype.GetContext = function()
{
  return this._context;
};


/**
 * Determine if this animation is running.
 * @type {boolean}
 */
dvt.BaseAnimation.prototype.isRunning = function()
{
  if (this._animator) {
    return this._animator.isRunning();
  }
  return false;
};

/**
 * @override
 */
dvt.BaseAnimation.prototype.initialize = function() {
  if (!this._bInitialized)
  {
    //initialize the desired end results of the animation before the start
    //states because the end results may depend on the object states
    //before the start states are applied
    this._initializeEndStates(this._arObjects);
    //initialize the display objects appropriately for the start of the animation
    this._initializeStartStates(this._arObjects);

    this.InitializePlay();

    this._bInitialized = true;
  }
};

/**
  * @override
  */
dvt.BaseAnimation.prototype.play = function(bImmediate)
{
  // Initialize the start and end states.
  this.initialize();

  if (this._animator)
    this._animator.play(bImmediate);
};


/**
  * @override
  */
dvt.BaseAnimation.prototype.stop = function(bJumpToEnd)
{
  if (this._animator)
    this._animator.stop(bJumpToEnd);
};


/**
  * @override
  */
dvt.BaseAnimation.prototype.pause = function()
{
  if (this._animator)
    this._animator.pause();
};

/**
  * @override
  */
dvt.BaseAnimation.prototype.getDuration = function()
{
  return this._duration;
};

/**
  * Set the duration of this animation.
  * @param {number}  duration  duration of this animation, in seconds
  */
dvt.BaseAnimation.prototype.setDuration = function(duration)
{
  this._duration = (duration ? duration : 0);

  if (this._animator)
    this._animator.setDuration(this._duration);
};


/**
  * Get the delay for the start of this animation, in seconds.
  * @type {number}
  */
dvt.BaseAnimation.prototype.getDelay = function()
{
  return this._delay;
};


/**
  * Set the delay for the start of this animation.
  * @param {number}  delay  delay for the start of this animation, in seconds
  */
dvt.BaseAnimation.prototype.setDelay = function(delay)
{
  this._delay = (delay ? delay : 0);

  if (this._animator)
    this._animator.setDelay(this._delay);
};


/**
  * Get the easing function for this animation.
  * Returns one of the EASING_ constants defined on dvt.BaseAnimation.
  */
dvt.BaseAnimation.prototype.getEasing = function()
{
  return this._easing;
};


/**
  * Set the easing function for this animation.
  * @param  easing  one of the EASING_ constants defined on dvt.BaseAnimation
  */
dvt.BaseAnimation.prototype.setEasing = function(easing)
{
  this._easing = easing;

  if (this._animator)
    this._animator.setEasing(dvt.BaseAnimation.GetEasingFunction(this._easing));
};


/**
  * @protected
  * Create the underlying animator used by this animation.
  * @param {dvt.Context}  context  platform specific context object
  */
dvt.BaseAnimation.prototype.CreateAnimator = function(context)
{
  this._animator = new dvt.Animator(context, this._duration, this._delay, dvt.BaseAnimation.GetEasingFunction(this._easing));
  this._animator.setOnEnd(this.OnAnimEnd, this);
};


/**
  * @protected
  * Called when the underlying animator ends.
  */
dvt.BaseAnimation.prototype.OnAnimEnd = function()
{
  //hide objects first
  if (this._bHideObjectsOnEnd)
  {
    this.HideObjects();
  }

  //restore original transforms after hiding objects
  if (this._bSaveAndRestoreOriginalMatrices)
  {
    this.RestoreOriginalMatrices();
  }

  //call external onEnd func after any internal cleanup
  if (this._onEnd)
  {
    this._onEnd.call(this._onEndObj);
  }
};

/**
  * @protected
  * Called when play is called.
  */
dvt.BaseAnimation.prototype.InitializePlay = function()
{
  //for subclasses to implement
};


/**
  * Called when play is called to initialize the start states of
  * the objects being animated.
  * @param {array}  arObjects  array of objects being animated
  * @private
  */
dvt.BaseAnimation.prototype._initializeStartStates = function(arObjects)
{
  if (arObjects)
  {
    var obj;
    for (var i = 0; i < arObjects.length; i++)
    {
      obj = arObjects[i];
      if (obj)
      {
        if (this._bSaveAndRestoreOriginalMatrices)
        {
          if (!this._origMatrixArray)
          {
            this._origMatrixArray = [];
          }

          this._origMatrixArray.push(obj.getMatrix());
        }

        this.InitStartState(obj);
      }
    }
  }
};


/**
  * Called when play is called to initialize the end states of
  * the objects being animated.
  * @param {array}  arObjects  array of objects being animated
  * @private
  */
dvt.BaseAnimation.prototype._initializeEndStates = function(arObjects)
{
  if (arObjects)
  {
    var obj;
    for (var i = 0; i < arObjects.length; i++)
    {
      obj = arObjects[i];
      if (obj)
      {
        this.InitEndState(obj);
      }
    }
  }
};


/**
  * @protected
  * Initialize the start state of the given object being animated.
  * @param {object}  obj  object being animated
  */
dvt.BaseAnimation.prototype.InitStartState = function(obj)
{
  //subclasses must implement
};


/**
  * @protected
  * Initialize the end state of the given object being animated.
  * @param {object}  obj  object being animated
  */
dvt.BaseAnimation.prototype.InitEndState = function(obj)
{
  //subclasses must implement
};


/**
  * @protected
  * Set objects to be visible.
  */
dvt.BaseAnimation.prototype.ShowObjects = function()
{
  this.SetObjectsVisible(true);
};


/**
  * @protected
  * Set objects to be hidden.
  */
dvt.BaseAnimation.prototype.HideObjects = function()
{
  this.SetObjectsVisible(false);
};


/**
 * @protected
 * Set visibility of objects.
 *
 * @param {boolean}  bVisible  true to show, false to hide
 */
dvt.BaseAnimation.prototype.SetObjectsVisible = function(bVisible)
{
  if (this._arObjects)
  {
    var obj;
    for (var i = this._arObjects.length - 1; i >= 0; i--)
    {
      obj = this._arObjects[i];
      if (obj)
      {
        obj.setVisible(bVisible);
      }
    }
  }
};


/**
  * @protected
  * Restore objects' original matrices as they were before animation.
  */
dvt.BaseAnimation.prototype.RestoreOriginalMatrices = function()
{
  if (this._arObjects)
  {
    var obj;
    for (var i = this._arObjects.length - 1; i >= 0; i--)
    {
      obj = this._arObjects[i];
      if (obj)
      {
        if (this._origMatrixArray)
        {
          obj.setMatrix(this._origMatrixArray.pop());
        }
      }
    }
  }
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Class providing the ability to create a custom animation using a dvt.Animator.
 * @param {dvt.Context} context The platform specific context object.
 * @param {obj} obj The object to animate.
 * @param {number} duration The length of animation, in seconds.
 * @param {number} delay The time to delay start of animation, in seconds.
 * @extends {dvt.BaseAnimation}
 * @class dvt.CustomAnimation
 * @constructor
 */
dvt.CustomAnimation = function(context, obj, duration, delay)
{
  this.Init(context, obj, duration, delay);
};

dvt.Obj.createSubclass(dvt.CustomAnimation, dvt.BaseAnimation);


/**
 * Returns the animator, which can be used to add animated properties.
 * @return {dvt.Animator} The animator for this animation.
 */
dvt.CustomAnimation.prototype.getAnimator = function()
{
  return this._animator;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to move an object into view as
  * if on a conveyor belt.  The object will in from the background on
  * its side and then rotate to face forward.
  * @extends {dvt.BaseAnimation}
  * @class DvtAnimConveyorIn
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param direction compass direction to move display objects in from;
  *        can be one of: DIR_N, DIR_E, DIR_S, DIR_W
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimConveyorIn = function(context, objs, direction, duration, delay)
{
  this.Init(context, objs, direction, duration, delay);
};

dvt.Obj.createSubclass(DvtAnimConveyorIn, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.Init = function(context, objs, direction, duration, delay)
{
  DvtAnimConveyorIn.superclass.Init.call(this, context, objs, duration, delay);

  this._direction = direction;

  this._SCALE = .2;
  this._SKEW_ANGLE = Math.PI / 12;

  this._bSaveAndRestoreOriginalMatrices = true;
};


/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.CreateAnimator = function(context)
{
  DvtAnimConveyorIn.superclass.CreateAnimator.call(this, context);

  this.setEasing(dvt.BaseAnimation.EASING_CUBIC_IN);
  this._animator.setDuration(this.getDuration() / 2);
  this._animator.setOnEnd(this.PlayEndAnim, this);

  this._endAnim = new dvt.Animator(context, this.getDuration() / 2, 0, dvt.BaseAnimation.GetEasingFunction(dvt.BaseAnimation.EASING_CUBIC_OUT));
  this._endAnim.setOnEnd(this.OnAnimEnd, this);
};


/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.InitializePlay = function()
{
  DvtAnimConveyorIn.superclass.InitializePlay.call(this);

  this.ShowObjects();
};


/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.InitStartState = function(obj)
{
  DvtAnimConveyorIn.superclass.InitStartState.call(this, obj);

  obj.setVisible(false);

  //rotate first
  var scale = this._SCALE;
  var diffScale = 1 - scale;

  var bounds = obj.getDimensions();
  var halfWidth = bounds.w * diffScale;
  var halfHeight = bounds.h * diffScale;

  var mat = this.GetConcatenatedRotationMatrix(obj, bounds);

  //slide into background after
  var mat2 = new dvt.Matrix();
  if (this._direction === dvt.BaseAnimation.DIR_W ||
      this._direction === dvt.BaseAnimation.DIR_E)
  {
    if (this._direction === dvt.BaseAnimation.DIR_W)
    {
      mat2.translate(bounds.w, 0);
    }
    else
    {
      mat2.translate(-bounds.w, 0);
    }
  }
  else
  {
    if (this._direction === dvt.BaseAnimation.DIR_N)
    {
      mat2.translate(0, bounds.h);
    }
    else
    {
      mat2.translate(0, -bounds.h);
    }
  }
  mat2.concat(mat);
  obj.setMatrix(mat2);
  obj.setAlpha(0);
};


/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.InitEndState = function(obj)
{
  DvtAnimConveyorIn.superclass.InitEndState.call(this, obj);

  var bounds = obj.getDimensions();

  //slide into foreground first
  var concatRotMat = this.GetConcatenatedRotationMatrix(obj, bounds);
  this._animator.addProp(dvt.Animator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, concatRotMat);
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 1);

  //rotate after
  var currMat = obj.getMatrix();
  this._endAnim.addProp(dvt.Animator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, currMat);
};


/**
  * @protected
  * Play the end animation, which rotates the object to face forward again.
  */
DvtAnimConveyorIn.prototype.PlayEndAnim = function()
{
  // Perform the animation immediately since this is not part of a slow component render operation.
  this._endAnim.play(true);
};


/**
  * @protected
  * Get the concatenation of the rotation matrix with the current matrix.
  *
  * @param  obj  display object being animated
  * @param {dvt.Rectangle}  bounds  bounding box for the object
  * @type {dvt.Matrix}
  */
DvtAnimConveyorIn.prototype.GetConcatenatedRotationMatrix = function(obj, bounds)
{
  var scale = this._SCALE;
  var diffScale = 1 - scale;

  var halfWidth = bounds.w * diffScale;
  var halfHeight = bounds.h * diffScale;

  var skewAngle = this._SKEW_ANGLE;
  if (this._direction === dvt.BaseAnimation.DIR_W ||
      this._direction === dvt.BaseAnimation.DIR_S)
  {
    skewAngle = -skewAngle;
  }
  var tanAngle = Math.tan(skewAngle);

  var currMat = obj.getMatrix();
  var mat = new dvt.Matrix();
  if (this._direction === dvt.BaseAnimation.DIR_W ||
      this._direction === dvt.BaseAnimation.DIR_E)
  {
    mat.skew(0, skewAngle);
    mat.scale(scale, 1);
    if (this._direction === dvt.BaseAnimation.DIR_W)
    {
      mat.translate(0, 0);
    }
    else
    {
      mat.translate(halfWidth, -bounds.w * tanAngle);
    }
  }
  else
  {
    mat.skew(skewAngle, 0);
    mat.scale(1, scale);
    if (this._direction === dvt.BaseAnimation.DIR_N)
    {
      mat.translate(0, 0);
    }
    else
    {
      mat.translate(-bounds.h * tanAngle, halfHeight);
    }
  }
  mat.concat(currMat);
  return mat;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to move an object out of view as
  * if on a conveyor belt.  The object will rotate onto its side and
  * slide into the background.
  * @extends {dvt.BaseAnimation}
  * @class DvtAnimConveyorOut
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param direction compass direction to move display objects out;
  *        can be one of: DIR_N, DIR_E, DIR_S, DIR_W
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimConveyorOut = function(context, objs, direction, duration, delay)
{
  this.Init(context, objs, direction, duration, delay);
};

dvt.Obj.createSubclass(DvtAnimConveyorOut, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
DvtAnimConveyorOut.prototype.Init = function(context, objs, direction, duration, delay)
{
  DvtAnimConveyorOut.superclass.Init.call(this, context, objs, duration, delay);

  this._direction = direction;

  this._bSaveAndRestoreOriginalMatrices = true;
  this._bHideObjectsOnEnd = true;
};


/**
  * @protected
  * @override
  */
DvtAnimConveyorOut.prototype.CreateAnimator = function(context)
{
  DvtAnimConveyorOut.superclass.CreateAnimator.call(this, context);

  this.setEasing(dvt.BaseAnimation.EASING_CUBIC_IN);
  this._animator.setDuration(this.getDuration() / 2);
  this._animator.setOnEnd(this.PlayEndAnim, this);

  this._endAnim = new dvt.Animator(context, this.getDuration() / 2, 0, dvt.BaseAnimation.GetEasingFunction(dvt.BaseAnimation.EASING_CUBIC_OUT));
  this._endAnim.setOnEnd(this.OnAnimEnd, this);
};


/**
  * @protected
  * @override
  */
DvtAnimConveyorOut.prototype.InitEndState = function(obj)
{
  DvtAnimConveyorOut.superclass.InitEndState.call(this, obj);

  //rotate first
  var scale = .2;
  var diffScale = 1 - scale;

  var bounds = obj.getDimensions();
  var halfWidth = bounds.w * diffScale;
  var halfHeight = bounds.h * diffScale;

  var skewAngle = Math.PI / 12;
  if (this._direction === dvt.BaseAnimation.DIR_W ||
      this._direction === dvt.BaseAnimation.DIR_S)
  {
    skewAngle = -skewAngle;
  }
  var tanAngle = Math.tan(skewAngle);

  var currMat = obj.getMatrix();
  var mat = new dvt.Matrix();
  if (this._direction === dvt.BaseAnimation.DIR_W ||
      this._direction === dvt.BaseAnimation.DIR_E)
  {
    mat.skew(0, skewAngle);
    mat.scale(scale, 1);
    if (this._direction === dvt.BaseAnimation.DIR_W)
    {
      mat.translate(0, 0);
    }
    else
    {
      mat.translate(halfWidth, -bounds.w * tanAngle);
    }
  }
  else
  {
    mat.skew(skewAngle, 0);
    mat.scale(1, scale);
    if (this._direction === dvt.BaseAnimation.DIR_N)
    {
      mat.translate(0, 0);
    }
    else
    {
      mat.translate(-bounds.h * tanAngle, halfHeight);
    }
  }
  mat.concat(currMat);
  this._animator.addProp(dvt.Animator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, mat);

  //slide into background after
  var mat2 = new dvt.Matrix();
  if (this._direction === dvt.BaseAnimation.DIR_W ||
      this._direction === dvt.BaseAnimation.DIR_E)
  {
    if (this._direction === dvt.BaseAnimation.DIR_W)
    {
      mat2.translate(bounds.w, 0);
    }
    else
    {
      mat2.translate(-bounds.w, 0);
    }
  }
  else
  {
    if (this._direction === dvt.BaseAnimation.DIR_N)
    {
      mat2.translate(0, bounds.h);
    }
    else
    {
      mat2.translate(0, -bounds.h);
    }
  }
  mat2.concat(mat);
  this._endAnim.addProp(dvt.Animator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, mat2);
  this._endAnim.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 0);
};


/**
  * @protected
  * Play the end animation, which slides the object into the background.
  */
DvtAnimConveyorOut.prototype.PlayEndAnim = function()
{
  // Perform the animation immediately since this is not part of a slow component render operation.
  this._endAnim.play(true);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to flip an object into view,
  * as if flipping a playing card.
  * @extends {dvt.BaseAnimation}
  * @class DvtAnimFlipIn
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimFlipIn = function(context, objs, axis, rotationDir, duration, delay)
{
  this.Init(context, objs, axis, rotationDir, duration, delay);
};

dvt.Obj.createSubclass(DvtAnimFlipIn, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
DvtAnimFlipIn.prototype.Init = function(context, objs, axis, rotationDir, duration, delay)
{
  DvtAnimFlipIn.superclass.Init.call(this, context, objs, duration, delay);

  this._axis = axis;
  this._rotationDir = rotationDir;

  this._bSaveAndRestoreOriginalMatrices = true;
  this._cubeEffect = false;
};


/**
  * @protected
  * @override
  */
DvtAnimFlipIn.prototype.InitStartState = function(obj)
{
  DvtAnimFlipIn.superclass.InitStartState.call(this, obj);

  obj.setVisible(false);

  var bounds = obj.getDimensions();
  var halfWidth = bounds.w / 2;
  var halfHeight = bounds.h / 2;

  var skewAngle = Math.PI / 6;
  if (this._rotationDir === dvt.BaseAnimation.ROT_DIR_COUNTERCLOCKWISE)
  {
    skewAngle = -skewAngle;
  }
  var tanAngle = Math.tan(skewAngle);

  var currMat = obj.getMatrix();
  var mat = new dvt.Matrix();
  if (this._axis === dvt.BaseAnimation.AXIS_Y)
  {
    mat.skew(0, skewAngle);
    mat.scale(0, 1);
    if (this._cubeEffect)
    {
      if (this._rotationDir === dvt.BaseAnimation.ROT_DIR_COUNTERCLOCKWISE)
      {
        mat.translate(bounds.w, 0);
      }
      else
      {
        mat.translate(0, -bounds.w * tanAngle);
      }
    }
    else
    {
      mat.translate(halfWidth, -halfWidth * tanAngle);
    }
  }
  else
  {
    mat.skew(skewAngle, 0);
    mat.scale(1, 0);
    if (this._cubeEffect)
    {
      if (this._rotationDir === dvt.BaseAnimation.ROT_DIR_COUNTERCLOCKWISE)
      {
        mat.translate(-bounds.h * tanAngle, 0);
      }
      else
      {
        mat.translate(0, bounds.h);
      }
    }
    else
    {
      mat.translate(-halfHeight * tanAngle, halfHeight);
    }
  }
  mat.concat(currMat);
  obj.setMatrix(mat);

  if (this._cubeEffect)
  {
    obj.setAlpha(0);
  }
};


/**
  * @protected
  * @override
  */
DvtAnimFlipIn.prototype.InitEndState = function(obj)
{
  DvtAnimFlipIn.superclass.InitEndState.call(this, obj);

  var currMat = obj.getMatrix();
  this._animator.addProp(dvt.Animator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, currMat);

  if (this._cubeEffect)
  {
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 1);
  }
};


/**
  * @protected
  * @override
  */
DvtAnimFlipIn.prototype.InitializePlay = function()
{
  DvtAnimFlipIn.superclass.InitializePlay.call(this);

  this.ShowObjects();
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to flip an object out of view,
  * as if flipping a playing card.
  * @extends {dvt.BaseAnimation}
  * @class DvtAnimFlipOut
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimFlipOut = function(context, objs, axis, rotationDir, duration, delay)
{
  this.Init(context, objs, axis, rotationDir, duration, delay);
};

dvt.Obj.createSubclass(DvtAnimFlipOut, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
DvtAnimFlipOut.prototype.Init = function(context, objs, axis, rotationDir, duration, delay)
{
  DvtAnimFlipOut.superclass.Init.call(this, context, objs, duration, delay);

  this._axis = axis;
  this._rotationDir = rotationDir;

  this._bSaveAndRestoreOriginalMatrices = true;
  this._bHideObjectsOnEnd = true;
  this._cubeEffect = false;
};


/**
  * @protected
  * @override
  */
DvtAnimFlipOut.prototype.InitEndState = function(obj)
{
  DvtAnimFlipOut.superclass.InitEndState.call(this, obj);

  var bounds = obj.getDimensions();
  var halfWidth = bounds.w / 2;
  var halfHeight = bounds.h / 2;

  var skewAngle = Math.PI / 6;
  if (this._rotationDir === dvt.BaseAnimation.ROT_DIR_CLOCKWISE)
  {
    skewAngle = -skewAngle;
  }
  var tanAngle = Math.tan(skewAngle);

  var currMat = obj.getMatrix();
  var mat = new dvt.Matrix();
  if (this._axis === dvt.BaseAnimation.AXIS_Y)
  {
    mat.skew(0, skewAngle);
    mat.scale(0, 1);
    if (this._cubeEffect)
    {
      if (this._rotationDir === dvt.BaseAnimation.ROT_DIR_CLOCKWISE)
      {
        mat.translate(bounds.w, 0);
      }
      else
      {
        mat.translate(0, -bounds.w * tanAngle);
      }
    }
    else
    {
      mat.translate(halfWidth, -halfWidth * tanAngle);
    }
  }
  else
  {
    mat.skew(skewAngle, 0);
    mat.scale(1, 0);
    if (this._cubeEffect)
    {
      if (this._rotationDir === dvt.BaseAnimation.ROT_DIR_CLOCKWISE)
      {
        mat.translate(-bounds.h * tanAngle, 0);
      }
      else
      {
        mat.translate(0, bounds.h);
      }
    }
    else
    {
      mat.translate(-halfHeight * tanAngle, halfHeight);
    }
  }
  mat.concat(currMat);
  this._animator.addProp(dvt.Animator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, mat);

  if (this._cubeEffect)
  {
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 0);
  }
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to rotate an object into view,
  * as if rotating a cube.
  * @extends {DvtAnimFlipIn}
  * @class DvtAnimCubeIn
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimCubeIn = function(context, objs, axis, rotationDir, duration, delay)
{
  this.Init(context, objs, axis, rotationDir, duration, delay);
};

dvt.Obj.createSubclass(DvtAnimCubeIn, DvtAnimFlipIn);


/**
  * @protected
  * @override
  */
DvtAnimCubeIn.prototype.Init = function(context, objs, axis, rotationDir, duration, delay)
{
  DvtAnimCubeIn.superclass.Init.call(this, context, objs, axis, rotationDir, duration, delay);

  this._cubeEffect = true;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to rotate an object out of view,
  * as if rotating a cube.
  * @extends {DvtAnimFlipOut}
  * @class DvtAnimCubeOut
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimCubeOut = function(context, objs, axis, rotationDir, duration, delay)
{
  this.Init(context, objs, axis, rotationDir, duration, delay);
};

dvt.Obj.createSubclass(DvtAnimCubeOut, DvtAnimFlipOut);


/**
  * @protected
  * @override
  */
DvtAnimCubeOut.prototype.Init = function(context, objs, axis, rotationDir, duration, delay)
{
  DvtAnimCubeOut.superclass.Init.call(this, context, objs, axis, rotationDir, duration, delay);

  this._cubeEffect = true;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to fade in an object.
  * @extends {dvt.BaseAnimation}
  * @class dvt.AnimFadeIn
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimFadeIn = function(context, objs, duration, delay)
{
  this.Init(context, objs, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimFadeIn, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
dvt.AnimFadeIn.prototype.Init = function(context, objs, duration, delay)
{
  dvt.AnimFadeIn.superclass.Init.call(this, context, objs, duration, delay);
};


/**
  * @protected
  * @override
  */
dvt.AnimFadeIn.prototype.InitStartState = function(obj)
{
  obj.setAlpha(0);
};


/**
  * @protected
  * @override
  */
dvt.AnimFadeIn.prototype.InitEndState = function(obj)
{
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 1);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to fade out an object.
  * @extends {dvt.BaseAnimation}
  * @class dvt.AnimFadeOut
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimFadeOut = function(context, objs, duration, delay)
{
  this.Init(context, objs, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimFadeOut, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
dvt.AnimFadeOut.prototype.Init = function(context, objs, duration, delay)
{
  dvt.AnimFadeOut.superclass.Init.call(this, context, objs, duration, delay);
};


/**
  * @protected
  * @override
  */
dvt.AnimFadeOut.prototype.InitEndState = function(obj)
{
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 0);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to move an object by a given amount.
  * @extends {dvt.BaseAnimation}
  * @class dvt.AnimMoveBy
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param offsets  a single dvt.Point or Array of DvtPoints to move by
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimMoveBy = function(context, objs, offsets, duration, delay)
{
  this.Init(context, objs, offsets, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimMoveBy, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
dvt.AnimMoveBy.prototype.Init = function(context, objs, offsets, duration, delay)
{
  if (offsets instanceof Array)
  {
    this._arOffsets = offsets;
  }
  else if (offsets instanceof dvt.Point)
  {
    this._arOffsets = [offsets];
  }
  else
  {
    this._arOffsets = [new dvt.Point(0, 0)];
  }

  this._currIndex = 0;

  dvt.AnimMoveBy.superclass.Init.call(this, context, objs, duration, delay);
};


/**
  * @protected
  * @override
  */
dvt.AnimMoveBy.prototype.InitEndState = function(obj)
{
  var offset;
  if (this._currIndex < this._arOffsets.length)
  {
    offset = this._arOffsets[this._currIndex];
  }
  else
  {
    offset = this._arOffsets[this._arOffsets.length - 1];
  }

  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getTranslateX, obj.setTranslateX, obj.getTranslateX() + offset.x);
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getTranslateY, obj.setTranslateY, obj.getTranslateY() + offset.y);

  this._currIndex++;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to move an object to a given point.
  * @extends {dvt.BaseAnimation}
  * @class dvt.AnimMoveTo
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param points  a single dvt.Point or Array of DvtPoints to move to
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimMoveTo = function(context, objs, points, duration, delay)
{
  this.Init(context, objs, points, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimMoveTo, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
dvt.AnimMoveTo.prototype.Init = function(context, objs, points, duration, delay)
{
  if (points instanceof Array)
  {
    this._arPoints = points;
  }
  else if (points instanceof dvt.Point)
  {
    this._arPoints = [points];
  }
  else
  {
    this._arPoints = [new dvt.Point(0, 0)];
  }

  this._currIndex = 0;

  dvt.AnimMoveTo.superclass.Init.call(this, context, objs, duration, delay);
};


/**
  * @protected
  * @override
  */
dvt.AnimMoveTo.prototype.InitEndState = function(obj)
{
  var point;
  if (this._currIndex < this._arPoints.length)
  {
    point = this._arPoints[this._currIndex];
  }
  else
  {
    point = this._arPoints[this._arPoints.length - 1];
  }

  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getTranslateX, obj.setTranslateX, point.x);
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getTranslateY, obj.setTranslateY, point.y);

  this._currIndex++;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to scale an object by a given amount.
  * @extends {dvt.BaseAnimation}
  * @class dvt.AnimScaleBy
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param scales  a single dvt.Point or Array of DvtPoints to scale by
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimScaleBy = function(context, objs, scales, duration, delay)
{
  this.Init(context, objs, scales, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimScaleBy, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
dvt.AnimScaleBy.prototype.Init = function(context, objs, scales, duration, delay)
{
  if (scales instanceof Array)
  {
    this._arScales = scales;
  }
  else if (scales instanceof dvt.Point)
  {
    this._arScales = [scales];
  }
  else
  {
    this._arScales = [new dvt.Point(1, 1)];
  }

  this._currIndex = 0;

  dvt.AnimScaleBy.superclass.Init.call(this, context, objs, duration, delay);
};


/**
  * @protected
  * @override
  */
dvt.AnimScaleBy.prototype.InitEndState = function(obj)
{
  var scale;
  if (this._currIndex < this._arScales.length)
  {
    scale = this._arScales[this._currIndex];
  }
  else
  {
    scale = this._arScales[this._arScales.length - 1];
  }

  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, obj.getScaleX() * scale.x);
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, obj.getScaleY() * scale.y);

  this._currIndex++;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to move and fade in an object.  The object
  * is moved in from the edges of a provided rectangle as it fades.
  * The object is also scaled as it fades, so it becomes larger as it is
  * more opaque.
  * @extends {dvt.AnimFadeIn}
  * @class dvt.AnimScaleFadeIn
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param {dvt.Rectangle}  boundsRect  a rectangle defining the bounds for moving the object
  * @param direction  compass direction to move display object in from;
  *        can be one of the values defined in dvt.BaseAnimation:
  *        DIR_C, DIR_N, DIR_NE, DIR_E, DIR_SE, DIR_S, DIR_SW, DIR_W, DIR_NW (default is DIR_NW)
  * @param {number}  minScale  minimum scale to make the object as it starts
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimScaleFadeIn = function(context, objs, boundsRect, direction, minScale, duration, delay)
{
  this.Init(context, objs, boundsRect, direction, minScale, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimScaleFadeIn, dvt.AnimFadeIn);


/**
  * @protected
  * @override
  */
dvt.AnimScaleFadeIn.prototype.Init = function(context, objs, boundsRect, direction, minScale, duration, delay)
{
  this._boundsRect = boundsRect;
  this._direction = (direction ? direction : dvt.BaseAnimation.DIR_NW);
  this._minScale = (minScale ? minScale : 0.5);

  dvt.AnimScaleFadeIn.superclass.Init.call(this, context, objs, duration, delay);

  //need to do this AFTER calling superclass Init because member will
  //initially be defined there
  this._bSaveAndRestoreOriginalMatrices = true;
};


/**
  * @protected
  * @override
  */
dvt.AnimScaleFadeIn.prototype.InitStartState = function(obj)
{
  dvt.AnimScaleFadeIn.superclass.InitStartState.call(this, obj);

  var newScaleX = this._minScale * obj.getScaleX();
  var newScaleY = this._minScale * obj.getScaleY();

  //move the dispObj to the edge of the bounding rect and scale it down
  var objBounds = obj.getDimensions();
  var rect = new dvt.Rectangle(0, 0, newScaleX * objBounds.w, newScaleY * objBounds.h);
  var point = dvt.BaseAnimation.GetAlignCompassPoint(rect, this._boundsRect, this._direction);
  obj.setTranslate(point.x, point.y);
  obj.setScale(newScaleX, newScaleY);
};


/**
  * @protected
  * @override
  */
dvt.AnimScaleFadeIn.prototype.InitEndState = function(obj)
{
  dvt.AnimScaleFadeIn.superclass.InitEndState.call(this, obj);

  var currMat = obj.getMatrix();
  this._animator.addProp(dvt.Animator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, currMat);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to move and fade out an object.  The object
  * is moved out toward the edges of a provided rectangle as it fades.
  * The object is also scaled as it fades, so it becomes smaller as it is
  * more transparent.
  * @extends {dvt.AnimFadeOut}
  * @class dvt.AnimScaleFadeOut
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param {dvt.Rectangle}  boundsRect  a rectangle defining the bounds for moving the object
  * @param direction  compass direction to move display object out to;
  *        can be one of the values defined in dvt.BaseAnimation:
  *        DIR_C, DIR_N, DIR_NE, DIR_E, DIR_SE, DIR_S, DIR_SW, DIR_W, DIR_NW (default is DIR_NE)
  * @param {number}  minScale  minimum scale to make the object as it starts
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimScaleFadeOut = function(context, objs, boundsRect, direction, minScale, duration, delay)
{
  this.Init(context, objs, boundsRect, direction, minScale, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimScaleFadeOut, dvt.AnimFadeOut);


/**
  * @protected
  * @override
  */
dvt.AnimScaleFadeOut.prototype.Init = function(context, objs, boundsRect, direction, minScale, duration, delay)
{
  this._boundsRect = boundsRect;
  this._direction = (direction ? direction : dvt.BaseAnimation.DIR_NE);
  this._minScale = (minScale ? minScale : 0.5);

  dvt.AnimScaleFadeOut.superclass.Init.call(this, context, objs, duration, delay);

  //need to do this AFTER calling superclass Init because member will
  //initially be defined there
  this._bSaveAndRestoreOriginalMatrices = true;
};


/**
  * @protected
  * @override
  */
dvt.AnimScaleFadeOut.prototype.InitEndState = function(obj)
{
  dvt.AnimScaleFadeOut.superclass.InitEndState.call(this, obj);

  var newScaleX = this._minScale * obj.getScaleX();
  var newScaleY = this._minScale * obj.getScaleY();

  //move the dispObj to the edge of the bounding rect and scale it down
  var objBounds = obj.getDimensions();
  var rect = new dvt.Rectangle(0, 0, newScaleX * objBounds.w, newScaleY * objBounds.h);
  var point = dvt.BaseAnimation.GetAlignCompassPoint(rect, this._boundsRect, this._direction);

  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, newScaleX);
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, newScaleY);

  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getTranslateX, obj.setTranslateX, point.x);
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getTranslateY, obj.setTranslateY, point.y);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to scale an object to a given value.
  * @extends {dvt.BaseAnimation}
  * @class dvt.AnimScaleTo
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param scales  a single dvt.Point or Array of DvtPoints to scale to
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimScaleTo = function(context, objs, scales, duration, delay)
{
  this.Init(context, objs, scales, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimScaleTo, dvt.BaseAnimation);


/**
  * @protected
  * @override
  */
dvt.AnimScaleTo.prototype.Init = function(context, objs, scales, duration, delay)
{
  if (scales instanceof Array)
  {
    this._arScales = scales;
  }
  else if (scales instanceof dvt.Point)
  {
    this._arScales = [scales];
  }
  else
  {
    this._arScales = [new dvt.Point(1, 1)];
  }

  this._currIndex = 0;

  dvt.AnimScaleTo.superclass.Init.call(this, context, objs, duration, delay);
};


/**
  * @protected
  * @override
  */
dvt.AnimScaleTo.prototype.InitEndState = function(obj)
{
  var scale;
  if (this._currIndex < this._arScales.length)
  {
    scale = this._arScales[this._currIndex];
  }
  else
  {
    scale = this._arScales[this._arScales.length - 1];
  }

  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, scale.x);
  this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, scale.y);

  this._currIndex++;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to pop an object in.
  * @extends {dvt.BaseAnimation}
  * @class dvt.AnimPopIn
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param {boolean}  bCenter  true to scale the object from its center,
  *        false to scale from its origin
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimPopIn = function(context, objs, bCenter, duration, delay)
{
  this.Init(context, objs, bCenter, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimPopIn, dvt.BaseAnimation);


/**
  * @protected
  */
dvt.AnimPopIn.BackOut = function(progress)
{
  return dvt.Easing.backOut(progress, 2.5);
};


/**
  * @protected
  * @override
  */
dvt.AnimPopIn.prototype.Init = function(context, objs, bCenter, duration, delay)
{
  this._bCenter = bCenter;
  if (this._bCenter) {
    //temporary containers used to scale an object from its center
    this._tempContainers = [];
    //current index in array of temp containers
    this._currIndex = 0;
  }
  dvt.AnimPopIn.superclass.Init.call(this, context, objs, duration, delay);
};


/**
  * @override
  */
dvt.AnimPopIn.prototype.setEasing = function(easing)
{
  //do nothing because we want to use our own easing
};


/**
  * @protected
  * @override
  */
dvt.AnimPopIn.prototype.CreateAnimator = function(context)
{
  dvt.AnimPopIn.superclass.CreateAnimator.call(this, context);
  this._animator.setEasing(dvt.AnimPopIn.BackOut);
  if (this._bCenter) {
    //need to remove temporary containers at end of anim
    dvt.Playable.appendOnEnd(this._animator, this.RemoveTempContainers, this);
  }
};


/**
  * @protected
  * @override
  */
dvt.AnimPopIn.prototype.InitStartState = function(obj)
{
  if (this._bCenter) {
    //For centering, the idea is to insert a temporary container between the obj and its
    //parent.  The temp container will be positioned such that its origin is at the center
    //of the obj.  Then, when the temp container is scaled about its origin, it will look
    //like the obj is scaled about its own center point.
    var tempContainer = this._tempContainers[this._currIndex];

    var dims = obj.getDimensions();
    //store the original translate on the temp container
    tempContainer._dvtAnimPopInOrigTx = obj.getTranslateX();
    tempContainer._dvtAnimPopInOrigTy = obj.getTranslateY();
    //calculate the center point of the obj
    var dx = dims.x + .5 * dims.w;
    var dy = dims.y + .5 * dims.h;
    //position the origin of the temp container at the center point of the obj
    //so that the obj appears to scale from its center
    tempContainer.setTranslate(tempContainer._dvtAnimPopInOrigTx + dx, tempContainer._dvtAnimPopInOrigTy + dy);
    //translate the obj so that its center point is at the origin of the temp container
    obj.setTranslate(-dx, -dy);
    //reparent the obj to the temp container, and insert the temp container into
    //the obj's original parent at the same index
    var childIndex = obj.getParent().getChildIndex(obj);
    tempContainer._dvtAnimPopInChildIndex = childIndex;
    obj.getParent().addChildAt(tempContainer, childIndex);
    tempContainer.addChild(obj);

    //scale the temp container instead of the obj
    tempContainer.setScale(.01, .01);

    this._currIndex++;
  }
  else {
    //scale the obj
    obj.setScale(.01, .01);
  }
  obj.setVisible(true);
};


/**
  * @protected
  * @override
  */
dvt.AnimPopIn.prototype.InitEndState = function(obj)
{
  if (this._bCenter) {
    //create a temp container
    var tempContainer = new dvt.Container(this._context);
    this._tempContainers.push(tempContainer);
    //scale the temp container to full size
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, tempContainer, tempContainer.getScaleX, tempContainer.setScaleX, 1);
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, tempContainer, tempContainer.getScaleY, tempContainer.setScaleY, 1);
  }
  else {
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, 1);
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, 1);
  }
};


/**
  * @protected
  */
dvt.AnimPopIn.prototype.RemoveTempContainers = function() {
  //remove temp containers used for scaling from center
  if (this._tempContainers) {
    for (var i = 0; i < this._tempContainers.length; i++) {
      var tempContainer = this._tempContainers[i];
      this._tempContainers[i] = null;
      if (tempContainer.getNumChildren() > 0) {
        //obj should be first child of temp container
        var obj = tempContainer.getChildAt(0);
        if (obj) {
          //translate the obj back to its original position and reparent it back to
          //its original container at the same z-index
          obj.setTranslate(tempContainer._dvtAnimPopInOrigTx, tempContainer._dvtAnimPopInOrigTy);
          tempContainer.getParent().addChildAt(obj, tempContainer._dvtAnimPopInChildIndex);
        }
      }
      //remove the temp container from the display list
      tempContainer.getParent().removeChild(tempContainer);
    }
    this._tempContainers = null;
  }
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to pop an object out.
  * @extends {dvt.BaseAnimation}
  * @class dvt.AnimPopOut
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to animate
  * @param {boolean}  bCenter  true to scale the object from its center,
  *        false to scale from its origin
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.AnimPopOut = function(context, objs, bCenter, duration, delay)
{
  this.Init(context, objs, bCenter, duration, delay);
};

dvt.Obj.createSubclass(dvt.AnimPopOut, dvt.BaseAnimation);


/**
  * @protected
  */
dvt.AnimPopOut.BackIn = function(progress)
{
  return dvt.Easing.backIn(progress, 2.5);
};


/**
  * @protected
  * @override
  */
dvt.AnimPopOut.prototype.Init = function(context, objs, bCenter, duration, delay)
{
  this._bCenter = bCenter;
  if (this._bCenter) {
    //temporary containers used to scale an object from its center
    this._tempContainers = [];
    //current index in array of temp containers
    this._currIndex = 0;
  }
  dvt.AnimPopOut.superclass.Init.call(this, context, objs, duration, delay);

  //need to do this AFTER calling superclass Init because member will
  //initially be defined there
  //only need to restore original matrices if not centering (temp containers not used)
  this._bSaveAndRestoreOriginalMatrices = !this._bCenter;
  this._bHideObjectsOnEnd = true;
};


/**
  * @override
  */
dvt.AnimPopOut.prototype.setEasing = function(easing)
{
  //do nothing because we want to use our own easing
};


/**
  * @protected
  * @override
  */
dvt.AnimPopOut.prototype.CreateAnimator = function(context)
{
  dvt.AnimPopOut.superclass.CreateAnimator.call(this, context);
  this._animator.setEasing(dvt.AnimPopOut.BackIn);
  if (this._bCenter) {
    //need to remove temporary containers at end of anim
    dvt.Playable.appendOnEnd(this._animator, this.RemoveTempContainers, this);
  }
};


/**
  * @protected
  * @override
  */
dvt.AnimPopOut.prototype.InitStartState = function(obj)
{
  if (this._bCenter) {
    //For centering, the idea is to insert a temporary container between the obj and its
    //parent.  The temp container will be positioned such that its origin is at the center
    //of the obj.  Then, when the temp container is scaled about its origin, it will look
    //like the obj is scaled about its own center point.
    var tempContainer = this._tempContainers[this._currIndex];

    var dims = obj.getDimensions();
    //store the original translate on the temp container
    tempContainer._dvtAnimPopInOrigTx = obj.getTranslateX();
    tempContainer._dvtAnimPopInOrigTy = obj.getTranslateY();
    //calculate the center point of the obj
    var dx = dims.x + .5 * dims.w;
    var dy = dims.y + .5 * dims.h;
    //position the origin of the temp container at the center point of the obj
    //so that the obj appears to scale from its center
    tempContainer.setTranslate(tempContainer._dvtAnimPopInOrigTx + dx, tempContainer._dvtAnimPopInOrigTy + dy);
    //translate the obj so that its center point is at the origin of the temp container
    obj.setTranslate(-dx, -dy);
    //reparent the obj to the temp container, and insert the temp container into
    //the obj's original parent at the same index
    var childIndex = obj.getParent().getChildIndex(obj);
    tempContainer._dvtAnimPopInChildIndex = childIndex;
    obj.getParent().addChildAt(tempContainer, childIndex);
    tempContainer.addChild(obj);

    this._currIndex++;
  }
};


/**
  * @protected
  * @override
  */
dvt.AnimPopOut.prototype.InitEndState = function(obj)
{
  if (this._bCenter) {
    //create a temp container
    var tempContainer = new dvt.Container(this._context);
    this._tempContainers.push(tempContainer);
    //scale the temp container to small size
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, tempContainer, tempContainer.getScaleX, tempContainer.setScaleX, .01);
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, tempContainer, tempContainer.getScaleY, tempContainer.setScaleY, .01);
  }
  else {
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, .01);
    this._animator.addProp(dvt.Animator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, .01);
  }
};


/**
  * @protected
  */
dvt.AnimPopOut.prototype.RemoveTempContainers = function() {
  //remove temp containers used for scaling from center
  if (this._tempContainers) {
    for (var i = 0; i < this._tempContainers.length; i++) {
      var tempContainer = this._tempContainers[i];
      this._tempContainers[i] = null;
      if (tempContainer.getNumChildren() > 0) {
        //obj should be first child of temp container
        var obj = tempContainer.getChildAt(0);
        if (obj) {
          //translate the obj back to its original position and reparent it back to
          //its original container at the same z-index
          obj.setTranslate(tempContainer._dvtAnimPopInOrigTx, tempContainer._dvtAnimPopInOrigTy);
          tempContainer.getParent().addChildAt(obj, tempContainer._dvtAnimPopInChildIndex);
        }
      }
      //remove the temp container from the display list
      tempContainer.getParent().removeChild(tempContainer);
    }
    this._tempContainers = null;
  }
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class used to animate replacing one set of display objects with another
  * set by rotating and moving them as if on a conveyor belt.  The old
  * objects will move back into the display while the new objects will be
  * moved to the front.
  * @extends {dvt.ParallelPlayable}
  * @class DvtCombinedAnimConveyor
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param outObjs  a single dvt.Container or Array of DvtContainers to fade out
  * @param inObjs  a single dvt.Container or Array of DvtContainers to fade in
  * @param outDir compass direction to move old display objects out; can be
  *        one of: DIR_N, DIR_E, DIR_S, DIR_W
  * @param inDir compass direction to move new display objects in from; can
  *        be one of: DIR_N, DIR_E, DIR_S, DIR_W
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimConveyor = function(context, outObjs, inObjs, outDir, inDir, duration, delay)
{
  this.Init(context, outObjs, inObjs, outDir, inDir, duration, delay);
};

dvt.Obj.createSubclass(DvtCombinedAnimConveyor, dvt.ParallelPlayable);


/**
  * @protected
  * @override
  */
DvtCombinedAnimConveyor.prototype.Init = function(context, outObjs, inObjs, outDir, inDir, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;

  var conveyorOut = new DvtAnimConveyorOut(context, outObjs, outDir, duration, delay);
  var conveyorIn = new DvtAnimConveyorIn(context, inObjs, inDir, duration, (duration / 3) + delay);

  DvtCombinedAnimConveyor.superclass.Init.call(this, context, [conveyorOut, conveyorIn]);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class used to animate replacing one set of display objects with
  * another set by rotating out the old and rotating in the new,
  * as if on a cube.
  * @extends {dvt.ParallelPlayable}
  * @class dvt.CombinedAnimCube
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param outObjs  a single dvt.Container or Array of DvtContainers to fade out
  * @param inObjs  a single dvt.Container or Array of DvtContainers to fade in
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.CombinedAnimCube = function(context, outObjs, inObjs, axis, rotationDir, duration, delay)
{
  this.Init(context, outObjs, inObjs, axis, rotationDir, duration, delay);
};

dvt.Obj.createSubclass(dvt.CombinedAnimCube, dvt.ParallelPlayable);


/**
  * @protected
  * @override
  */
dvt.CombinedAnimCube.prototype.Init = function(context, outObjs, inObjs, axis, rotationDir, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;

  var cubeOut = new DvtAnimCubeOut(context, outObjs, axis, rotationDir, duration, delay);
  var cubeIn = new DvtAnimCubeIn(context, inObjs, axis, rotationDir, duration, delay);

  dvt.CombinedAnimCube.superclass.Init.call(this, context, [cubeOut, cubeIn]);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class used to animate replacing one set of display objects with another set by
  * fading out the old and fading in the new.
  * @extends {dvt.ParallelPlayable}
  * @class DvtCombinedAnimFade
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param outObjs  a single dvt.Container or Array of DvtContainers to fade out
  * @param inObjs  a single dvt.Container or Array of DvtContainers to fade in
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimFade = function(context, outObjs, inObjs, duration, delay)
{
  this.Init(context, outObjs, inObjs, duration, delay);
};

dvt.Obj.createSubclass(DvtCombinedAnimFade, dvt.ParallelPlayable);


/**
  * @protected
  * @override
  */
DvtCombinedAnimFade.prototype.Init = function(context, outObjs, inObjs, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;

  var fadeOut = new dvt.AnimFadeOut(context, outObjs, duration, delay);
  //delay the fade out by a little bit to make both animations easier to see
  var fadeIn = new dvt.AnimFadeIn(context, inObjs, duration, 0.5 * fadeOut.getDuration() + delay);

  DvtCombinedAnimFade.superclass.Init.call(this, context, [fadeOut, fadeIn]);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class used to animate replacing one set of display objects with
  * another set by flipping out the old and flipping in the new,
  * as if on a playing card.
  * @extends {dvt.SequentialPlayable}
  * @class dvt.CombinedAnimFlip
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param outObjs  a single dvt.Container or Array of DvtContainers to fade out
  * @param inObjs  a single dvt.Container or Array of DvtContainers to fade in
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.CombinedAnimFlip = function(context, outObjs, inObjs, axis, rotationDir, duration, delay)
{
  this.Init(context, outObjs, inObjs, axis, rotationDir, duration, delay);
};

dvt.Obj.createSubclass(dvt.CombinedAnimFlip, dvt.SequentialPlayable);


/**
  * @protected
  * @override
  */
dvt.CombinedAnimFlip.prototype.Init = function(context, outObjs, inObjs, axis, rotationDir, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;

  var flipOut = new DvtAnimFlipOut(context, outObjs, axis, rotationDir, duration, delay);
  //adjust easing so that animation is slow at the beginning,
  //but fast at the end
  flipOut.setEasing(dvt.BaseAnimation.EASING_CUBIC_IN);
  var flipIn = new DvtAnimFlipIn(context, inObjs, axis, rotationDir, duration, delay);
  //adjust easing so that animation is fast at the beginning,
  //but slow at the end
  flipIn.setEasing(dvt.BaseAnimation.EASING_CUBIC_OUT);

  //because the flipOut and flipIn animations are played in sequence,
  //and because the initState of the flipIn won't be set until it starts
  //to play, we need to explicitly hide the flipIn objects here so that
  //they're not visible during the first flipOut part of the sequence
  flipIn.HideObjects();

  dvt.CombinedAnimFlip.superclass.Init.call(this, context, [flipOut, flipIn]);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class used to animate replacing one set of display objects with another set by
  * moving out the old and moving in the new.
  * @extends {dvt.ParallelPlayable}
  * @class dvt.CombinedAnimMoveBy
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param outObjs  a single dvt.Container or Array of DvtContainers to move out
  * @param inObjs  a single dvt.Container or Array of DvtContainers to move in
  * @param outOffsets  a single dvt.Point or Array of DvtPoints to move out by
  * @param inOffsets  a single dvt.Point or Array of DvtPoints to move in by
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.CombinedAnimMoveBy = function(context, outObjs, inObjs, outOffsets, inOffsets, duration, delay)
{
  this.Init(context, outObjs, inObjs, outOffsets, inOffsets, duration, delay);
};

dvt.Obj.createSubclass(dvt.CombinedAnimMoveBy, dvt.ParallelPlayable);


/**
  * @protected
  * @override
  */
dvt.CombinedAnimMoveBy.prototype.Init = function(context, outObjs, inObjs, outOffsets, inOffsets, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;

  var moveOut = new dvt.AnimMoveBy(context, outObjs, outOffsets, duration, delay);
  var moveIn = new dvt.AnimMoveBy(context, inObjs, inOffsets, duration, delay);

  dvt.CombinedAnimMoveBy.superclass.Init.call(this, context, [moveOut, moveIn]);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class used to animate replacing one set of display objects with another set by
  * moving and fading out the old and moving and fading in the new.  The objects
  * are moved out toward and in from the edges of a provided rectangle as they fade.
  * The objects are also scaled as they fade, so they become smaller as they are
  * more transparent.
  * @extends {dvt.ParallelPlayable}
  * @class DvtCombinedAnimScaleFade
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param outObjs  a single dvt.Container or Array of DvtContainers to fade out
  * @param inObjs  a single dvt.Container or Array of DvtContainers to fade in
  * @param {dvt.Rectangle}  boundsRect  a rectangle defining the bounds for moving the objects
  * @param outDirection  compass direction to move old display objects out to;
  *        can be one of the values defined in dvt.BaseAnimation:
  *        DIR_C, DIR_N, DIR_NE, DIR_E, DIR_SE, DIR_S, DIR_SW, DIR_W, DIR_NW (default is DIR_NE)
  * @param inDirection  compass direction to move new display objects in from;
  *        can be one of the values defined in dvt.BaseAnimation:
  *        DIR_C, DIR_N, DIR_NE, DIR_E, DIR_SE, DIR_S, DIR_SW, DIR_W, DIR_NW (default is DIR_NW)
  * @param {number}  minScale  minimum scale to make the objects as they fade
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimScaleFade = function(context, outObjs, inObjs, boundsRect, outDirection, inDirection, minScale, duration, delay)
{
  this.Init(context, outObjs, inObjs, boundsRect, outDirection, inDirection, minScale, duration, delay);
};

dvt.Obj.createSubclass(DvtCombinedAnimScaleFade, dvt.ParallelPlayable);


/**
  * @protected
  * @override
  */
DvtCombinedAnimScaleFade.prototype.Init = function(context, outObjs, inObjs, boundsRect, outDirection, inDirection, minScale, duration, delay)
{
  if (!outDirection)
    outDirection = dvt.BaseAnimation.DIR_NE;
  if (!inDirection)
    inDirection = dvt.BaseAnimation.DIR_NW;
  if (!minScale)
    minScale = 0.5;
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;

  var fadeOut = new dvt.AnimScaleFadeOut(context, outObjs, boundsRect, outDirection, minScale, duration, delay);
  var fadeIn = new dvt.AnimScaleFadeIn(context, inObjs, boundsRect, inDirection, minScale, duration, 0.3 * fadeOut.getDuration() + delay);

  DvtCombinedAnimScaleFade.superclass.Init.call(this, context, [fadeOut, fadeIn]);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class used to animate a set of display objects popping into the display
  * at staggered times.
  * @extends {dvt.ParallelPlayable}
  * @class dvt.CombinedAnimPopIn
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to pop in
  * @param {boolean}  bCenter  true to scale the object from its center,
  *        false to scale from its origin (true is not implemented yet)
  * @param {number}  popDuration  length of individual pop animations,
  *        in seconds
  * @param {number}  totalDuration  total length of time in which all
  *        individiual animations must run, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
dvt.CombinedAnimPopIn = function(context, objs, bCenter, popDuration, totalDuration, delay)
{
  this.Init(context, objs, bCenter, popDuration, totalDuration, delay);
};

dvt.Obj.createSubclass(dvt.CombinedAnimPopIn, dvt.ParallelPlayable);


/**
  * @protected
  * @override
  */
dvt.CombinedAnimPopIn.prototype.Init = function(context, objs, bCenter, popDuration, totalDuration, delay)
{
  var array = [];
  var dispObjArray;

  if (objs instanceof Array)
  {
    dispObjArray = objs;
  }
  else
  {
    dispObjArray = [objs];
  }

  delay = (delay === null || isNaN(delay)) ? 0 : delay;

  for (var i = 0; i < dispObjArray.length; i++)
  {
    var dispObj = dispObjArray[i];
    //if (dispObj instanceof dvt.Displayable)
    //{
    var individualDelay = delay + (Math.random() * (totalDuration - popDuration));//Randomize the delay @RandomNumberOk
    var popIn = new dvt.AnimPopIn(context, dispObj, bCenter, popDuration, individualDelay);
    array.push(popIn);
    //}
  }

  dvt.CombinedAnimPopIn.superclass.Init.call(this, context, array);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * Class used to animate a set of display objects popping out of the display
  * at staggered times.
  * @extends {dvt.ParallelPlayable}
  * @class DvtCombinedAnimPopOut
  * @constructor
  *
  * @param {dvt.Context}  context  platform specific context object
  * @param objs  a single dvt.Container or Array of DvtContainers to pop out
  * @param {boolean}  bCenter  true to scale the object from its center,
  *        false to scale from its origin (true is not implemented yet)
  * @param {number}  popDuration  length of individual pop animations,
  *        in seconds
  * @param {number}  totalDuration  total length of time in which all
  *        individiual animations must run, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimPopOut = function(context, objs, bCenter, popDuration, totalDuration, delay)
{
  this.Init(context, objs, bCenter, popDuration, totalDuration, delay);
};

dvt.Obj.createSubclass(DvtCombinedAnimPopOut, dvt.ParallelPlayable);


/**
  * @protected
  * @override
  */
DvtCombinedAnimPopOut.prototype.Init = function(context, objs, bCenter, popDuration, totalDuration, delay)
{
  var array = [];
  var dispObjArray;


  if (objs instanceof Array)
  {
    dispObjArray = objs;
  }
  else
  {
    dispObjArray = [objs];
  }

  delay = (delay === null || isNaN(delay)) ? 0 : delay;

  for (var i = 0; i < dispObjArray.length; i++)
  {
    var dispObj = dispObjArray[i];
    //if (dispObj instanceof dvt.Displayable)
    //{
    var individualDelay = delay + (Math.random() * (totalDuration - popDuration));//Randomize the delay @RandomNumberOk
    var popIn = new dvt.AnimPopOut(context, dispObj, bCenter, popDuration, individualDelay);
    array.push(popIn);
    //}
  }

  DvtCombinedAnimPopOut.superclass.Init.call(this, context, array);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*   DvtBaseDrawEffect                                                     */
/*-------------------------------------------------------------------------*/
/**
 * A base class for draw effects like sahodws, glows, etc.
 * {@link DvtBaseDrawEffect}.
 * @extends {DvtLockable}
 * @class DvtBaseDrawEffect  A base class for draw effects like sahodws, glows, etc.
 * @constructor  Do not create/use directly.
 */
var DvtBaseDrawEffect = function() {
  this._Init();
};

dvt.Obj.createSubclass(DvtBaseDrawEffect, DvtLockable);


/**
 * @private
 */
DvtBaseDrawEffect.prototype._Init = function() {
  DvtBaseDrawEffect.superclass._Init.call(this);
};


/**
 *   Returns the id of this draw effect.
 *   @type {String}
 */
DvtBaseDrawEffect.prototype.getId = function() {
  return this._id;
};


/**
 *   Sets the id of this fill.
 *   @param {String} id  The id for the fill.
 */
DvtBaseDrawEffect.prototype.setId = function(id) {
  this._id = id;
};


/**
 *   Merge properties in the current object into the supplied object.
 *   Abstract method, subclasses must implement. Used internally by clone().
 *   @param {dvt.Obj}
 *   @private
 */
DvtBaseDrawEffect.prototype.mergeProps = function(obj) {
  obj.setId(this._id);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*   dvt.ColorUtils       A static class for css color manipulation         */
/*-------------------------------------------------------------------------*/
/*   The static utility functions operate on color specifications of the   */
/*   format #rrggbb, or rgb(r,g,b), or rgba(r,g,b,a).                      */
/*-------------------------------------------------------------------------*/
/**  Static utility functions that operate on color specification strings of the
  *  format #rrggbb, or rgb(r,g,b), or rgba(r,g,b,a).
  *  @base dvt.ColorUtils
  */
dvt.ColorUtils = {};

dvt.Obj.createSubclass(dvt.ColorUtils, dvt.Obj);

//  Channel definition constants

dvt.ColorUtils._RED = 0;  // Channels. Don't change
dvt.ColorUtils._GREEN = 1;  // defs unless the routines
dvt.ColorUtils._BLUE = 2;  // below are changed.
dvt.ColorUtils._ALPHA = 3;

//  private constants

dvt.ColorUtils._RGBA = 'rgba(';
dvt.ColorUtils._RGB = 'rgb(';
dvt.ColorUtils._POUND = '#';

dvt.ColorUtils._FACTOR = 0.15;  // default darkening percentage.


/** @private */
dvt.ColorUtils._names;          // associative array


/*-------------------------------------------------------------------------*/
/*  getColorFromName()                                                     */
/*-------------------------------------------------------------------------*/
/**
  * Returns a color definition string from the named color.
  * @param {String}  name  The color name.
  * @type {String}
  * @return  An #rrggbb color string.
  */
dvt.ColorUtils.getColorFromName = function(name)
{
  if (! dvt.ColorUtils._names) {
    var ar = [];
    ar['aliceblue'] = '#f0f8ff';
    ar['antiquewhite'] = '#faEbd7';
    ar['aqua'] = '#00ffff';
    ar['aquamarine'] = '#7fffd4';
    ar['azure'] = '#f0ffff';
    ar['beige'] = '#f5f5dc';
    ar['bisque'] = '#ffE4c4';
    ar['black'] = '#000000';
    ar['blanchedalmond'] = '#ffEbcd';
    ar['blue'] = '#0000ff';
    ar['blueviolet'] = '#8a2bE2';
    ar['brown'] = '#a52a2a';
    ar['burlywood'] = '#dEb887';
    ar['cadetblue'] = '#5f9Ea0';
    ar['chartreuse'] = '#7fff00';
    ar['chocolate'] = '#d2691E';
    ar['coral'] = '#ff7f50';
    ar['cornflowerblue'] = '#6495Ed';
    ar['cornsilk'] = '#fff8dc';
    ar['crimson'] = '#dc143c';
    ar['cyan'] = '#00ffff';
    ar['darkblue'] = '#00008b';
    ar['darkcyan'] = '#008b8b';
    ar['darkgoldenrod'] = '#b8860b';
    ar['darkgray'] = '#a9a9a9';
    ar['darkgreen'] = '#006400';
    ar['darkkhaki'] = '#bdb76b';
    ar['darkmagenta'] = '#8b008b';
    ar['darkolivegreen'] = '#556b2f';
    ar['darkorange'] = '#ff8c00';
    ar['darkorchid'] = '#9932cc';
    ar['darkred'] = '#8b0000';
    ar['darksalmon'] = '#E9967a';
    ar['darkseagreen'] = '#8fbc8f';
    ar['darkslateblue'] = '#483d8b';
    ar['darkslategray'] = '#2f4f4f';
    ar['darkturquoise'] = '#00cEd1';
    ar['darkviolet'] = '#9400d3';
    ar['deeppink'] = '#ff1493';
    ar['deepskyblue'] = '#00bfff';
    ar['dimgray'] = '#696969';
    ar['dodgerblue'] = '#1E90ff';
    ar['firebrick'] = '#b22222';
    ar['floralwhite'] = '#fffaf0';
    ar['forestgreen'] = '#228b22';
    ar['fuchsia'] = '#ff00ff';
    ar['gainsboro'] = '#dcdcdc';
    ar['ghostwhite'] = '#f8f8ff';
    ar['gold'] = '#ffd700';
    ar['goldenrod'] = '#daa520';
    ar['gray'] = '#808080';
    ar['green'] = '#008000';
    ar['greenyellow'] = '#adff2f';
    ar['honeydew'] = '#f0fff0';
    ar['hotpink'] = '#ff69b4';
    ar['indianred '] = '#cd5c5c';
    ar['indigo '] = '#4b0082';
    ar['ivory'] = '#fffff0';
    ar['khaki'] = '#f0E68c';
    ar['lavender'] = '#E6E6fa';
    ar['lavenderblush'] = '#fff0f5';
    ar['lawngreen'] = '#7cfc00';
    ar['lemonchiffon'] = '#fffacd';
    ar['lightblue'] = '#add8E6';
    ar['lightcoral'] = '#f08080';
    ar['lightcyan'] = '#E0ffff';
    ar['lightgoldenrodyellow'] = '#fafad2';
    ar['lightgray'] = '#d3d3d3';
    ar['lightgreen'] = '#90EE90';
    ar['lightpink'] = '#ffb6c1';
    ar['lightsalmon'] = '#ffa07a';
    ar['lightseagreen'] = '#20b2aa';
    ar['lightskyblue'] = '#87cEfa';
    ar['lightslategray'] = '#778899';
    ar['lightsteelblue'] = '#b0c4dE';
    ar['lightyellow'] = '#ffffE0';
    ar['lime'] = '#00ff00';
    ar['limegreen'] = '#32cd32';
    ar['linen'] = '#faf0E6';
    ar['magenta'] = '#ff00ff';
    ar['maroon'] = '#800000';
    ar['mediumaquamarine'] = '#66cdaa';
    ar['mediumblue'] = '#0000cd';
    ar['mediumorchid'] = '#ba55d3';
    ar['mediumpurple'] = '#9370db';
    ar['mediumseagreen'] = '#3cb371';
    ar['mediumslateblue'] = '#7b68EE';
    ar['mediumspringgreen'] = '#00fa9a';
    ar['mediumturquoise'] = '#48d1cc';
    ar['mediumvioletred'] = '#c71585';
    ar['midnightblue'] = '#191970';
    ar['mintcream'] = '#f5fffa';
    ar['mistyrose'] = '#ffE4E1';
    ar['moccasin'] = '#ffE4b5';
    ar['navajowhite'] = '#ffdEad';
    ar['navy'] = '#000080';
    ar['oldlace'] = '#fdf5E6';
    ar['olive'] = '#808000';
    ar['olivedrab'] = '#6b8E23';
    ar['orange'] = '#ffa500';
    ar['orangered'] = '#ff4500';
    ar['orchid'] = '#da70d6';
    ar['palegoldenrod'] = '#EEE8aa';
    ar['palegreen'] = '#98fb98';
    ar['paleturquoise'] = '#afEEEE';
    ar['palevioletred'] = '#db7093';
    ar['papayawhip'] = '#ffEfd5';
    ar['peachpuff'] = '#ffdab9';
    ar['peru'] = '#cd853f';
    ar['pink'] = '#ffc0cb';
    ar['plum'] = '#dda0dd';
    ar['powderblue'] = '#b0E0E6';
    ar['purple'] = '#800080';
    ar['rebeccapurple'] = '#663399';
    ar['red'] = '#ff0000';
    ar['rosybrown'] = '#bc8f8f';
    ar['royalblue'] = '#4169E1';
    ar['saddlebrown'] = '#8b4513';
    ar['salmon'] = '#fa8072';
    ar['sandybrown'] = '#f4a460';
    ar['seagreen'] = '#2E8b57';
    ar['seashell'] = '#fff5EE';
    ar['sienna'] = '#a0522d';
    ar['silver'] = '#c0c0c0';
    ar['skyblue'] = '#87cEEb';
    ar['slateblue'] = '#6a5acd';
    ar['slategray'] = '#708090';
    ar['snow'] = '#fffafa';
    ar['springgreen'] = '#00ff7f';
    ar['steelblue'] = '#4682b4';
    ar['tan'] = '#d2b48c';
    ar['teal'] = '#008080';
    ar['thistle'] = '#d8bfd8';
    ar['tomato'] = '#ff6347';
    ar['turquoise'] = '#40E0d0';
    ar['violet'] = '#EE82EE';
    ar['wheat'] = '#f5dEb3';
    ar['white'] = '#ffffff';
    ar['whitesmoke'] = '#f5f5f5';
    ar['yellow'] = '#ffff00';
    ar['yellowgreen'] = '#9acd32';

    ar['transparent'] = 'rgba(255,255,255,0)';

    dvt.ColorUtils._names = ar;
  }
  return dvt.ColorUtils._names[name];

};


/*-------------------------------------------------------------------------*/
/*  isColor()                                                              */
/*-------------------------------------------------------------------------*/
/**
 * Determine if the given string specifies a color value.
 * @param {String}  s  The string to be evaluated.
 * @param {Boolean}  bValid  Optional.  If omitted or false, the string prefix
 *                           is checked for validity only. If true, a deeper
 *                           check of the rgb component values is performed.
 * @type {Boolean}
 * @return true if the string specifies a color value, else false.
 */
dvt.ColorUtils.isColor = function(s, bValid)
{
  if (! bValid) {
    return ((s.charAt(0) === dvt.ColorUtils._POUND) ||
            (s.indexOf(dvt.ColorUtils._RGBA) === 0) ||
            (s.indexOf(dvt.ColorUtils._RGB) === 0));
  }

  // Deeper validation

  var bRet = false;

  s = dvt.StringUtils.trim(s);
  s = s.toLowerCase();

  if (s.charAt(0) === dvt.ColorUtils._POUND) {
    if (s.length === 7) {
      var pat = new RegExp(/^#[0-9a-f]{6}$/i);
      bRet = pat.test(s);
    }
  }
  else {
    var bRGBA = (s.indexOf(dvt.ColorUtils._RGBA) === 0);
    var bRGB;

    if (! bRGBA) {
      bRGB = (s.indexOf(dvt.ColorUtils._RGB) === 0);
    }

    if (bRGBA || bRGB) {
      var x = s.indexOf(')');

      if (x >= 0) {
        var ar = s.substring((bRGBA ? 5 : 4), x).split(',');
        var len = ar.length;
        var bVals = true;

        for (var i = 0; i < len; i++) {
          var n = ar[i];
          if (((1 < 3) && (n < 0 || n > 255)) || ((i > 3) && (n < 0 || n > 1))) {
            bVals = false;
            break;
          }
        }

        if (bVals) {
          bRet = (bRGBA ? (len === 4) : (len === 3));
        }
      }
    }
  }

  return bRet;
};


/*-------------------------------------------------------------------------*/
/*   get/setAlpha()                                                        */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the alpha value (or implied value) of the specified color string.
  *  @param {String} c The color specification.
  *  @type {number}
  *  @return {number}  The alpha-channel value (between 0 and 1).
  */
dvt.ColorUtils.getAlpha = function(c)
{
  return dvt.ColorUtils._getChannel(c, dvt.ColorUtils._ALPHA);
};


/**
  *  Changes the alpha channel in the supplied color string.
  *  @param {String} c The color specification.
  *  @param {number} a The alpha value (range 0 to 1).
  *  @type {String}
  *  @return  A new color specification.
  */
dvt.ColorUtils.setAlpha = function(c, a)
{
  return dvt.ColorUtils._setChannel(c, dvt.ColorUtils._ALPHA, a);
};


/*-------------------------------------------------------------------------*/
/*   get/setRed()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the red-channel value of the specified color string.
  *  @param {String} c The color specification.
  *  @type {number}
  *  @return   The red-channel value as a decimal number between 0 and 255.
  */
dvt.ColorUtils.getRed = function(c)
{
  return dvt.ColorUtils._getChannel(c, dvt.ColorUtils._RED);
};


/**
  *  Changes the red-channel value in the supplied color string.
  *  @param {String} c The color specification.
  *  @param {number} r The red channel value as a decimal number between 0 and 255.
  *  @type {String}
  *  @return  A new color string specification.
  */
dvt.ColorUtils.setRed = function(c, r)
{
  return dvt.ColorUtils._setChannel(c, dvt.ColorUtils._RED, r);
};


/*-------------------------------------------------------------------------*/
/*   get/setBlue()                                                         */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the blue-channel value of the specified color string.
  *  @param {String} c The color specification.
  *  @type {number}
  *  @return  The blue-channel value as a decimal number between 0 and 255.
  */
dvt.ColorUtils.getBlue = function(c)
{
  return dvt.ColorUtils._getChannel(c, dvt.ColorUtils._BLUE);
};


/**
  *  Changes the blue-channel value in the supplied color string.
  *  @param {String} c The color specification.
  *  @param {number} b The blue channel value as a decimal number.
  *  @type {String}
  *  @return  A new color string specification.
  */
dvt.ColorUtils.setBlue = function(c, b)
{
  return dvt.ColorUtils._setChannel(c, dvt.ColorUtils._BLUE, b);
};


/*-------------------------------------------------------------------------*/
/*   get/setGreen()                                                        */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the green-channel value of the specified color string.
  *  @param {String} c The color specification.
  *  @type {number}
  *  @return   The green value as a decimal number between 0 and 255.
  */
dvt.ColorUtils.getGreen = function(c)
{
  return dvt.ColorUtils._getChannel(c, dvt.ColorUtils._GREEN);
};


/**
  *  Changes the green-channel value in the supplied color string.
  *  @param {String} c The color specification.
  *  @param {number} g The green channel value as a decimal number between 0 and 255.
  *  @type {String}
  *  @return  A new color string specification.
  */
dvt.ColorUtils.setGreen = function(c, g)
{
  return dvt.ColorUtils._setChannel(c, dvt.ColorUtils._GREEN, g);
};


/*-------------------------------------------------------------------------*/
/*   getChannel()     Returns a channel from a #, rgb or rgba string.      */
/*                    (Note: if an alpha channel is requested and a # or   */
/*                    rgb string is supplied, the implied value of 1 is    */
/*                    returned.                                            */
/*-------------------------------------------------------------------------*/
/**
  *  Returns a specifed channel value from a css color specification (#, rgb(), rgba()).
  *  If an alpha channel is requested and a # or rgb string is supplied,
  *  an implied value of 1 is returned.
  *  @private
  *  @param  {String} c  The color string.
  *  @param  {number} chan  The channel (see {@dvt.ColorUtils#_RED} for example).
  *  @type {number}
  *  @return The channel value as a decimal number (between 0 and 255).
  */
dvt.ColorUtils._getChannel = function(c, chan)
{
  var clr = c;
  var chval = null;// the return value

  // If clr is a named color, then convert into usable format
  var namedColor = dvt.ColorUtils.getColorFromName(clr);
  if (namedColor)
    clr = namedColor;

  // Alpha support
  if (chan === dvt.ColorUtils._ALPHA) {
    if (clr.charAt(0) === '#')
      return (clr.length > 7) ? parseInt(clr.substring(1, 3), 16) / 255 : 1;//check for MT extended format of #aarrggbb
    else if (clr === 'none')
      return 0;
  }

  var x1 = clr.indexOf('(');
  if (x1 < 0) {
    ar = [];
    //: parse channels for different # formats
    if (clr.length > 7) {
      //  #aarrggbb format
      ar[0] = parseInt(clr.substr(3, 2), 16);
      ar[1] = parseInt(clr.substr(5, 2), 16);
      ar[2] = parseInt(clr.substr(7, 2), 16);
      ar[3] = parseInt(clr.substr(1, 2), 16) / 255;
    }
    else {
      //  #rrggbb format
      ar[0] = parseInt(clr.substr(1, 2), 16);
      ar[1] = parseInt(clr.substr(3, 2), 16);
      ar[2] = parseInt(clr.substr(5, 2), 16);
      ar[3] = 1;
    }
    chval = ar[chan];
  }
  else {

    //  rgb() or rgba() format
    var x2 = clr.indexOf(')');
    var ar = clr.substring(x1 + 1, x2).split(',');

    if (ar.length === 3 && chan === dvt.ColorUtils._ALPHA) {
      chval = 1;
    }
    else {
      chval = ar[chan];
      chval = parseFloat(chval);
    }
  }

  return chval;
};


/*-------------------------------------------------------------------------*/
/*   getDarker()                                                           */
/*-------------------------------------------------------------------------*/
/**
  * Returns the specified color made darker by the specified percentage.
  * <p>
  * Example:<br><br><code>
  * // create a color darkened by 25%).
  *  var darker = dvt.ColorUtils.getDarker("rgba(220,128,49)", 0.25) ;<br>
  *  </code>
  * @param {String} color   A color specification.
  * @param {number} factor  An optional percentage by which each color component is to be
  *                         darkened (1 returns unchanged) specified as a decimal
  *                         (e.g. 25% = 0.25).  If omitted, a default percentage of
  *                         15% (i.e 0.15) is applied.
  * @type {String}
  * @return A darkened color specification in RGBA format.
  */
dvt.ColorUtils.getDarker = function(color, factor)
{
  //TDO

  var r = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._RED);
  var g = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._GREEN);
  var b = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._BLUE);
  var a = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._ALPHA);

  if (! factor) {
    factor = dvt.ColorUtils._FACTOR;    // use default factor
  }

  r = Math.max(parseInt(r * factor), 0);
  g = Math.max(parseInt(g * factor), 0);
  b = Math.max(parseInt(b * factor), 0);

  return dvt.ColorUtils.makeRGBA(r, g, b, a);
};


/*-------------------------------------------------------------------------*/
/*   getGrey()                                                             */
/*-------------------------------------------------------------------------*/
/**
  * @this {dvt.ColorUtils}
  *   Returns a greyscale version of the supplied color (in the same format).
  *   @param {String} color  The color to be converted.
  *   @return a greyscale version of the supplied color
  *   @type {String}
  *   @return a greyscale version of the supplied color (in the same format).
  */
dvt.ColorUtils.getGrey = function(color)
{
  var ret;

  var r = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._RED);
  var g = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._BLUE);
  var b = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._GREEN);

  var gray = Math.round((r * 0.3) + (g * 0.59) + (b * 0.11));

  return this.setRGB(color, gray, gray, gray);
};


/*-------------------------------------------------------------------------*/
/*   invert()                                                              */
/*-------------------------------------------------------------------------*/
/**
  *   Inverts the specified color.
  *   @param {String} c   The color to be inverted.
  *   @type  {String}
  *   @return The inverted color in the same color format as supplied.
  */
dvt.ColorUtils.invert = function(c) {

  var ret;

  var r = 255 - dvt.ColorUtils._getChannel(c, dvt.ColorUtils._RED);
  var g = 255 - dvt.ColorUtils._getChannel(c, dvt.ColorUtils._BLUE);
  var b = 255 - dvt.ColorUtils._getChannel(c, dvt.ColorUtils._GREEN);

  if (c.charAt(0) === '#') {
    ret = dvt.ColorUtils.makePound(r, g, b);
  }
  else if (c.substr(0, 4) === dvt.ColorUtils._RGB) {
    ret = dvt.ColorUtils.makeRGB(r, g, b);
  }
  else {
    ret = dvt.ColorUtils.makeRGBA(r, g, b, dvt.ColorUtils._getChannel(c, dvt.ColorUtils._ALPHA));
  }

  return ret;
};


/*-------------------------------------------------------------------------*/
/*   isRGBA()                                                              */
/*-------------------------------------------------------------------------*/
/**
  *   Returns true if the color string is of rgba(...) format.
  *   @param {String} c   the color to be tested.
  *   @return {boolean}  true if the color is of rgba(. . .) type, else false.
  */
dvt.ColorUtils.isRGBA = function(c)
{
  return (c.substr(0, 5) === dvt.ColorUtils._RGBA);
};


/*-------------------------------------------------------------------------*/
/*   makeRGB()                                                             */
/*-------------------------------------------------------------------------*/
/**
  *  Creates an rgb(...) format from the supplied red, green, blue channel values.
  *  @param {number} r  The red value as a decimal number in the range 0 - 255.
  *  @param {number} g  The green value as a decimal number in the range 0 - 255.
  *  @param {number} b  The blue value as a decimal number in the range 0 - 255.
  *  @type {String}
  *  @return A new rgb(. . .) format string.
  */
dvt.ColorUtils.makeRGB = function(r,g,b)
{
  b = ((b === null || isNaN(b)) ? 0 : b);
  g = ((g === null || isNaN(g)) ? 0 : g);
  r = ((r === null || isNaN(r)) ? 0 : r);

  return dvt.ColorUtils._RGB + r + ',' + g + ',' + b + ')';
};


/*-------------------------------------------------------------------------*/
/*   makeRGBA()                                                            */
/*-------------------------------------------------------------------------*/
/**
  *  Creates an rgba(...) format string using the supplied red, green, blue,
  *   and alpha channel values.
  *  @param {number} r  The red value as a decimal number in the range 0 - 255.
  *  @param {number} g  The green value as a decimal number in the range 0 - 255.
  *  @param {number} b  The blue value as a decimal number in the range 0 - 255.
  *  @param {number} a  The alpha value as a decimal number in the range 0 - 1.
  *                  If omitted, 1 is assumed.
  *  @type {String}
  *  @return A new rgba(. . .) format string.
  */
dvt.ColorUtils.makeRGBA = function(r,g,b,a)
{
  b = ((b === null || isNaN(b)) ? 0 : Math.round(b));
  g = ((g === null || isNaN(g)) ? 0 : Math.round(g));
  r = ((r === null || isNaN(r)) ? 0 : Math.round(r));
  a = ((a === null || isNaN(a)) ? 1 : a);

  return dvt.ColorUtils._RGBA + r + ',' + g + ',' + b + ',' + a + ')';
};


/*-------------------------------------------------------------------------*/
/*   makePound()                                                           */
/*-------------------------------------------------------------------------*/
/**
  *  Creates a #rrggbb format string using the supplied red, green and blue
  *  channel values.
  *  @param {number} r  The red value as a decimal number in the range 0 - 255.
  *  @param {number} g  The green value as a decimal number in the range 0 - 255.
  *  @param {number} b  The blue value as a decimal number in the range 0 - 255.
  *  @type {String}
  *  @return A new #rrggbb format string.
  */
dvt.ColorUtils.makePound = function(r,g,b)
{
  var rr = Math.round(r);
  var gg = Math.round(g);
  var bb = Math.round(b);
  var red = rr.toString(16);
  var green = gg.toString(16);
  var blue = bb.toString(16);

  return '#' + (red.length === 1 ? '0' : '') + red + (green.length === 1 ? '0' : '') + green +
      (blue.length === 1 ? '0' : '') + blue;
};


/*-------------------------------------------------------------------------*/
/*   getPound()  Returns a "#rrggbb" string from a color string            */
/*              specification such as #rr[gg[bb[aa]]], rgba(...), rgb(...) */
/*-------------------------------------------------------------------------*/
/**
  *   Returns a "#rrggbb"  color string from the supplied color string. Formats
  *   accepted are the extended middle-tier "#aarrggbb" string, "rgba(r,g,b,a)",
  *   or an "rgb(r,g,b)". If a "#rrggbb" is supplied, the same object will be
  *   returned.  (See also {@link dvt.ColorUtils#makePound}.)
  *   @param {String} s  A color string specification.
  *   @return {String}  a string of the format "#rrggbb".
  */
dvt.ColorUtils.getPound = function(s)
{
  var ret;

  if (s.charAt(0) === '#') {

    var len = s.length;

    if (len <= 7) {
      return s;
    }
    else {             // alpha specified (#aarrggbb) - middle-tier extended format
      ret = dvt.ColorUtils._POUND;
      ret += s.substring(3, 5) + s.substring(5, 7) + s.substring(7, 9);
    }
  }
  else {
    var r = dvt.ColorUtils.getRed(s);
    var g = dvt.ColorUtils.getGreen(s);
    var b = dvt.ColorUtils.getBlue(s);
    ret = dvt.ColorUtils.makePound(r, g, b);
  }

  return ret;

};


/*-------------------------------------------------------------------------*/
/*   getRGB()   Returns an rgb(rr,gg,bb) string from a color string        */
/*              specification such as #rr[gg[bb[aa]]], rgba(...), rgb(...) */
/*-------------------------------------------------------------------------*/
/**
  *   Returns an "rgb(r,g,b)"  color string from a supplied "#rrggbb" or
  *   extended middle-tier "#aarrggbb" string, or an rgb(r,g,b,a).
  *   If an "rgb(r,g,b)" is supplied, the same object will be returned.  (See also {@link dvt.ColorUtils#makePound}.)
  *   @param {String} s  A color string specification.
  *   @type {String.}
  */
dvt.ColorUtils.getRGB = function(s)
{
  var ret;

  // If clr is a named color, then convert into usable format
  var namedColor = dvt.ColorUtils.getColorFromName(s);
  if (namedColor)
    s = namedColor;

  if (s.charAt(0) === '#') {
    ret = dvt.ColorUtils._RGB;

    var len = s.length;

    if (len > 7) {             // alpha specified (#aarrggbb) - middle-tier extended format
      ret += parseInt(s.substring(3, 5), 16) + ',' + parseInt(s.substring(5, 7), 16) + ',' +
              parseInt(s.substring(7, 9), 16);
    }
    else if (len === 7) {      // alpha not specified (#rrggbb)
      ret += parseInt(s.substring(1, 3), 16) + ',' + parseInt(s.substring(3, 5), 16) + ',' +
              parseInt(s.substr(5), 16);
    }
    else if (len === 4) {      // #rgb
      var r = s.substring(1, 2);
      r += r;
      var g = s.substring(2, 3);
      g += g;
      var b = s.substring(3);
      b += b;

      ret += parseInt(r, 16) + ',' + parseInt(g, 16) + ',' + parseInt(b, 16);
    }
    else if (len === 5) {      // #rrgg
      ret += parseInt(s.substring(1, 3), 16) + ',' + parseInt(s.substring(3, 5), 16) + ',0,1';
    }
    else if (len === 3) {      // #rr
      ret += parseInt(s.substring(1, 3), 16) + ',0,0,1';
    }

    ret += ')';
  }
  else if (s.substr(0, 5) === dvt.ColorUtils._RGBA) {
    var x = s.lastIndexOf(',');
    ret = dvt.ColorUtils._RGB;
    ret += s.substring(5, x);
    ret += ')';
  }
  else {
    ret = s;
  }
  return ret;

};


/*-------------------------------------------------------------------------*/
/*   getRGBA()  Returns an rgba(rr,gg,bb,aa) string from a color string    */
/*              specification such as #rr[gg[bb[aa]]], rgb(...), rgba(...) */
/*-------------------------------------------------------------------------*/
/**
  *   Returns an "rgba(r,g,b,a)"  color string from a supplied "#rrggbb" or
  *   extended middle-tier "#aarrggbb" string.  Will also accept an rgb(r,g,b)
  *   string (in which case the implied alpha is 1).  If an "rgba(r,g,b,a)" is
  *   supplied, the same object will be returned.  (See also {@link dvt.ColorUtils#makePound}.)
  *   @param {String} s  A color string specification.
  *   @type {String.}
  */
dvt.ColorUtils.getRGBA = function(s)
{
  var ret;

  // If clr is a named color, then convert into usable format
  var namedColor = dvt.ColorUtils.getColorFromName(s);
  if (namedColor)
    s = namedColor;

  if (s.charAt(0) === '#') {
    ret = dvt.ColorUtils._RGBA;

    var len = s.length;

    if (len > 7) {             // alpha specified (#aarrggbb)
      ret += parseInt(s.substring(3, 5), 16) + ',' + parseInt(s.substring(5, 7), 16) + ',' +
              parseInt(s.substring(7, 9), 16) + ',' + (parseInt(s.substring(1, 3), 16) / 255);
    }
    else if (len === 7) {      // alpha not specified (#rrggbb)  - alpha of 1 is assumed
      ret += parseInt(s.substring(1, 3), 16) + ',' + parseInt(s.substring(3, 5), 16) + ',' +
              parseInt(s.substr(5), 16) + ',1';
    }
    else if (len === 5) {      // #rrgg
      ret += parseInt(s.substring(1, 3), 16) + ',' + parseInt(s.substring(3, 5), 16) + ',0,1';
    }
    else if (len === 4) {      // #rgb
      var r = s.substring(1, 2);
      r += r;
      var g = s.substring(2, 3);
      g += g;
      var b = s.substring(3);
      b += b;

      ret += parseInt(r, 16) + ',' + parseInt(g, 16) + ',' + parseInt(b, 16) + ',1';
    }
    else if (len === 3) {      // #rr
      ret += parseInt(s.substring(1, 3), 16) + ',0,0,1';
    }

    ret += ')';
  }
  else if (s.substr(0, 4) === dvt.ColorUtils._RGB) {
    ret = dvt.ColorUtils._RGBA;
    ret += s.substring(4, s.length - 1) + ',1)';
  }
  else {
    ret = s;
  }
  return ret;

};


/*-------------------------------------------------------------------------*/
/*  _setChannel()     Replaces a channel in an rgb or rgba string.  (Note: */
/*                    if an alpha channel is added and an rgb string was   */
/*                    supplied, the string is changed to an rgba string.)  */
/*-------------------------------------------------------------------------*/
/**
  *  Returns a new color String with the specifed channel value set.
  *  If an alpha channel is requested and a # or rgb string is supplied,
  *  an rgba(...) string is returned.
  *  @private
  *  @param {String} s     A color specification to be changed.
  *  @param {number} chan  The channel to be changed.
  *  @param {number} chval The new channel value (as a decimal number).
  *  @type {String}
  */
dvt.ColorUtils._setChannel = function(s, chan, chval)
{
  if ((chan === undefined) || (chval === undefined) || (chan < dvt.ColorUtils._RED) || (chan > dvt.ColorUtils._ALPHA)) {
    return s;
  }

  // If named color, then convert into usable format
  var namedColor = dvt.ColorUtils.getColorFromName(s);
  if (namedColor)
    s = namedColor;

  var ar;
  var bPound = (s.charAt(0) === '#');
  var bRGBA;
  var ret;
  if (bPound) {
    ar = [];
    ar.push(parseInt(s.substr(1, 2), 16));
    ar.push(parseInt(s.substr(3, 2), 16));
    ar.push(parseInt(s.substr(5, 2), 16));
    if (chan === dvt.ColorUtils._ALPHA) {
      ar.push(chval);
      bPound = false;
      bRGBA = true;
    }
  }
  else {
    var bRGBA = (s.substr(0, 5) === dvt.ColorUtils._RGBA);
    var x1 = s.indexOf('(');
    var x2 = s.indexOf(')');
    var ar = s.substring(x1 + 1, x2).split(',');

    if ((! bRGBA) && chan === dvt.ColorUtils._ALPHA) {
      ar.push(chval);
      bRGBA = true;
    }
  }

  ar[chan] = chval;

  if (bPound) {
    ret = dvt.ColorUtils.makePound(ar[0], ar[1], ar[2]);
  }
  else {
    ret = (bRGBA ? dvt.ColorUtils.makeRGBA(ar[0], ar[1], ar[2], ar[3]) :
        dvt.ColorUtils.makeRGB(ar[0], ar[1], ar[2]));
  }
  return ret;

};


/*-------------------------------------------------------------------------*/
/*   setRGB()                                                              */
/*-------------------------------------------------------------------------*/
/**
  *  Returns a string of the same format as the input string, with the red, green,
  *  and blue channels replaced.
  *  @param {String}  s  The input string.
  *  @param {number}  r  The red value as a decimal number.
  *  @param {number}  g  The green value as a decimal number.
  *  @param {number}  b  The blue value as a decimal number.
  *  @type {String}
  *  @return A new color string of the same format as the input string, with
  *  the new color values.
  */
dvt.ColorUtils.setRGB = function(s, r, g, b)
{
  b = ((b === null || isNaN(b)) ? 0 : b);
  g = ((g === null || isNaN(g)) ? 0 : g);
  r = ((r === null || isNaN(r)) ? 0 : r);

  if (s.charAt(0) === '#')
  {
    return dvt.ColorUtils.makePound(r, g, b);
  }

  var bRGBA = (s.substr(0, 5) === dvt.ColorUtils._RGBA);

  var ret = (bRGBA ? dvt.ColorUtils._RGBA : dvt.ColorUtils._RGB) + r + ',' + g + ',' + b;

  if (bRGBA) {
    var x1 = s.lastIndexOf(5, ',');
    var x2 = s.indexOf(')');

    ret += ',' + s.substring(x1 + 1, x2);
  }
  ret += ')';
  return ret;
};


/**
  * Returns a brighter color of the supplied color based on a percentage factor.
  * @param {String} color   A color specification.
  * @param {number} factor  An optional percentage by which the color is to be brightened
  *                         lightened (1 returns unchanged) specified as a decimal
  *                         (e.g. 25% = 0.25).  If omitted, a default percentage of
  *                         15% (i.e 0.15) is applied.
  * @type {String}
  * @return  A new color string brightened by the factor <code>uint</code> containing the new color value.
  */
dvt.ColorUtils.getBrighter = function(color, factor)
{
  var r = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._RED);
  var g = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._GREEN);
  var b = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._BLUE);
  var a = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._ALPHA);

  if (! factor) {
    factor = dvt.ColorUtils._FACTOR;    // use default factor
  }

  // From 2D group:
  // 1. black.brighter() should return grey
  // 2. applying brighter to blue will always return blue, brighter
  // 3. non pure color (non zero rgb) will eventually return white

  var i = parseInt(1.0 / (1.0 - factor));
  if (r === 0 && g === 0 && b === 0) {
    //if factor=.5, then this only creates a color of rgb(2,2,2),
    //which is still black, so instead, just use the factor times white
    //return dvt.ColorUtils.makeRGBA(i, i, i, a);
    var newI = parseInt(255 * factor);
    return dvt.ColorUtils.makeRGBA(newI, newI, newI, a);
  }

  if (r > 0 && r < i) {
    r = i;
  }
  if (g > 0 && g < i) {
    g = i;
  }
  if (b > 0 && b < i) {
    b = i;
  }

  r = Math.min(parseInt(r / factor), 255);
  g = Math.min(parseInt(g / factor), 255);
  b = Math.min(parseInt(b / factor), 255);

  return dvt.ColorUtils.makeRGBA(r, g, b, a);
};


/**
 * Returns the hsl values for a color with the given rgb.
 * @param {number} r The r value, on a scale from 0 to 255
 * @param {number} g The g value, on a scale from 0 to 255
 * @param {number} b The b value, on a scale from 0 to 255
 * @return {object} The object containing the h, s, and l fields.  The h field is on a scale from 0 to 360, and the s
 *                  and l fields are on a scale from 0 to 1.
 */
dvt.ColorUtils.rgb2hsl = function(r, g, b) {
  // Scale rgb to be from 0 to 1
  r /= 255;
  g /= 255;
  b /= 255;

  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var sum = max + min;

  var h, s;
  var l = sum / 2;

  if (max == min) {
    h = 0;
    s = 0;
  }
  else {
    var diff = max - min;
    s = l > 0.5 ? diff / (2 - sum) : diff / sum;

    if (max == r)
      h = (g - b) / diff + (g < b ? 6 : 0);
    else if (max == g)
      h = (b - r) / diff + 2;
    else if (max == b)
      h = (r - g) / diff + 4;

    h /= 6;
  }

  return {h: h * 360, s: s, l: l};
};


/**
 * Returns the rgb values for a color with the given hsl.
 * @param {number} h The h value, on a scale from 0 to 360
 * @param {number} s The s value, on a scale from 0 to 1
 * @param {number} l The l value, on a scale from 0 to 1
 * @return {object} The object containing the r, g, and b fields on a scale from 0 to 255.
 */
dvt.ColorUtils.hsl2rgb = function(h, s, l) {
  // Scale h to be from 0 to 1
  h /= 360;

  var r, g, b;
  if (s == 0)
    r = g = b = l;
  else {
    var q = l < 0.5 ? l * (1 + s) : l + s - (l * s);
    var p = 2 * l - q;
    r = dvt.ColorUtils._hue2rgb(p, q, h + 1 / 3);
    g = dvt.ColorUtils._hue2rgb(p, q, h);
    b = dvt.ColorUtils._hue2rgb(p, q, h - 1 / 3);
  }

  return {r: r * 255, g: g * 255, b: b * 255};
};


/**
 * @private
 */
dvt.ColorUtils._hue2rgb = function(p, q, t) {
  if (t < 0)
    t += 1;
  else if (t > 1)
    t -= 1;

  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  else if (t < 1 / 2)
    return q;
  else if (t < 2 / 3)
    return p + (q - p) * (2 / 3 - t) * 6;
  else
    return p;
};


/**
  * Converts an HSV color to RGB.
  *
  * @param (number) hue hue of the HSV color
  * @param (number) sat saturation of the HSV color
  * @param (number) val value of the HSV color
  *
  * @type {object}
  * @return an object defining r,g,b for the color
  */
dvt.ColorUtils.hsv2rgb = function(hue, sat, val)
{
  var red;
  var grn;
  var blu;
  var i;
  var f;
  var p;
  var q;
  var t;

  hue %= 360;
  if (val == 0)
  {
    return (
        {
          r: 0, g: 0, v: 0
        });
  }
  sat /= 100;
  val /= 100;
  hue /= 60;
  i = Math.floor(hue);
  f = hue - i;
  p = val * (1 - sat);
  q = val * (1 - (sat * f));
  t = val * (1 - (sat * (1 - f)));
  if (i == 0)
  {
    red = val;
    grn = t;
    blu = p;
  }
  else if (i == 1)
  {
    red = q;
    grn = val;
    blu = p;
  }
  else if (i == 2)
  {
    red = p;
    grn = val;
    blu = t;
  }
  else if (i == 3)
  {
    red = p;
    grn = q;
    blu = val;
  }
  else if (i == 4)
  {
    red = t;
    grn = p;
    blu = val;
  }
  else if (i == 5)
  {
    red = val;
    grn = p;
    blu = q;
  }
  red = Math.floor(red * 255);
  grn = Math.floor(grn * 255);
  blu = Math.floor(blu * 255);
  return ({r: red, g: grn, b: blu});
};


/**
  * Converts an RGB color to HSV.
  *
  * @param (number) red red of the RGB color
  * @param (number) grn green of the RGB color
  * @param (number) blu blue of the RGB color
  *
  * @type {object}
  * @return an object defining h,s,v for the color
  */
dvt.ColorUtils.rgb2hsv = function(red, grn, blu)
{
  var x;
  var val;
  var f;
  var i;
  var hue;
  var sat;

  red /= 255;
  grn /= 255;
  blu /= 255;
  x = Math.min(red, grn, blu);
  val = Math.max(red, grn, blu);
  if (x == val)
  {
    return ({h: undefined, s: 0, v: val * 100});
  }
  f = (red == x) ? grn - blu : ((grn == x) ? blu - red : red - grn);
  i = (red == x) ? 3 : ((grn == x) ? 5 : 1);
  hue = Math.floor((i - f / (val - x)) * 60) % 360;
  sat = Math.floor(((val - x) / val) * 100);
  val = Math.floor(val * 100);
  return ({h: hue, s: sat, v: val});
};


/**
  * Returns a pastel color using the supplied color based on a ratio.
  *
  *
  * @param (String) color  A color specification.
  * @param (number) factor An optional percentage by which to apply the pastel effect (0 returns unchanged)
  *                        specified as a decimal (e.g., 25% = 0.25).  If omitted, the default percentage of
  *                        15% (i.e., 0.15) is applied.
  *
  * @return A <code>uint</code> containing the new color value.
  */
dvt.ColorUtils.getPastel = function(color, factor)
{
  // TDO
  var a = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._ALPHA);
  var r = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._RED);
  var g = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._GREEN);
  var b = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._BLUE);

  var gR = Math.min(r + parseInt((255 - r) * factor), 255);
  var gG = Math.min(g + parseInt((255 - g) * factor), 255);
  var gB = Math.min(b + parseInt((255 - b) * factor), 255);

  return dvt.ColorUtils.makeRGBA(gR, gG, gB, a);

};


/**
 * Returns a color whose lightness has been adjusted by the specified amount.
 * @param {string} color The original color.
 * @param {number} dh The change in hue.
 * @param {number} ds The change in saturation.
 * @param {number} dl The change in lightness.
 * @return {string} The adjusted color.
 */
dvt.ColorUtils.adjustHSL = function(color, dh, ds, dl) 
{
  // Cache the adjusted values for performance.
  if (!dvt.ColorUtils._hslCache)
    dvt.ColorUtils._hslCache = new dvt.Cache(100);

  // Create the key and look for the cache entry.
  var key = color + ':' + dh + ':' + ds + ':' + dl;
  var ret = dvt.ColorUtils._hslCache.get(key);
  if (ret != null)
    return ret;

  // Break down in rgba
  var r = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._RED);
  var g = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._GREEN);
  var b = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._BLUE);
  var a = dvt.ColorUtils._getChannel(color, dvt.ColorUtils._ALPHA);

  // Get the color as HSL
  var hslColor = dvt.ColorUtils.rgb2hsl(r, g, b);

  // Add the changes, bounded to the min and max for each value
  var h = Math.min(Math.max(0, hslColor.h + dh), 360);
  var s = Math.min(Math.max(0, hslColor.s + ds), 1);
  var l = Math.min(Math.max(0, hslColor.l + dl), 1);

  // Convert back to rgba and return
  var rgbColor = dvt.ColorUtils.hsl2rgb(h, s, l);
  if (a == 1)
    ret = dvt.ColorUtils.makePound(rgbColor.r, rgbColor.g, rgbColor.b);
  else
    ret = dvt.ColorUtils.makeRGBA(rgbColor.r, rgbColor.g, rgbColor.b, a);

  // Store in the cache and return
  dvt.ColorUtils._hslCache.put(key, ret);
  return ret;
};


/**
  * Interpolate a color between the original and destination values for the
  * given percent.
  * @param  origVal  original color value, a string
  * @param  destVal  destination color value, a string
  * @param {number}  percent  percent value to interpolate
  */
dvt.ColorUtils.interpolateColor = function(origVal, destVal, percent)
{
  var oldR = dvt.ColorUtils.getRed(origVal);
  var oldG = dvt.ColorUtils.getGreen(origVal);
  var oldB = dvt.ColorUtils.getBlue(origVal);
  var oldA = dvt.ColorUtils.getAlpha(origVal);

  var destR = dvt.ColorUtils.getRed(destVal);
  var destG = dvt.ColorUtils.getGreen(destVal);
  var destB = dvt.ColorUtils.getBlue(destVal);
  var destA = dvt.ColorUtils.getAlpha(destVal);

  var newR = Math.round(dvt.Math.interpolateNumber(oldR, destR, percent));
  var newG = Math.round(dvt.Math.interpolateNumber(oldG, destG, percent));
  var newB = Math.round(dvt.Math.interpolateNumber(oldB, destB, percent));
  var newA = dvt.Math.interpolateNumber(oldA, destA, percent);

  return dvt.ColorUtils.makeRGBA(newR, newG, newB, newA);
};

dvt.ColorUtils.inferColor = function(baseColor1, baseColor2, newColor1) {
  if (baseColor1 == baseColor2) {
    return newColor1;
  }

  if (newColor1 == baseColor1) {
    return baseColor2;
  }

  var red;
  var divisor = dvt.ColorUtils.getRed(baseColor1);
  var dividend = dvt.ColorUtils.getRed(baseColor2);
  if (divisor == dividend) {
    red = dvt.ColorUtils.getRed(newColor1);
  }
  else {
    if (divisor == 0) {
      divisor = 1;
    }
    red = dividend / divisor * dvt.ColorUtils.getRed(newColor1);
  }
  var green;
  divisor = dvt.ColorUtils.getGreen(baseColor1);
  dividend = dvt.ColorUtils.getGreen(baseColor2);
  if (divisor == dividend) {
    green = dvt.ColorUtils.getGreen(newColor1);
  }
  else {
    if (divisor == 0) {
      divisor = 1;
    }
    green = dividend / divisor * dvt.ColorUtils.getGreen(newColor1);
  }
  var blue;
  divisor = dvt.ColorUtils.getBlue(baseColor1);
  dividend = dvt.ColorUtils.getBlue(baseColor2);
  if (divisor == dividend) {
    blue = dvt.ColorUtils.getBlue(newColor1);
  }
  else {
    if (divisor == 0) {
      divisor = 1;
    }
    blue = dividend / divisor * dvt.ColorUtils.getBlue(newColor1);
  }
  //return (0xffffff & (red << 16)) + (0xffff & (green << 8)) + (0xff & blue);
  return dvt.ColorUtils.makePound(red, green, blue);
};


/**
 * Returns a contrasting text color for the specified background color.
 * @param {string} backgroundColor The background color.
 * @return {string} A constrasting color for use on text.
 */
dvt.ColorUtils.getContrastingTextColor = function(backgroundColor) {
  var r = dvt.ColorUtils.getRed(backgroundColor);
  var g = dvt.ColorUtils.getGreen(backgroundColor);
  var b = dvt.ColorUtils.getBlue(backgroundColor);
  var yiq = (r * 299 + g * 587 + b * 114) / 1000;
  return (yiq >= 128) ? '#000000' : '#FFFFFF';
};

/**
 * Process and fix color based on platform.
 * Color in #aarrggbb format is converted to rgba(r,g,b,a) representation
 * Batik doesn't support rgba, so splits the rgba color into rgb(r,g,b) color and alpha for Batik
 * @param {String}  color  The hex or RGB or RGBA representation of the color
 * @param {number}  alpha  The opacity
 * @return {object}  color object containing 'color' and 'alpha'
 */
dvt.ColorUtils.fixColorForPlatform = function(color, alpha) {
  if (!color)
    return null;
  if (color.charAt(0) == '#' && color.length > 8) {
    // #aarrggbb values shouldn't be sent to the DOM
    color = dvt.ColorUtils.getRGBA(color);
  }
  var colorObj = {};
  // rgba is not supported in batik environment.
  if (dvt.Agent.isEnvironmentBatik() && color.indexOf('rgba') !== - 1) {
    colorObj['color'] = dvt.ColorUtils.getRGB(color);

    // Apply alpha in rgba value as a multiplier to the alpha set on the object as this is what svg does.
    if (alpha != null)
      colorObj['alpha'] = dvt.ColorUtils.getAlpha(color) * alpha;
    else
      colorObj['alpha'] = dvt.ColorUtils.getAlpha(color);
  }
  else {
    colorObj['color'] = color;
    if (alpha != null)
      colorObj['alpha'] = alpha;
  }
  return colorObj;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.



/**
  *  @class dvt.ClipPath
  *  Defines a clipping region composed of the union of one or more outlines.
  *  @param {String} prefix  An optional prefix for the clip path id.
  *  @constructor
  */
dvt.ClipPath = function(prefix)
{
  /** Id of the clip path. @type {String}  */
  this._id = (prefix ? prefix + '$' : '') + 'cp' + dvt.ClipPath._uniqueSeed++;
  /** the clipping outline  @type {Object}  */
  this._regions = [];
};

dvt.Obj.createSubclass(dvt.ClipPath, dvt.Obj);

dvt.ClipPath._uniqueSeed = 0;

//  Clipping path outlines


/**  @final  @type {number}  */
dvt.ClipPath.NONE = 0;


/**  @final  @type {number}  */
dvt.ClipPath.RECT = 1;


/**  @final  @type {number}  */
dvt.ClipPath.PATH = 2;


/**  @final  @type {number}  */
dvt.ClipPath.POLYGON = 3;


/**  @final  @type {number}  */
dvt.ClipPath.ELLIPSE = 4;


/**  @final  @type {number}  */
dvt.ClipPath.CIRCLE = 5;


/**
  *   @private
  */
dvt.ClipPath.prototype._addRegion = function(obj)
{
  if (obj)
    this._regions.push(obj);
};


/**
  *   Returns the ID of the clip path
  *   @return {String}  The ID of the clip path
  */

dvt.ClipPath.prototype.getId = function()
{
  return this._id;
};

/**
 *   Returns a  clipping region outline object (by index).
 *   @type {Object}
 */

dvt.ClipPath.prototype.getRegions = function(idx)
{
  return this._regions;
};


/**
  *  Adds a rectangular clipping region to the clip path.
  *  @param {number}  x   The top left x position of the rectangular region.
  *  @param {number}  y   The top left y position of the rectangular region.
  *  @param {number}  w   The width of the rectangular region.
  *  @param {number}  h   The height of the rectangular region.
  *  @param {number}  rx  Optional x-axis radius of the ellipse used to round off the cornders of the rectangle.
  *  @param {number}  ry  Optional y-axis radius of the ellipse used to round off the cornders of the rectangle.
  */
dvt.ClipPath.prototype.addRect = function(x, y, w, h, rx, ry)
{
  var obj = {};
  obj.type = dvt.ClipPath.RECT;
  obj.x = x;
  obj.y = y;
  obj.w = w;
  obj.h = h;
  obj.rx = rx;
  obj.ry = ry;
  this._addRegion(obj);
};


/**
  *  Adds a circular clipping region to the clip path.
  *  @param {number}  cx  The x-axis coordinate of the center of the circle.
  *  @param {number}  cy  The y-axis coordinate of the center of the circle.
  *  @param {number}  r   The radius of the circle.
  */
dvt.ClipPath.prototype.addCircle = function(cx, cy, r)
{
  var obj = {};
  obj.type = dvt.ClipPath.CIRCLE;
  obj.cx = cx;
  obj.cy = cy;
  obj.r = r;
  this._addRegion(obj);
};


/**
  *  Adds an ellipse clipping region to the clip path.
  *  @param {number}  cx  The x-axis coordinate of the center of the circle.
  *  @param {number}  cy  The y-axis coordinate of the center of the circle.
  *  @param {number}  rx  The x-axis radius of the ellipse.
  *  @param {number}  ry  The y-axis radius of the ellipse.
  */
dvt.ClipPath.prototype.addEllipse = function(cx, cy, rx, ry)
{
  var obj = {};
  obj.type = dvt.ClipPath.ELLIPSE;
  obj.cx = cx;
  obj.cy = cy;
  obj.rx = rx;
  obj.ry = ry;
  this._addRegion(obj);
};


/**
  *  Adds a polygon clipping region to the clip path.
  *  @param {string}  points  The points that make up the polygon.
  */
dvt.ClipPath.prototype.addPolygon = function(points)
{
  var obj = {};
  obj.type = dvt.ClipPath.POLYGON;
  obj.points = points;
  this._addRegion(obj);
};


/**
  *  Adds a path clipping region to the clip path.
  *  @param {string}  d  Path data.
  */
dvt.ClipPath.prototype.addPath = function(d)
{
  var obj = {};
  obj.type = dvt.ClipPath.PATH;
  obj.d = d;
  this._addRegion(obj);
};
// Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 *  Defines a mask.
 *  @param {dvt.GradientFill} gradient The gradient to use for this mask
 *  @param {dvt.Rectangle} bounds The bounds of this mask
 *  @constructor
 */
dvt.Mask = function(gradient, bounds) {
  this._id = 'mask' + dvt.Mask._uniqueSeed++;
  this._gradient = gradient;
  this._bounds = bounds;
};

dvt.Obj.createSubclass(dvt.Mask, dvt.Obj);

/**
 * @private
 */
dvt.Mask._uniqueSeed = 0;

/**
 * Returns the ID of the mask
 * @return {String}
 */
dvt.Mask.prototype.getId = function() {
  return this._id;
};

/**
 * Returns the DvtGradient for this mask
 * @return {DvtGradient}
 */
dvt.Mask.prototype.getGradient = function() {
  return this._gradient;
};

/**
 * Returns the bounds of this mask
 * @return {dvt.Rectangle}
 */
dvt.Mask.prototype.getBounds = function() {
  return this._bounds;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*   dvt.Fill                                                               */
/*-------------------------------------------------------------------------*/
/**
  * A base class for shape fills. dvt.Fill is intended to be subclassed (e.g.
  * {@link dvt.SolidFill}).
  * @extends {DvtBaseDrawEffect}
  * @class dvt.Fill  is a base class for shape fill specifications.  dvt.Fill is intended to be subclassed (e.g.
  * {@link dvt.SolidFill}).
  * @constructor  Do not create/use directly.
  * @param {String} id  Optional ID for the object (see also {@link DvtBaseDrawEffect#setId}).
  */
dvt.Fill = function()
{
  this._Init();
};

dvt.Obj.createSubclass(dvt.Fill, DvtLockable);


//  Fill type definitions


/**   @final @type {number}  */
dvt.Fill.NONE = 0;


// No fill specified.
/**   @final @type {number}  */
dvt.Fill.COLOR = 1;


// Solid color fill.
/**   @final @type {number}  */
dvt.Fill.GRADIENT = 2;


// Gradient fill.
/**   @final @type {number}  */
dvt.Fill.PATTERN = 3;


// Pattern fill.
/**   @final @type {number}  */
dvt.Fill.IMAGE = 4;            // Image fill.


/**
 * @private
 */
dvt.Fill.prototype._Init = function() {
  dvt.Fill.superclass._Init.call(this);
};

// TODO  REMOVE get/setId if possible
/**
 *   Returns the id of this draw effect.
 *   @type {String}
 */
dvt.Fill.prototype.getId = function() {
  return this._id;
};


/**
 *   Sets the id of this fill.
 *   @param {String} id  The id for the fill.
 */
dvt.Fill.prototype.setId = function(id) {
  this._id = id;
};

/**
 * Returns true if this fill is identical to the specified fill.
 * @param {dvt.Fill} fill
 * @return {boolean}
 */
dvt.Fill.prototype.equals = function(fill) {
  return true; // subclasses should override
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * A shape fill class rendering a solid fill color.
  * @constructor
  * @param {String} fc  A css color specification for the fill color.
  * @param {String} fa  An optional alpha. Can be used to supplement the alpha specified by the fill color.  If omitted, the alpha specifed
  *                     by the fill color (or 1 if it does not specify an alpha) is used.
 */
dvt.SolidFill = function(fc, fa)
{
  this._Init(fc, fa);
};

dvt.Obj.createSubclass(dvt.SolidFill, dvt.Fill);

/**
 * Returns a copy of this object.
 * @return {dvt.SolidFill}
 */
dvt.SolidFill.prototype.clone = function()
{
  var o = new dvt.SolidFill();
  this.mergeProps(o);
  return o;
};


/**
 * Helper method to initialize this object.
  * @param {String} fc  A css color specification for the fill color.
  * @param {String} fa  An optional alpha. Can be used to supplement the alpha specified by the fill color.  If omitted, the alpha specifed
  *                     by the fill color (or 1 if it does not specify an alpha) is used.
 * @private
 */
dvt.SolidFill.prototype._Init = function(fc, fa)
{
  dvt.SolidFill.superclass._Init.call(this);
  this._fc = fc;
  this._fa = fa != null ? fa : 1;
};


/**
  *  Returns the fill's solid color (and alpha).
  *  @type {String}
  */
dvt.SolidFill.prototype.getColor = function()
{
  return this._fc;
};


/**
  *  Sets the fill color.
  *  @param  {String} fc  A color specification.
  *  e.g.  #123456, &nbsp; rgb(128,42,200), &nbsp; rgba(28, 128, 56, 0.7)
  *  &nbsp;or &nbsp;'green'&nbsp; or&nbsp; 'none'
  */
dvt.SolidFill.prototype.setColor = function(fc)
{
  if (! this.isLocked()) {
    this._fc = fc;
  }
};


/**
  *  Returns the fill's solid color alpha channel value in the range 0 (invisible) to 1 (opaque).
  *  @type {number}
  */
dvt.SolidFill.prototype.getAlpha = function()
{
  return this._fa;
};


/**
  *  Sets the fill alpha.
  *  @param {number} alpha  A value between 0 (invisible) and 1 (opaque).
  */
dvt.SolidFill.prototype.setAlpha = function(alpha)
{
  if (! this.isLocked()) {
    this._fa = alpha;
  }
};


/**
  *   Merges the fill properties in the current object into the supplied fill
  *   object.
  *   Used internally by clone().
  *   @private
  */
dvt.SolidFill.prototype.mergeProps = function(obj)
{
  dvt.SolidFill.superclass.mergeProps.call(this, obj);   // merge in subclass props

  obj._fc = this._fc;   // color
  obj._fa = this._fa;   // alpha
};


/**
 * Returns an instance of dvt.SolidFill that is invisible and can be used for event detection.
 * @return {dvt.SolidFill}
 */
dvt.SolidFill.invisibleFill = function() {
  if (!dvt.SolidFill._INVISIBLE_FILL)
    dvt.SolidFill._INVISIBLE_FILL = new dvt.SolidFill('rgba(0,0,0,0)');

  return dvt.SolidFill._INVISIBLE_FILL;
};

/**
 * @override
 */
dvt.SolidFill.prototype.equals = function(fill) {
  // TODO  fc should be converted so that equivalent colors via different syntax are treated correctly.
  if (fill instanceof dvt.SolidFill && fill._fc == this._fc && fill._fa == this._fa)
    return dvt.SolidFill.superclass.equals.call(this, fill);
  else
    return false;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*   dvt.Stroke                 Base stroke properties                      */
/*-------------------------------------------------------------------------*/
/**
  * An abstract base class representing stroke properties.
  * @class dvt.Stroke
  * @extends {dvt.Obj}
  * @constructor
  * @param {number} sw  The width of the stroke line.  If omitted, default is 1.
  * @param {String} id  Optional ID for the object (see also {@link DvtBaseDrawEffect#setId}).
  */
dvt.Stroke = function(sw, id)
{
  this._Init(sw, id);
};

dvt.Obj.createSubclass(dvt.Stroke, DvtLockable);


/**
  * Stroke Types
  */
dvt.Stroke.SOLID = 0;
dvt.Stroke.DASHED = 1;
dvt.Stroke.DOTTED = 2;
dvt.Stroke.DASHED_DOTTED = 3;


/**
  * Stroke joins
  */
dvt.Stroke.SQUARE = 'square';
dvt.Stroke.ROUND = 'round';
dvt.Stroke.BEVEL = 'bevel';
dvt.Stroke.MITER = 'miter';

/**
  * Stroke endings
  */
//DvtSTROKE.SQUARE  ;     // same as for join
//DvtSTROKE.ROUND   ;     //  ..   .  ..  ..
dvt.Stroke.BUTT = 'butt';


/**
 * Converts the specified stroke type string to its constant value.
 * @param {string} shape The stroke type.
 * @return {number} The corresponding constant value.
 */
dvt.Stroke.convertTypeString = function(type) {
  if (type == 'solid')
    return dvt.Stroke.SOLID;
  else if (type == 'dashed')
    return dvt.Stroke.DASHED;
  else if (type == 'dotted')
    return dvt.Stroke.DOTTED;
  else
    return dvt.Stroke.SOLID;
};


/*-------------------------------------------------------------------------*/
/*   _Init()                                                               */
/*-------------------------------------------------------------------------*/
/** @private */
dvt.Stroke.prototype._Init = function(sw)
{
  this._sw = ((sw === null || isNaN(sw)) ? 1 : sw);    // stroke_width

  dvt.Stroke.superclass._Init.call(this);
  this._bFixedWidth = false;
};


/**
 *   Returns the id of this draw effect.
 *   @type {String}
 */
dvt.Stroke.prototype.getId = function() {
  return this._id;
};


/**
 *   Sets the id of this fill.
 *   @param {String} id  The id for the fill.
 */
dvt.Stroke.prototype.setId = function(id) {
  this._id = id;
};


/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/

dvt.Stroke.prototype.mergeProps = function(to)
{
  to._sw = this._sw;      // stroke width
  to._st = this._st;      // stroke type (solid, dashed, etc)
  to._sd = this._sd;      // dash details
  to._sdo = this._sdo;      // dash offset
  to._sj = this._sj;      // line join style
  to._se = this._se;      // line ending style
  to._sm = this._sm;      // miter limit
  to._bFixedWidth = this._bFixedWidth;

  dvt.Stroke.superclass.mergeProps.call(this, to);
};


/*-------------------------------------------------------------------------*/
/*   setStyle()                                                            */
/*-------------------------------------------------------------------------*/
/**
  *  Sets the stroke style (e.g solid line, or intermittent line, and optionally
  *  the stroke join type and the line ending type). Null may be used to ignore
  *  any argument.
  *  <p>
  *  Dashed line examples :<br><br><code>
  *  // 3 pixel dash followed by a 3 pixel gap<br><br>
  *  obj.setStyle(dvt.Stroke.DASHED, "3");<br><br>
  *  // 5 pixel dash, 3 pixel gap, 9 pixel dash, 2 pixel gap.  The pattern then repeats
  *  to fill the line<br><br>
  *  obj.setStyle(dvt.Stroke.DASHED, "5,3,9,2");
  *
  *  @param {number} type  dvt.Stroke.SOLID or dvt.Stroke.DASHED.
  *  @param {String} dashsize  For dashed lines, specifies the dash and space size.
  *                            The string contains a list of numbers separated by commas
  *                            or whitespace, specifying dash length and gaps. The list
  *                            should have an even number of entries, but if an odd number
  *                            is used the list will be repeated so that the entry count is even.
  *  @param {String} join  Specifies the type of line join.  May be dvt.Stroke.SQUARE,
  *                        dvt.Stroke.ROUND, dvt.Stroke.BEVEL, or dvt.Stroke.MITER.
  *  @param {String} end   Specifies the type of line end.  May be DvtSTROKE.SQUARE,
  *                        DvtSTROKE.ROUND, or dvt.Stroke.BUTT.
  *  @param {number} miter miter limit when join is dvt.Stroke.MITER
  */
dvt.Stroke.prototype.setStyle = function(type, dashsize, join, end, miter)
{
  if (this.isLocked()) {
    return;
  }

  //  Line-type attributes

  if (type && !dashsize)
    dashsize = dvt.Stroke.getDefaultDash(type, this._sw);

  this._st = type;
  this._sd = dashsize;


  //  Line-joining attributes

  if (join) {
    this._sj = join;
  }

  //  Line-ending attributes

  if (end) {
    this._se = end;
  }

  //  miter limit attributes

  if (miter) {
    this._sm = miter;
  }

};


dvt.Stroke.prototype.getDash = function()
{
  return this._sd;
};

dvt.Stroke.prototype.getDashOffset = function()
{
  return this._sdo;
};


dvt.Stroke.prototype.getLineJoin = function()
{
  return this._sj;
};

dvt.Stroke.prototype.setLineJoin = function(join)
{
  if (! this.isLocked()) {
    this._sj = join;
  }
};

dvt.Stroke.prototype.getLineEnd = function()
{
  return this._se;
};

dvt.Stroke.prototype.setLineEnd = function(end)
{
  if (! this.isLocked()) {
    this._se = end;
  }
};

dvt.Stroke.prototype.getMiterLimit = function()
{
  return this._sm;
};

dvt.Stroke.prototype.setMiterLimit = function(limit)
{
  if (! this.isLocked()) {
    this._sm = limit;
  }
};


/*-------------------------------------------------------------------------*/
/*   get/setType()     Gets/Sets the type of stroke (e.g. solid or dashed  */
/*-------------------------------------------------------------------------*/

dvt.Stroke.prototype.getType = function()
{
  return this._st;
};


//  dash size is optional.  May also specify alternating sizes  e.g. "3, 5, 3"
/**
  *  Sets the type of the stroke.
  *  @param {number} type  The stroke type, such as {@link dvt.Stroke#DASHED}.
  *  @param {number} dashsize  Optional dash details if the stroke type is not {@link dvt.Stroke#SOLID}.
  *  @param {number} dashoffset  Optional dash offset if the stroke type is not {@link dvt.Stroke#SOLID}.
  */
dvt.Stroke.prototype.setType = function(type, dashsize, dashoffset)
{
  if (this.isLocked()) {
    return;
  }

  if (type === dvt.Stroke.SOLID) {
    dashsize = null;
    dashoffset = null;
  }
  else if (! dashsize) {
    dashsize = dvt.Stroke.getDefaultDash(type, this._sw);
  }

  this._st = type;
  this._sd = dashsize;
  this._sdo = dashoffset;

};


/*-------------------------------------------------------------------------*/
/*   get/setWidth()                                                        */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the stroke width.
  *  @type {number}
  */
dvt.Stroke.prototype.getWidth = function()
{
  return this._sw;
};


/**
  *  Sets the stroke width.
  *  @param {number} sw  The stroke width.
  */
dvt.Stroke.prototype.setWidth = function(sw)
{
  if (! this.isLocked()) {
    this._sw = sw;
  }
};

dvt.Stroke.prototype.setFixedWidth = function(bFixedWidth)
{
  this._bFixedWidth = bFixedWidth;
};

dvt.Stroke.prototype.isFixedWidth = function()
{
  return this._bFixedWidth;
};


/**
 * Gets a default dash size based on the stroke type and stroke width.
 * @return {string} dash size string, e.g. "6,3,4,3"
 */
dvt.Stroke.getDefaultDash = function(type, width) {
  width = Math.ceil(width);
  var dashSize = Math.max(6, width * 2); // dash is at least 6px
  var dotSize = Math.max(2, width); // dot is at least 2px
  var dashDotGap = Math.floor((dashSize + dotSize) / 2);

  if (type == dvt.Stroke.DASHED)
    return '' + dashSize;
  if (type == dvt.Stroke.DOTTED)
    return '' + dotSize;
  if (type == dvt.Stroke.DASHED_DOTTED)
    return '' + dashSize + ',' + dashDotGap + ',' + dotSize + ',' + dashDotGap;
  else
    return null;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    dvt.GradientStroke            Gradient stroke definition class          */
/*---------------------------------------------------------------------------*/
/*  Can be used to share a gradient definition among several shapes, or as a */
/*  convenience to maintain a gradient definition separately from a shape.   */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a gradient specification (shareable by other shapes).
  *   @extends {dvt.Stroke}
  *   @class
  *   @constructor
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arAlphas  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  *   @param {number} sw       Stroke width
  *   @param {String} id
  */
dvt.GradientStroke = function(arColors, arAlphas, arStops, arBounds, sw, id)
{
  this._Init(arColors, arAlphas, arStops, arBounds, sw, id);
};


dvt.Obj.createSubclass(dvt.GradientStroke, dvt.Stroke);


/**
 * Return the first alpha in the alphas array
 *
 * @return {number}
 */
dvt.GradientStroke.prototype.getAlpha = function()
{
  return 1;
};


/**
  *   Returns an array of alpha's.
  *   @type {Array}
  */
dvt.GradientStroke.prototype.getAlphas = function()
{
  return this._arAlphas;
};


/**
  *   Returns the bounding box for the gradient as an array (x, y, w, h).
  *   @type {Array}
  */
dvt.GradientStroke.prototype.getBounds = function()
{
  return this._arBounds;
};


/**
  *   Returns an array of colors.
  *   @type {Array}
  */
dvt.GradientStroke.prototype.getColors = function()
{
  return this._arColors;
};


/**
  *   Returns an array of stop ratios.
  *   @type {Array}
  */
dvt.GradientStroke.prototype.getStops = function()
{
  return this._arStops;
};


/*---------------------------------------------------------------------------*/
/*    _Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
dvt.GradientStroke.prototype._Init = function(arColors, arAlphas, arStops, arBounds, sw, id)
{
  dvt.GradientStroke.superclass._Init.call(this, sw, id);

  this._arColors = arColors;
  this._arBounds = arBounds;

  var len = 0;
  if (arColors) {
    len = arColors.length - 1;
  }

  if (! arAlphas) {
    arAlphas = dvt.GradientStroke.createDefaultAlphas(len);
  }
  this._arAlphas = arAlphas;

  if (! arStops) {     // if no stops, generate default stops
    // for a uniform distribution of colors.
    arStops = dvt.GradientStroke.createDefaultStops(len);
  }

  this._arStops = arStops;
};


/**
 * @param {number} size
 * @return {Array} An array with size number of elements, with each element equal to 1, or null if size
 *                  is less than 0.
 */
dvt.GradientStroke.createDefaultAlphas = function(size)
{
  if (size < 0)
    return null;

  var arAlphas = [];
  for (var i = 0; i < size; i++)
  {
    arAlphas.push(1);
  }
  return arAlphas;
};


/**
 * Creates a uniformly distributed range of gradient stops
 *
 * @param {number} numStops
 * @return {Array}
 */
dvt.GradientStroke.createDefaultStops = function(numStops)
    {
  var arStops = [];
  var incr = 1 / numStops;
  var curStop = 0;

  do {
    arStops.push(curStop);
    curStop += incr;
  } while (--numStops > 0);
  arStops.push(1);

  return arStops;
};


/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the gradient properties in the current object into the supplied gradient object.
  *   Used internally by clone().
  *   @private
  */
dvt.GradientStroke.prototype.mergeProps = function(obj)
{
  obj._arColors = this._arColors;
  obj._arStops = this._arStops;
  obj._arAlphas = this._arAlphas;
  obj._arBounds = this._arBounds;

  dvt.GradientStroke.superclass.mergeProps.call(this, obj);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    dvt.LinearGradientStroke       Linear Gradient stroke class             */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a linear gradient stroke.
  *   @extends {dvt.GradientStroke}
  *   @class
  *   <p>
  *   <b>Example usage:</b><br><br><code>
  *
  *   //  Fill rectangle with a left-to-right gradient of red through blue to green.<br>
  *   //  The colors are evenly graduated because the stop values have been omitted.<br><br>
  *   rect.setStroke(<b>new dvt.LinearGradientStroke(0, ['red', 'green, 'blue']</b>) ;<br><br>
  *
  *   //  Fill rectangle with a north-east direction gradient of red to green
  *   with an unequal gradient distribution of colors.<br><br>
  *   rect.setStroke(<b>new dvt.LinearGradientStroke(45, ['red', 'green], [0, 0.75,1]</b>) ;<br><br>

  *   @constructor
  *   @param {number} angle  Specifies the direction of the gradient as an
  *                          angle in degrees (using the standard anti-clockwise convention
  *                           for positive angles, i.e. 0 = horizontal and 90 = vertically up, etc).
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arColors  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  *   @param {number} sw    An optional number for stroke width.
  *   @param {String} id
  */
dvt.LinearGradientStroke = function(angle, arColors, arAlphas, arStops, arBounds, sw, id)
{
  this._Init(angle, arColors, arAlphas, arStops, arBounds, sw, id);
};

dvt.Obj.createSubclass(dvt.LinearGradientStroke, dvt.GradientStroke);


/*---------------------------------------------------------------------------*/
/*    clone()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns an (unlocked) copy of this object.
  *  @type {dvt.LinearGradientStroke}
  */
dvt.LinearGradientStroke.prototype.clone = function()
{
  var o = new dvt.LinearGradientStroke();

  this.mergeProps(o);    // merge properties into cloned obj.
  return o;
};


/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
dvt.LinearGradientStroke.prototype._Init = function(angle, arColors, arAlphas, arStops, arBounds, sw, id)
{
  dvt.LinearGradientStroke.superclass._Init.call(this, arColors, arAlphas, arStops, arBounds, sw, id);

  this._angle = ((angle === null || isNaN(angle)) ? 0 : angle);
};


/*---------------------------------------------------------------------------*/
/*   getAngle()    Returns the gradient angle property for linear gradients  */
/*                 see also setAngle().                                      */
/*---------------------------------------------------------------------------*/
/**
  *  Gets the angle of the gradient in degrees.
  *  @type {number}
  *  @return The angle of the gradient in degrees.  The zero degree direction is
  *  left-to-right (due east). Positive angles rotate anti-clockwise, and negative
  *  angles rotate clockwise.
  */
dvt.LinearGradientStroke.prototype.getAngle = function()
{
  return this._angle;
};


/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the linear gradient properties in the current object into the
  *   dvt.LinearGradientStroke object.
  *   Used internally by clone().
  *   @private
  */
dvt.LinearGradientStroke.prototype.mergeProps = function(obj)
{
  dvt.LinearGradientStroke.superclass.mergeProps.call(this, obj);

  obj._angle = this._angle;      // gradient angle
};



/*---------------------------------------------------------------------------*/
/*   setAngle()         Set the gradient angle for linear gradients          */
/*---------------------------------------------------------------------------*/
//  Be default, the gradient angle is zero (due east).  Angles greater
// than zero rotate anti-clockwise.  Angles less than zero rotate clockwise.


/**
  * Sets the angle of the gradient in degrees.  The zero degree direction is
  * left-to-right (due east). Positive angles rotate anti-clockwise, and negative
  * angles rotate clockwise.
  * @param {number} The gradient direction in degrees.
  */
dvt.LinearGradientStroke.prototype.setAngle = function(degrees)
{
  if (this.isLocked()) {
    return;
  }

  if (degrees !== 0) {
    if (Math.abs(degrees) > 360) {
      degrees %= 360;
    }
    this._angle = degrees;
  }
};

// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * A class representing the stroke properties for a solid line.
  * @param {String} sc  A css color specification for the stroke color.
  * @param {String} sa  An optional alpha. Can be used to supplement the alpha specified by the stroke color.
  *                     If omitted, the alpha specifed by the stroke color (or 1 if it does not specify an alpha) is used.
  * @param {number} sw  The width of the stroke line.  If omitted, the default width is 1.
  */
dvt.SolidStroke = function(sc, sa, sw)
{
  this._Init(sc, sa, sw);
};

dvt.Obj.createSubclass(dvt.SolidStroke, dvt.Stroke);


/**
  *  Returns an (unlocked) copy of this stroke object.
  *  @type {dvt.SolidStroke}
  */
dvt.SolidStroke.prototype.clone = function()
{
  var o = new dvt.SolidStroke();

  this.mergeProps(o);    // merge properties into cloned obj.
  return o;
};


/**
 * Helper method to initialize this object.
  * @param {String} sc  A css color specification for the stroke color.
  * @param {String} sa  An optional alpha. Can be used to supplement the alpha specified by the stroke color.
  *                     If omitted, the alpha specifed by the stroke color (or 1 if it does not specify an alpha) is used.
  * @param {number} sw  The width of the stroke line.  If omitted, the default width is 1.
 * @private
 */
dvt.SolidStroke.prototype._Init = function(sc, sa, sw)
{
  this._sc = sc;
  this._sa = sa != null ? sa : 1;
  this._st = dvt.Stroke.SOLID;
  dvt.SolidStroke.superclass._Init.call(this, sw);
};


/**
  *  Returns the stroke alpha as a value between 0 (invisible) and 1 (opaque).
  *  @type {number}
  */
dvt.SolidStroke.prototype.getAlpha = function()
{
  return this._sa;
};


/**
  *  Sets the stroke alpha.
  *  @param {number} alpha  A value between 0 (invisible) and 1 (opaque).
  */
dvt.SolidStroke.prototype.setAlpha = function(alpha)
{
  if (! this.bLocked)
    this._sa = alpha;
};


/**
  *  Returns the stroke color.
  *  @type {String}
  */
dvt.SolidStroke.prototype.getColor = function()
{
  return this._sc;
};


/**
  *  Sets the stroke color.
  *  @param {String}  sc  A css color specification. e.g.  '#123456',  'rgb(128,42,200)',
  *                       rgba(128,42,200,0.8), or 'green'
  */
dvt.SolidStroke.prototype.setColor = function(sc)
{
  if (! this.bLocked)
    this._sc = sc;
};


/**
  *   Merges the stroke properties in the current object into the supplied
  *   stroke object.
  *   Used internally by clone().
  *   @private
  */
dvt.SolidStroke.prototype.mergeProps = function(obj)
{
  dvt.SolidStroke.superclass.mergeProps.call(this, obj);   // merge in the subclass's props

  obj._sc = this._sc;      // stroke color
  obj._sa = this._sa;      // stroke alpha
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*   dvt.Shadow                     Base drop shadow                        */
/*-------------------------------------------------------------------------*/
/**
  * @class dvt.Shadow
  * Represents a drop shadow.  The shadow object properties are a superset of values, and
  *                            each platform implementation should take those required
  *                            by that specfic platform.
  *
  * @constructor
  * @param {number} sw  The width of the stroke line.  If omitted, default is 1.
  * @param {String} id  Optional ID for the object (see also {@link DvtBaseDrawEffect#setId}).
  * @param {String} rgba  The color and transparency of the shadow.  Default is      0x59333333.
  * @param {number} distance The offset distance for the shadow, in pixels.   Default is 4.
  * @param {number} strength  The strength of the imprint or spread. Default is 1.
  *                           Note: The higher the value, the more color is imprinted and the
  *                           stronger the contrast between the shadow and the background.
  *                           Valid values are from 0 to 255.0
  * @param {number} angle  The angle of the shadow. Valid values are 0.0 to 360.0 degrees.  Default is 45 deg.
  * @param {number} blurX  The amount of horizontal blur. Valid values are 0.0 to 255.0  Default is 4.
  * @param {number} blurY  The amount of vertical blur (float). Valid values are 0.0 to 255.0  Default is 4.
  * @param {number} quality  An integer number of times to apply the effect. Valid values are 0
  *                          to 15.  Default is 1.  Note: shadows with lower values are rendered
  *                          more quickly. For most applications, a quality value of 1 (low), 2
  *                          (medium), or 3 (high) is sufficient.  Although you can use additional
  *                          numeric values up to 15 to achieve different effects, higher values
  *                          are rendered more slowly. Instead of increasing the value of quality,
  *                          you can often get a similar effect, and with faster rendering, by
  *                          simply increasing the values of the blurX and blurY properties.
  * @param {Boolean} inner  A boolean value indicating whether or not the shadow is an inner shadow.
  *                         A true value specifies an inner shadow. False specifies an outer shadow
  *                         (a shadow around the outer edges of the object).
  * @param {Boolean} knockout  Applies a knockout effect if true which effectively makes the object's
  *                         fill transparent, and reveals the background color of the document.
  * @param {Boolean} hide   A value indicating whether or not the object is hidden. A true value
  *                         indicates that the object itself is not drawn; only the shadow is visible.
  *                         If false, the object is shown.
  *
  */
dvt.Shadow = function(rgba, distance, blurX, blurY, angle, strength,
    quality,inner,knockout,hide)

{
  this._Init(rgba, distance, blurX, blurY, angle, strength, quality, inner, knockout, hide);
};


dvt.Obj.createSubclass(dvt.Shadow, DvtBaseDrawEffect);


dvt.Shadow._uniqueId = 1;


/*-------------------------------------------------------------------------*/
/*   _Init()                                                               */
/*-------------------------------------------------------------------------*/
/** @private */
dvt.Shadow.prototype._Init = function(rgba, distance, blurX, blurY, angle, strength,
                                     quality,inner,knockout,hide)
{
  dvt.Shadow.superclass._Init.call(this);

  // The type of this draw effect, used in Flash to differentiate between filter effects
  this.__type = 'shadow';

  this._rgba = (rgba ? rgba : 'rgba(48,48,48,0.35)');
  this._distance = ((distance === null || isNaN(distance)) ? 4 : distance);

  this._strength = ((strength === null || isNaN(strength)) ? 1 : strength);
  this._blurX = ((blurX === null || isNaN(blurX)) ? 4 : blurX);
  this._blurY = ((blurY === null || isNaN(blurY)) ? 4 : blurY);
  this._angle = ((angle === null || isNaN(angle)) ? 45 : angle);
  this._quality = ((quality === null || isNaN(quality)) ? 1 : quality);
  this._bInner = (inner ? true : false);
  this._bKnockout = false;
  this._bHide = false;
  this._Id = 'ds' + dvt.Shadow._uniqueId++;
};


/**
  *  Returns an (unlocked) copy of this object.
  *  @type {dvt.Shadow}
  */
dvt.Shadow.prototype.clone = function()
{
  var o = new dvt.Shadow();

  this.mergeProps(o);    // merge properties into cloned obj.

  return o;
};


/**
  *   Merges the fill properties in the current object into the supplied fill
  *   object.
  *   Used internally by clone().
  *   @private
  */
dvt.Shadow.prototype.mergeProps = function(obj)
{
  dvt.Shadow.superclass.mergeProps.call(this, obj);   // merge in subclass props

  obj._rgba = this._rgba;
  obj._distance = this._distance;
  obj._strength = this._strength;
  obj._blurX = this._blurX;
  obj._blurY = this._blurY;
  obj._angle = this._angle;
  obj._quality = this._quality;
  obj._bInner = this._bInner;
  obj._bKnockout = this._bKnockout;
  obj._bHide = this._bHide;
  obj._Id = this._Id;
};


// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    dvt.GradientFill            Gradient fill definition class              */
/*---------------------------------------------------------------------------*/
/*  Can be used to share a gradient definition among several shapes, or as a */
/*  convenience to maintain a gradient definition separately from a shape.   */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a gradient specification (shareable by other shapes).
  *   @extends {dvt.Fill}
  *   @class
  *   @constructor
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arColors  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  */
dvt.GradientFill = function(arColors, arAlphas, arStops, arBounds)
{
  this._Init(arColors, arAlphas, arStops, arBounds);
};


dvt.Obj.createSubclass(dvt.GradientFill, dvt.Fill);


/**
  *   Returns an array of alpha's.
  *   @type {Array}
  */
dvt.GradientFill.prototype.getAlphas = function()
{
  return this._arAlphas;
};


/**
  *   Returns the bounding box for the gradient as an array (x, y, w, h).
  *   @type {Array}
  */
dvt.GradientFill.prototype.getBounds = function()
{
  return this._arBounds;
};


/**
  *   Returns an array of colors.
  *   @type {Array}
  */
dvt.GradientFill.prototype.getColors = function()
{
  return this._arColors;
};


/**
  *   Returns an array of stop ratios.
  *   @type {Array}
  */
dvt.GradientFill.prototype.getStops = function()
{
  return this._arStops;
};


/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
dvt.GradientFill.prototype._Init = function(arColors, arAlphas, arStops, arBounds)
{
  dvt.GradientFill.superclass._Init.call(this);

  this._arColors = arColors;
  this._arBounds = arBounds;

  if (! arAlphas) {
    arAlphas = [];
    if (arColors) {
      for (var i = 0; i < arColors.length; i++) {
        arAlphas.push(1);
      }
    }
  }
  this._arAlphas = arAlphas;

  var len = arColors ? arColors.length - 1 : 0;
  if (! arStops) {     // if no stops, generate default stops
    // for a uniform distribution of colors.
    arStops = [];
    var incr = (len > 0) ? 1 / len : 0;
    var curStop = 0;

    do {
      arStops.push(curStop);
      curStop += incr;
    } while (--len > 0);
    arStops.push(1);
  }

  this._arStops = arStops;
};


/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the gradient properties in the current object into the supplied gradient object.
  *   Used internally by clone().
  *   @private
  */
dvt.GradientFill.prototype.mergeProps = function(obj)
{
  obj._arColors = this._arColors;
  obj._arStops = this._arStops;
  obj._arAlphas = this._arAlphas;
  obj._arBounds = this._arBounds;

  dvt.GradientFill.superclass.mergeProps.call(this, obj);
};

/**
 * @override
 */
dvt.GradientFill.prototype.equals = function(fill) {
  if (fill instanceof dvt.GradientFill && dvt.ArrayUtils.equals(this._arColors, fill._arColors) &&
      dvt.ArrayUtils.equals(this._arStops, fill._arStops) && dvt.ArrayUtils.equals(this._arAlphas, fill._arAlphas) &&
      dvt.ArrayUtils.equals(this._arBounds, fill._arBounds))
    return dvt.GradientFill.superclass.equals.call(this, fill);
  else
    return false;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    dvt.LinearGradientFill       Linear Gradient fill class                     */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a linear gradient fill.
  *   @extends {dvt.GradientFill}
  *   @class
  *   <p>
  *   <b>Example usage:</b><br><br><code>
  *
  *   //  Fill rectangle with a left-to-right gradient of red through blue to green.<br>
  *   //  The colors are evenly graduated because the stop values have been omitted.<br><br>
  *   rect.setFill(<b>new dvt.LinearGradientFill(0, ['red', 'green, 'blue']</b>) ;<br><br>
  *
  *   //  Fill rectangle with a north-east direction gradient of red to green
  *   with an unequal gradient distribution of colors.<br><br>
  *   rect.setFill(<b>new dvt.LinearGradientFill(45, ['red', 'green], [0, 0.75,1]</b>) ;<br><br>

  *   @constructor
  *   @param {number} angle  Specifies the direction of the gradient as an
  *                          angle in degrees (using the standard anti-clockwise convention
  *                           for positive angles, i.e. 0 = horizontal and 90 = vertically up, etc).
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arColors  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  */
dvt.LinearGradientFill = function(angle, arColors, arAlphas, arStops, arBounds)
{
  this._Init(angle, arColors, arAlphas, arStops, arBounds);
};

dvt.Obj.createSubclass(dvt.LinearGradientFill, dvt.GradientFill);


/*---------------------------------------------------------------------------*/
/*    clone()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns an (unlocked) copy of this object.
  *  @type {dvt.LinearGradientFill}
  */
dvt.LinearGradientFill.prototype.clone = function()
{
  var o = new dvt.LinearGradientFill();

  this.mergeProps(o);    // merge properties into cloned obj.
  return o;
};


/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
dvt.LinearGradientFill.prototype._Init = function(angle, arColors, arAlphas, arStops, arBounds)
{
  dvt.LinearGradientFill.superclass._Init.call(this, arColors, arAlphas, arStops, arBounds);

  this._angle = ((angle === null || isNaN(angle)) ? 0 : angle);
};


/*---------------------------------------------------------------------------*/
/*   getAngle()    Returns the gradient angle property for linear gradients  */
/*                 see also setAngle().                                      */
/*---------------------------------------------------------------------------*/
/**
  *  Gets the angle of the gradient in degrees.
  *  @type {number}
  *  @return The angle of the gradient in degrees.  The zero degree direction is
  *  left-to-right (due east). Positive angles rotate anti-clockwise, and negative
  *  angles rotate clockwise.
  */
dvt.LinearGradientFill.prototype.getAngle = function()
{
  return this._angle;
};

/**
 * Returns a copy of this object.
 * @return {dvt.LinearGradientFill}
 */
dvt.LinearGradientFill.prototype.clone = function()
{
  var o = new dvt.LinearGradientFill();
  this.mergeProps(o);
  return o;
};

/**
  *   Merges the linear gradient properties in the current object into the
  *   dvt.LinearGradientFill object.
  *   Used internally by clone().
  *   @private
  */
dvt.LinearGradientFill.prototype.mergeProps = function(obj)
{
  dvt.LinearGradientFill.superclass.mergeProps.call(this, obj);

  obj._angle = this._angle;      // gradient angle
};



/*---------------------------------------------------------------------------*/
/*   setAngle()         Set the gradient angle for linear gradients          */
/*---------------------------------------------------------------------------*/
//  Be default, the gradient angle is zero (due east).  Angles greater
// than zero rotate anti-clockwise.  Angles less than zero rotate clockwise.


/**
  * Sets the angle of the gradient in degrees.  The zero degree direction is
  * left-to-right (due east). Positive angles rotate anti-clockwise, and negative
  * angles rotate clockwise.
  * @param {number} The gradient direction in degrees.
  */
dvt.LinearGradientFill.prototype.setAngle = function(degrees)
{
  if (this.isLocked()) {
    return;
  }

  if (degrees !== 0) {
    if (Math.abs(degrees) > 360) {
      degrees %= 360;
    }
    this._angle = degrees;
  }
};

/**
 * @override
 */
dvt.LinearGradientFill.prototype.equals = function(fill) {
  if (fill instanceof dvt.LinearGradientFill && fill._angle == this._angle)
    return dvt.LinearGradientFill.superclass.equals.call(this, fill);
  else
    return false;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    dvt.ImageFill            Image fill definition class                    */
/*---------------------------------------------------------------------------*/
/*  Can be used to share an image fill definition among several shapes, or   */
/*  as a convenience to maintain an image fill definition separately from a  */
/*  shape.                                                                   */
/*---------------------------------------------------------------------------*/
/**
  *   Creates an image fill specification (shareable by other shapes).
  *   @extends {dvt.Fill}
  *   @class
  *   @constructor
  *   @param {String} src  image source
  *   @param {dimension} bound  bounding box (x, y, w, h).
  *   @param {String} repeat  specify how background image is repeated.
  *                           valid values: repeat-x, repeat-y, repeat, no-repeat
  */
dvt.ImageFill = function(src, bound, repeat)
{
  this._Init(src, bound, repeat);
};


dvt.Obj.createSubclass(dvt.ImageFill, dvt.Fill);


/**
  *   Returns the bounding box for the image fill as (x, y, w, h).
  *   @type {(x, y, w, h)}
  */
dvt.ImageFill.prototype.getBound = function()
{
  return this._bound;
};


/**
  *   Returns the image source
  *   @type {String}
  */
dvt.ImageFill.prototype.getSrc = function()
{
  return this._src;
};


/**
  *   Returns how the image is repeated
  *   @type {String}
  */
dvt.ImageFill.prototype.getRepeat = function()
{
  return this._repeat;
};


/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
dvt.ImageFill.prototype._Init = function(src, bound, repeat)
{
  dvt.ImageFill.superclass._Init.call(this);

  this._src = src;
  this._bound = bound;
  this._repeat = repeat;

};


/**
 * Returns a copy of this object.
 * @return {dvt.ImageFill}
 */
dvt.ImageFill.prototype.clone = function()
{
  var o = new dvt.ImageFill();
  this.mergeProps(o);
  return o;
};

/**
  *   Merges the image fill properties in the current object into the
  *   supplied image fill object.
  *   Used internally by clone().
  *   @private
  */
dvt.ImageFill.prototype.mergeProps = function(obj)
{
  obj._src = this._src;
  obj._bound = this._bound;
  obj._repeat = this._repeat;

  dvt.ImageFill.superclass.mergeProps.call(this);
};

/**
 * @override
 */
dvt.ImageFill.prototype.equals = function(fill) {
  if (fill instanceof dvt.ImageFill && fill._src == this._src && fill._repeat == this._repeat) {
    if (this._bound && fill._bound && this._bound.x == fill.bound.x && this._bound.y == fill.bound.y &&
        this._bound.w == fill.bound.w && this._bound.h == fill.bound.h)
      return dvt.ImageFill.superclass.equals.call(this, fill);
    else if (!this._bound && !fill._bound)
      return dvt.ImageFill.superclass.equals.call(this, fill);
  }

  return false;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    dvt.PatternFill            Pattern definition class                     */
/*---------------------------------------------------------------------------*/
/*  Can be used to share a pattern definition among several shapes, or as a  */
/*  convenience to maintain a pattern definition separately from a shape.    */
/*---------------------------------------------------------------------------*/
/**
 *   Creates a pattern specification (shareable by other shapes).
 *   @extends {dvt.Fill}
 *   @class
 *   @constructor
 *   @param {String} pattern  constant for the type of pattern
 *   @param {String} fillColor  color of the pattern
 *   @param {String} backgroundColor  background color of the pattern
 */
dvt.PatternFill = function(pattern, fillColor, backgroundColor)
{
  this.Init(pattern, fillColor, backgroundColor);
};


dvt.Obj.createSubclass(dvt.PatternFill, dvt.Fill);


/**   @final @type {String}  */
dvt.PatternFill.SM_DIAG_UP_LT = 'sDUL';


/**   @final @type {String}  */
dvt.PatternFill.LG_DIAG_UP_LT = 'lDUL';


/**   @final @type {String}  */
dvt.PatternFill.SM_DIAG_UP_RT = 'sDUR';


/**   @final @type {String}  */
dvt.PatternFill.LG_DIAG_UP_RT = 'lDUR';


/**   @final @type {String}  */
dvt.PatternFill.SM_CROSSHATCH = 'sC';


/**   @final @type {String}  */
dvt.PatternFill.LG_CROSSHATCH = 'lC';


/**   @final @type {String}  */
dvt.PatternFill.SM_CHECK = 'sCh';


/**   @final @type {String}  */
dvt.PatternFill.LG_CHECK = 'lCh';


/**   @final @type {String}  */
dvt.PatternFill.SM_TRIANGLE_CHECK = 'sTCh';


/**   @final @type {String}  */
dvt.PatternFill.LG_TRIANGLE_CHECK = 'lTCh';


/**   @final @type {String}  */
dvt.PatternFill.SM_DIAMOND_CHECK = 'sDCh';


/**   @final @type {String}  */
dvt.PatternFill.LG_DIAMOND_CHECK = 'lDCh';


/**
 *  @protected
 */
dvt.PatternFill.prototype.Init = function(pattern, fillColor, backgroundColor)
{
  dvt.PatternFill.superclass._Init.call(this);

  this._pattern = (pattern ? dvt.PatternFill._convertPatternValue(pattern) : dvt.PatternFill.SM_DIAG_UP_LT);
  this._fillColor = (fillColor ? fillColor : '#000000');
  this._backgroundColor = (backgroundColor ? backgroundColor : '#ffffff');
};


/**
 *   Returns the type of pattern
 *   @type {String}
 */
dvt.PatternFill.prototype.getPattern = function()
{
  return this._pattern;
};


/**
 *   Returns the color of the pattern
 *   @type {String}
 */
dvt.PatternFill.prototype.getColor = function()
{
  return this._fillColor;
};


/**
 *   Returns the background color of the pattern
 *   @type {String}
 */
dvt.PatternFill.prototype.getBackgroundColor = function()
{
  return this._backgroundColor;
};

/**
 * Returns a copy of this object.
 * @return {dvt.PatternFill}
 */
dvt.PatternFill.prototype.clone = function()
{
  var o = new dvt.PatternFill();
  this.mergeProps(o);
  return o;
};


/**
 *   Merges the pattern properties in the current object into the supplied
 *   pattern object.
 *   Used internally by clone().
 *   @private
 */
dvt.PatternFill.prototype.mergeProps = function(obj)
{
  obj._pattern = this._pattern;
  obj._fillColor = this._fillColor;
  obj._backgroundColor = this._backgroundColor;

  dvt.PatternFill.superclass.mergeProps.call(this);
};

/**
 * @override
 */
dvt.PatternFill.prototype.equals = function(fill) {
  if (fill instanceof dvt.PatternFill && fill._pattern == this._pattern && fill._fillColor == this._fillColor &&
      fill._backgroundColor == this._backgroundColor)
    return dvt.PatternFill.superclass.equals.call(this, fill);
  else
    return false;
};

/**
 * Return the transformation matrix applied to this container.
 *  @type {dvt.Matrix}
 *  @return transformation matrix
 */
dvt.PatternFill.prototype.getMatrix = function() {
  if (this._matrix)
    return this._matrix;

  return new dvt.Matrix();
};


/**
 * Set the transformation matrix to apply to this container.
 *  When set, the matrix is locked so that it becomes immutable.
 *  To make changes, clone the matrix, apply changes to it, and then
 *  set the matrix again.
 *  @param {dvt.Matrix} mat   The transformation matrix to apply.
 */
dvt.PatternFill.prototype.setMatrix = function(mat) {
  this._matrix = mat;

  // Lock the new matrix if it isn't already locked.
  // The same matrix can be set on more than one object irregardless of locking.
  if (this._matrix && !this._matrix.isLocked())
    this._matrix.__lock();


};


/**
 * Returns the pattern constant given the API string name for the pattern.  Returns the unmodified string if the value
 * is already a predefined constant or if it's not recognized.
 * @return {string}
 * @private
 */
dvt.PatternFill._convertPatternValue = function(patternStr) {
  if (patternStr == 'smallDiagonalLeft')
    return dvt.PatternFill.SM_DIAG_UP_LT;
  else if (patternStr == 'largeDiagonalLeft')
    return dvt.PatternFill.LG_DIAG_UP_LT;
  else if (patternStr == 'smallDiagonalRight')
    return dvt.PatternFill.SM_DIAG_UP_RT;
  else if (patternStr == 'largeDiagonalRight')
    return dvt.PatternFill.LG_DIAG_UP_RT;
  else if (patternStr == 'smallCrosshatch')
    return dvt.PatternFill.SM_CROSSHATCH;
  else if (patternStr == 'largeCrosshatch')
    return dvt.PatternFill.LG_CROSSHATCH;
  else if (patternStr == 'smallChecker')
    return dvt.PatternFill.SM_CHECK;
  else if (patternStr == 'largeChecker')
    return dvt.PatternFill.LG_CHECK;
  else if (patternStr == 'smallTriangle')
    return dvt.PatternFill.SM_TRIANGLE_CHECK;
  else if (patternStr == 'largeTriangle')
    return dvt.PatternFill.LG_TRIANGLE_CHECK;
  else if (patternStr == 'smallDiamond')
    return dvt.PatternFill.SM_DIAMOND_CHECK;
  else if (patternStr == 'largeDiamond')
    return dvt.PatternFill.LG_DIAMOND_CHECK;
  else
    return patternStr;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    dvt.RadialGradientFill       Radial Gradient fill class                 */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a radial gradient specification (shareable by other shapes).
  *   @extends {dvt.GradientFill}
  *   @class
  *   <p>
  *   <b>Example usage:</b><br><br><code>
  *
  *   //  Fill a circle with a radial gradient of red to green.<br><br>
  *   circle.setFill(<b>new dvt.RadialGradientFill(0, ['red', 'green]</b>) ;<br><br>
  *
  *   //  Fill rectangle with a north-east direction gradient of red to green
  *   with an unequal gradient distribution of colors.<br><br>
  *   rect.setFill(<b>new dvt.RadialGradientFill(45, ['red', 'green], [0, 0.75,1]</b>) ;<br><br>

  *   @constructor
  *   @param {number} radius
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arAlphas  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Number} cx       the radial gradient center x position.
  *   @param {Number} cy       the radial gradient center y position.
  *   @param {Number} r        the radius of the radial gradient.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  */
dvt.RadialGradientFill = function(arColors, arAlphas, arStops, cx, cy, r, arBounds)
{
  this._Init(arColors, arAlphas, arStops, cx, cy, r, arBounds);
};

dvt.Obj.createSubclass(dvt.RadialGradientFill, dvt.GradientFill);


/*---------------------------------------------------------------------------*/
/*    clone()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns an (unlocked) copy of this object.
  *  @type {dvt.RadialGradientFill}
  */
dvt.RadialGradientFill.prototype.clone = function()
{
  var o = new dvt.RadialGradientFill();

  this.mergeProps(o);    // merge properties into cloned obj.

  return o;
};


/*---------------------------------------------------------------------------*/
/*    getRadius()                                                            */
/*---------------------------------------------------------------------------*/
/**
  *  Returns the radial-gradient radius.
  *  @type {number}
  */
dvt.RadialGradientFill.prototype.getRadius = function()
{
  return this._r;
};


/*---------------------------------------------------------------------------*/
/*    getCx()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns the radial-gradient center x coordinate.
  *  @type {number}
  */
dvt.RadialGradientFill.prototype.getCx = function()
{
  return this._cx;
};


/*---------------------------------------------------------------------------*/
/*    getCy()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns the radial-gradient center y coordinate.
  *  @type {number}
  */
dvt.RadialGradientFill.prototype.getCy = function()
{
  return this._cy;
};


/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
dvt.RadialGradientFill.prototype._Init = function(arColors, arAlphas, arStops, cx, cy, r, arBounds)
{
  dvt.RadialGradientFill.superclass._Init.call(this, arColors, arAlphas, arStops, arBounds);

  this._cx = cx;
  this._cy = cy;
  this._r = r;


};

/**
 * Returns a copy of this object.
 * @return {dvt.RadialGradientFill}
 */
dvt.RadialGradientFill.prototype.clone = function()
{
  var o = new dvt.RadialGradientFill();
  this.mergeProps(o);
  return o;
};

/**
  *   Merges the radial gradient properties in the current object into the
  *   supplied dvt.RadialGradientFill object.
  *   Used internally by clone().
  *   @private
  */
dvt.RadialGradientFill.prototype.mergeProps = function(obj)
{
  dvt.RadialGradientFill.superclass.mergeProps.call(this, obj);

  obj._cx = this._cx;
  obj._cy = this._cy;
  obj._r = this._r;
};

/**
 * @override
 */
dvt.RadialGradientFill.prototype.equals = function(fill) {
  if (fill instanceof dvt.RadialGradientFill && fill._cx == this._cx && fill._cy == this._cy && fill._r == this._r)
    return dvt.RadialGradientFill.superclass.equals.call(this, fill);
  else
    return false;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.



/**
  *   Selection effect utilities.
  *   @class dvt.SelectionEffectUtils
  *   @constructor
  */
dvt.SelectionEffectUtils = {};

dvt.Obj.createSubclass(dvt.SelectionEffectUtils, dvt.Obj);


/**
 * Get the border color to use for a selectable marker when the mouse hovers over it.
 * @param {String} color The color of the data marker.
 * @return String The resulting color.
 */
dvt.SelectionEffectUtils.getHoverBorderColor = function(color)
{
  return dvt.ColorUtils.adjustHSL(color, 0, 0, 0.15);
};


/**
 * Apply a draw effect to a given displayable object.
 *
 * @param {dvt.Displayable}  displayable  object to apply draw effect to
 * @param {DvtBaseDrawEffect}  drawEffect  effect to apply
 */
dvt.SelectionEffectUtils.applyDrawEffect = function(displayable, drawEffect)
{
  var numEffects = displayable.getNumDrawEffects();
  if (numEffects == 0) {
    displayable.addDrawEffect(drawEffect);
  } else {
    var pos = displayable.getDrawEffectIndex(drawEffect);
    if (pos > -1) {
      displayable.removeDrawEffectAt(pos);
      displayable.addDrawEffectAt(drawEffect, pos);
    } else {
      displayable.addDrawEffect(drawEffect);
    }
  }
};


/**
 * Create a stroke to use when the mouse hovers over a selectable marker.
 *
 * @param {String}  selColor  color of the data marker
 *
 * @type {dvt.Stroke}
 */
dvt.SelectionEffectUtils.createSelectingStroke = function(selColor)
{
  var stroke = new dvt.SolidStroke(dvt.SelectionEffectUtils.getHoverBorderColor(selColor), 1, 2);
  stroke.setMiterLimit(1); // Set low miter limit to avoid bits sticking out at corners of 3D bars, for example
  return stroke;
};


/**
 * Get the type of cursor to use when the mouse hovers over a selectable marker.
 * @return {string}
 */
dvt.SelectionEffectUtils.getSelectingCursor = function()
{
  return 'pointer';
};

// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*    dvt.KeyboardFocusEffect     Manages keyboard focus effect         */
/*---------------------------------------------------------------------*/
/**
  *  Creates a rectangular shape that represents keyboard focus
  *  @param {dvt.Context} context the rendering context
  *  @param {dvt.Container} displayable a parent container
  *  @param {dvt.Rectangle} bounds keyboard focus dimensions
  *  @param {dvt.Matrix} matrix transformation matrix to apply to the focus effect
  *  @param {string} id  optional id for the focus
  *  @param {boolean} bAppendLast optional argument that specifies a position of the focus effect in the parent container.
  *                   True to add focus effect to the end of the child list. Default is false.
  *  @extends {dvt.Rect}
  */
dvt.KeyboardFocusEffect = function(context, displayable, bounds, matrix,id, bAppendLast)
{
  this.Init(context, displayable, bounds, matrix, id, bAppendLast);
};

dvt.Obj.createSubclass(dvt.KeyboardFocusEffect, dvt.Obj);

dvt.KeyboardFocusEffect.FOCUS_BORDER_RADIUS = 1;
dvt.KeyboardFocusEffect.FOCUS_STROKE_WIDTH = 1;
dvt.KeyboardFocusEffect.FOCUS_STROKE_ALPHA = 1;
dvt.KeyboardFocusEffect.FOCUS_STROKE_TYPE = dvt.Stroke.DOTTED;


/*---------------------------------------------------------------------*/
/*  Init()                                                             */
/*---------------------------------------------------------------------*/
/**
  *  Object initializer.
  *  @param {dvt.Context} context the rendering context
  *  @param {dvt.Container} container a parent container
  *  @param {dvt.Rectangle} bounds keyboard focus dimensions
  *  @param {dvt.Matrix} matrix transformation matrix to apply to the focus effect
  *  @param {string} id  optional id for the focus
  *  @param {boolean} bAppendLast optional argument that specifies a position of the focus effect in the parent container.
  *                   True to add focus effect to the end of the child list. Default is false.
  *  @protected
  */
dvt.KeyboardFocusEffect.prototype.Init = function(context, container, bounds, matrix, id, bAppendLast)
{
  this._container = container;
  this._focusEffect = new dvt.Rect(context, bounds.x, bounds.y, bounds.w, bounds.h, id);

  var stroke = this.CreateStroke();
  this._focusEffect.setStroke(stroke);
  this._focusEffect.setRx(dvt.KeyboardFocusEffect.FOCUS_BORDER_RADIUS);
  this._focusEffect.setRy(dvt.KeyboardFocusEffect.FOCUS_BORDER_RADIUS);
  if (matrix)
    this._focusEffect.setMatrix(matrix);
  this._focusEffect.setFill(null);
  this._appendLast = bAppendLast;
};


/**
 * Helper function that creates a solid stroke for the focus rectangle
 * @return {dvt.SolidStroke} a stroke for the focus rectangle
 * @protected
 */
dvt.KeyboardFocusEffect.prototype.CreateStroke = function()
{
  var color = dvt.Agent.getFocusColor();
  var width = dvt.KeyboardFocusEffect.FOCUS_STROKE_WIDTH;
  var alpha = dvt.KeyboardFocusEffect.FOCUS_STROKE_ALPHA;
  var type = dvt.KeyboardFocusEffect.FOCUS_STROKE_TYPE;

  if (dvt.Agent.isPlatformWebkit()) {
    width = 2;
    type = dvt.Stroke.SOLID;
  }

  var stroke = new dvt.SolidStroke(color,
      alpha,
      width);
  stroke.setType(type, width, width);
  return stroke;
};

dvt.KeyboardFocusEffect.prototype.getEffect = function() 
{
  return this._focusEffect;
};

dvt.KeyboardFocusEffect.prototype.setEffect = function(effect) 
{
  this._focusEffect = effect;
};

dvt.KeyboardFocusEffect.prototype.show = function() {
  if (this._focusEffect instanceof dvt.Shape) {
    if (!this._appendLast)
      this._container.addChildAt(this._focusEffect, 0);
    else
      this._container.addChild(this._focusEffect);
  }
};

dvt.KeyboardFocusEffect.prototype.hide = function() {
  if (this._focusEffect instanceof dvt.Shape)
    this._container.removeChild(this._focusEffect);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * Defines a (w,h) dimension.
 * @class dvt.Dimension
 * @extends {dvt.Obj}
 * @constructor
 * @param {number} w The dimension width
 * @param {number} h The dimension height
 */
dvt.Dimension = function(w, h)
{
  this.Init(w, h);
};


dvt.Obj.createSubclass(dvt.Dimension, dvt.Obj);


/**
 * @param {number} w The dimension width
 * @param {number} h The dimension height
 * @protected
 */
dvt.Dimension.prototype.Init = function(w, h)
{
  this.w = ((w === null || isNaN(w)) ? 0 : w);
  this.h = ((h === null || isNaN(h)) ? 0 : h);
};


/**
 * Gets the width
 * @return {number} width
 */
dvt.Dimension.prototype.getWidth = function() {
  return this.w;
};


/**
 * Gets the height
 * @return {number} height
 */
dvt.Dimension.prototype.getHeight = function() {
  return this.h;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 *  Creates a matrix object.
 *  @extends {dvt.Obj}
 *  @class dvt.Matrix is a platform independent class representing a transformation
 *  matrix.
 *  <p>
 *  The matrix is in the form:<br>
 *  [ a  b  tx ]<br>
 *  [ c  d  ty ]<br>
 *  [ 0  0  1  ]<br>
 *  <p>
 *  <b>Example:</b><br><br> <code>
  *  var mat = new dvt.Matrix(context) ;<br>
 *  mat.translate(15, 30) ;<br>
 *</code>
 *  @constructor
 *  @param {number} a Optional
 *  @param {number} b Optional
 *  @param {number} c Optional
 *  @param {number} d Optional
 *  @param {number} tx Optional
 *  @param {number} ty Optional
 */
dvt.Matrix = function(a, b, c, d, tx, ty) 
{
  //don't allow users to set individual elements, because we
  //may need to adjust transforms for different platforms, for
  //example if the angle of rotation increases in different
  //directions on different platforms, and we don't want to try
  //to deconstruct the matrix
  this.Init(a, b, c, d, tx, ty);
};

dvt.Obj.createSubclass(dvt.Matrix, DvtLockable);

//   [ a  b  tx ]
//   [ c  d  ty ]
//   [ 0  0  1  ]


/**
 *  @private
 */
dvt.Matrix._DECOMP_TX = 0;


/**
 *  @private
 */
dvt.Matrix._DECOMP_TY = 1;


/**
 *  @private
 */
dvt.Matrix._DECOMP_R = 2;


/**
 *  @private
 */
dvt.Matrix._DECOMP_SKEWX = 3;


/**
 *  @private
 */
dvt.Matrix._DECOMP_SX = 4;


/**
 *  @private
 */
dvt.Matrix._DECOMP_SY = 5;


/**
 * Users should becareful when setting individual elements, because we may need to adjust transforms for different
 * platforms, for example if the angle of rotation increases in different directions on different platforms,
 * and we don't want to try to deconstruct the matrix
 *  @protected
 */
dvt.Matrix.prototype.Init = function(a, b, c, d, tx, ty) 
{
  this._a = (a == null) ? 1 : a;
  this._b = (b == null) ? 0 : b;
  this._c = (c == null) ? 0 : c;
  this._d = (d == null) ? 1 : d;
  this._tx = (tx == null) ? 0 : tx;
  this._ty = (ty == null) ? 0 : ty;

  this._u = 0;
  this._v = 0;
  this._w = 1;

  dvt.Matrix.superclass._Init.call(this);
};


/**
 *  @protected
 *  Make this matrix the identity matrix.
 */
dvt.Matrix.prototype.Identity = function() 
{
  this._a = 1;
  this._b = 0;
  this._c = 0;
  this._d = 1;
  this._tx = 0;
  this._ty = 0;
};


/**
 *  Get the A element of this matrix.
 *  @return {Number}  The A element of this matrix.
 */
dvt.Matrix.prototype.getA = function()
{
  return this._a;
};


/**
 *  Get the B element of this matrix.
 *  @return {Number}  The B element of this matrix.
 */
dvt.Matrix.prototype.getB = function()
{
  return this._b;
};


/**
 *  Get the C element of this matrix.
 *  @return {Number}  The C element of this matrix.
 */
dvt.Matrix.prototype.getC = function()
{
  return this._c;
};


/**
 *  Get the D element of this matrix.
 *  @return {Number}  The D element of this matrix.
 */
dvt.Matrix.prototype.getD = function()
{
  return this._d;
};


/**
 *  Get the TX element of this matrix.
 *  @return {Number}  The TX element of this matrix.
 */
dvt.Matrix.prototype.getTx = function()
{
  return this._tx;
};


/**
 *  Get the TY element of this matrix.
 *  @return {Number}  The TY element of this matrix.
 */
dvt.Matrix.prototype.getTy = function()
{
  return this._ty;
};


/**
 *  Clone this matrix.
 *  @return {dvt.Matrix}  A clone of this matrix.
 */
dvt.Matrix.prototype.clone = function() 
{
  return new dvt.Matrix(this._a, this._b, this._c, this._d, this._tx, this._ty);
};


/**
 *  Concatenate the given matrix with this matrix.
 *  @param {dvt.Matrix} mat   The matrix to concatenate with this matrix.
 */
dvt.Matrix.prototype.concat = function(mat)
{
  // A * B = B.concat(A) = childMatrix.concat(parentMatrix)

  if (this.isLocked())
  {
    return;
  }

  var newA = this._a * mat._a + this._c * mat._b + this._u * mat._tx;
  var newB = this._b * mat._a + this._d * mat._b + this._v * mat._tx;
  var newTX = this._tx * mat._a + this._ty * mat._b + this._w * mat._tx;

  var newC = this._a * mat._c + this._c * mat._d + this._u * mat._ty;
  var newD = this._b * mat._c + this._d * mat._d + this._v * mat._ty;
  var newTY = this._tx * mat._c + this._ty * mat._d + this._w * mat._ty;

  //var newU = this._a * mat._u + this._c * mat._v + this._u * mat._w;
  //var newV = this._b * mat._u + this._d * mat._v + this._v * mat._w;
  //var newW = this._tx * mat._u + this._ty * mat._v + this._w * mat._w;

  this._a = newA;
  this._b = newB;
  this._c = newC;
  this._d = newD;
  this._tx = newTX;
  this._ty = newTY;
};


/**
 *  Translate this matrix.
 *  @param {Number} dx   The horizontal distance to translate by, in pixels.
 *  @param {Number} dy   The vertical distance to translate by, in pixels.
 */
dvt.Matrix.prototype.translate = function(dx, dy)
{
  if (this.isLocked())
  {
    return;
  }

  var tMat = new dvt.Matrix();
  tMat._tx = dx;
  tMat._ty = dy;

  this.concat(tMat);
};


/**
 *  Scale this matrix, optionally around a specified point
 *  @param {number} sx   The horizontal value to scale by.
 *  @param {number} sy   The vertical value to scale by.
 *  @param {number} px   The x value of the point to scale around (optional)
 *  @param {number} py   The y value of the point to scale around (optional)
 */
dvt.Matrix.prototype.scale = function(sx, sy, px, py)
{
  if (this.isLocked())
  {
    return;
  }

  if (px || py) {
    this.translate(-px, -py);
  }
  var tMat = new dvt.Matrix();
  tMat._a = sx;
  tMat._d = sy;

  this.concat(tMat);
  if (px || py) {
    this.translate(px, py);
  }
};


/**
 *  Rotate this matrix.
 *  @param {Number} angleRads   The angle to rotate by, in radians.
 */
dvt.Matrix.prototype.rotate = function(angleRads)
{
  if (this.isLocked())
  {
    return;
  }

  var tMat = new dvt.Matrix();
  tMat._a = Math.cos(angleRads);
  tMat._d = tMat._a;
  tMat._c = Math.sin(angleRads);
  tMat._b = - tMat._c;

  this.concat(tMat);
};


/**
 *  Skew this matrix.
 *  @param {Number} sxRads   The horizontal angle to skew by, in radians.
 *  @param {Number} syRads   The vertical angle to skew by, in radians.
 */
dvt.Matrix.prototype.skew = function(sxRads, syRads)
{
  if (this.isLocked())
  {
    return;
  }

  var tMat = new dvt.Matrix();
  tMat._b = Math.tan(sxRads);
  tMat._c = Math.tan(syRads);

  this.concat(tMat);
};


/**
 *  @protected
 *  Calculate the determinant of this matrix.
 *  @return {number} determinant of this matrix
 */
dvt.Matrix.prototype.Determinant = function()
{
  var determinant = this._a * (this._d * this._w - this._ty * this._v) -
                    this._b * (this._c * this._w - this._ty * this._u) +
                    this._tx * (this._c * this._v - this._d * this._u);
  return determinant;
};


/**
 *  Invert this matrix.
 */
dvt.Matrix.prototype.invert = function()
{
  if (this.isLocked())
  {
    return;
  }

  var determinant = this.Determinant();
  var A = (this._d * this._w - this._ty * this._v);
  var B = (this._tx * this._v - this._b * this._w);
  var TX = (this._b * this._ty - this._tx * this._d);
  var C = (this._ty * this._u - this._c * this._w);
  var D = (this._a * this._w - this._tx * this._u);
  var TY = (this._tx * this._c - this._a * this._ty);
  //var U = (this._c * this._v - this._d * this._u);
  //var V = (this._b * this._u - this._a * this._v);
  //var W = (this._a * this._d - this._b * this._c);

  this._a = A / determinant;
  this._b = B / determinant;
  this._tx = TX / determinant;
  this._c = C / determinant;
  this._d = D / determinant;
  this._ty = TY / determinant;
  //this._u = U / determinant;
  //this._v = V / determinant;
  //this._w = W / determinant;
};


/**
 *  @private
 *  Decompose this matrix into its constituent transforms.
 *  @return {Array} array of transform values in the form
 *           [translateX, translateY, rotationRadians, skewXRadians, scaleX, scaleY],
 *           of null if decomposition doesn't exist
 */
dvt.Matrix.prototype._decompose = function()
{
  var A = this._a;
  var B = this._b;
  var C = this._c;
  var D = this._d;
  var Tx = this._tx;
  var Ty = this._ty;

  if (A * D - B * C === 0)
    return null;

  //x scale factor
  var Sx = Math.sqrt(A * A + C * C);
  A = A / Sx;
  C = C / Sx;

  //xy shear
  var K = A * B + C * D;
  B = B - A * K;
  D = D - C * K;

  //y scale factor
  var Sy = Math.sqrt(B * B + D * D);
  B = B / Sy;
  D = D / Sy;
  K = K / Sy;

  var determinant = A * D - B * C;
  if (determinant === -1)
  {
    K = - K;
    Sy = - Sy;
  }

  //rotation
  var R = Math.atan2(C, A);

  //skew
  var skewX = Math.atan(K);

  //to create new matrix with same transforms, use order:
  //1) scale(Sx, Sy)
  //2) skew(skewX, 0);
  //3) rotate(R);
  //4) translate(Tx, Ty);
  return [Tx, Ty, R, skewX, Sx, Sy];
};


/**
 *  @private
 *  Recompose this matrix from the given decomposition.
 *  @param {Array}  arDecomposition  array of transform values returned from
 *         calling decompose()
 */
dvt.Matrix.prototype._recompose = function(arDecomposition)
{
  if (this.isLocked())
  {
    return;
  }

  this.Identity();

  var Tx = arDecomposition[0];
  var Ty = arDecomposition[1];
  var R = arDecomposition[2];
  var skewX = arDecomposition[3];
  var Sx = arDecomposition[4];
  var Sy = arDecomposition[5];

  this.scale(Sx, Sy);
  this.skew(skewX, 0);
  this.rotate(R);
  this.translate(Tx, Ty);
};


/**
 *  @private
 *  Determine whether this matrix is equal to another.
 *  @param {dvt.Matrix} mat   The matrix to compare with this matrix.
 *  @return {Boolean} True if equal, false if not.
 */
dvt.Matrix.prototype.equals = function(mat) {
  if (!this && mat) return false;
  else if (this && !mat) return false;
  else if (!this && !mat) return true;
  else return (this._a == mat._a && this._b == mat._b && this._c == mat._c &&
      this._d == mat._d && this._tx == mat._tx && this._ty == mat._ty);
};


/**
 * Transform a point using this matrix.
 * @param {dvt.Point}  p  point to transform
 * @type {dvt.Point}
 */
dvt.Matrix.prototype.transformPoint = function(p)
{
  var newX = this._a * p.x + this._b * p.y + this._tx * 1;
  var newY = this._c * p.x + this._d * p.y + this._ty * 1;
  return new dvt.Point(newX, newY);
};


/**
 * Test if this matrix is an indentity matrix.  Returns true if an identity matrix, else false.
 * @type {boolean}
 */
dvt.Matrix.prototype.isIdentity = function()
{
  return (this._a == 1 && this._b == 0 && this._c == 0 && this._d == 1 && this._tx == 0 && this._ty == 0);
};

// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * Defines an (x,y) coordinate.
 * @class dvt.Point
 * @extends {dvt.Obj}
 * @constructor
 * @param {number} x
 * @param {number} y
 */
dvt.Point = function(x,y)
{
  this.Init(x, y);
};

dvt.Obj.createSubclass(dvt.Point, dvt.Obj);

dvt.Point.prototype.Init = function(x, y)
{
  this.x = ((x === null || isNaN(x)) ? 0 : x);
  this.y = ((y === null || isNaN(y)) ? 0 : y);
};

/**
 * Compare the coordinates with another dvt.Point
 *
 * @param {dvt.Point} p  point to compare
 * @return {boolean} true if the point has the same coordinates as this
 */
dvt.Point.prototype.equals = function(p)
{
  if (p instanceof dvt.Point &&
      this.x === p.x && this.y === p.y)
    return true;

  return false;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
  *  Defines the geometry of a rectangle. Top-left (x,y), and width and height.
  *  @class dvt.Rectangle
  *  @extends {dvt.Obj}
  *  @constructor
  *  @param {number} x
  *  @param {number} y
  *  @param {number} w
  *  @param {number} h
  *  @type {dvt.Rectangle}
  */
dvt.Rectangle = function(x,y,w,h)
{
  this.x = ((x === null || isNaN(x)) ? 0 : x);
  this.y = ((y === null || isNaN(y)) ? 0 : y);
  this.w = ((w === null || isNaN(w)) ? 0 : w);
  this.h = ((h === null || isNaN(h)) ? 0 : h);
};

dvt.Obj.createSubclass(dvt.Rectangle, dvt.Obj);


/**
 * Creates a new dvt.Rectangle from an array of coordinates.
 * @param {Array} ar  an array of rectangle coordinates, where x = ar[0], y = ar[1], w = ar[2], h = ar[3].
 * @return  {dvt.Rectangle}
 */
dvt.Rectangle.create = function(ar)
{
  return new dvt.Rectangle(ar[0], ar[1], ar[2], ar[3]);
};


/**
 * Returns true if the rectangle contains the given point.
 */
dvt.Rectangle.prototype.containsPoint = function(nX, nY) 
{
  return (nX >= this.x && nX <= this.x + this.w && nY >= this.y && nY <= this.y + this.h);
};


dvt.Rectangle.prototype.getCenter = function()
{
  return new dvt.Point(this.x + (this.w / 2.0), this.y + (this.h / 2.0));
};


/**
 * Returns the union of this and the supplied rectangle.
 * @param {dvt.Rectangle}  rect  the supplied rectangle.
 * @return {dvt.Rectangle} a new rectangle that is the union of this and the supplied rectangle.
 */
dvt.Rectangle.prototype.getUnion = function(rect) 
{
  var u = new dvt.Rectangle();

  if (rect && rect.w !== 0 && rect.h !== 0) {  // ignore zero size rect's
    if (this.w !== 0 && this.h !== 0) {        //  ..     ..   ..    ..
      var thisRight = this.x + this.w;             // this right
      var thisBottom = this.y + this.h;             // this bottom
      var rectRight = rect.x + rect.w;             // rect right
      var rectBottom = rect.y + rect.h;             // rect bottom

      var minx = Math.min(this.x, rect.x);
      var miny = Math.min(this.y, rect.y);

      u.w = (thisRight < rectRight) ? (rectRight - minx) : (thisRight - minx);
      u.h = (thisBottom > rectBottom) ? (thisBottom - miny) : (rectBottom - miny);
      u.x = minx;
      u.y = miny;
    }
    else {
      u.x = rect.x;
      u.y = rect.y;
      u.w = rect.w;
      u.h = rect.h;
    }
  }
  else {
    u.x = this.x;
    u.y = this.y;
    u.w = this.w;
    u.h = this.h;
  }

  return u;
};

/**
 * Returns the intersection of this and the supplied rectangle.
 * @param {dvt.Rectangle}  rect  the supplied rectangle.
 * @return {dvt.Rectangle} a new rectangle that is the intersection of this and the supplied rectangle. Returns null if there is no intersection.
 */
dvt.Rectangle.prototype.getIntersection = function(rect) 
{
  var i = new dvt.Rectangle();

  if (rect && rect.w !== 0 && rect.h !== 0) {  // ignore zero size rect's
    if (this.w !== 0 && this.h !== 0) {        //  ..     ..   ..    ..
      var thisRight = this.x + this.w;             // this right
      var thisBottom = this.y + this.h;             // this bottom
      var rectRight = rect.x + rect.w;             // rect right
      var rectBottom = rect.y + rect.h;             // rect bottom

      var maxX = Math.max(this.x, rect.x);
      var maxY = Math.max(this.y, rect.y);

      if (maxX >= thisRight || maxX >= rectRight || maxY >= thisBottom || maxY >= rectBottom)
        return null;

      i.w = (thisRight < rectRight) ? (thisRight - maxX) : (rectRight - maxX);
      i.h = (thisBottom > rectBottom) ? (rectBottom - maxY) : (thisBottom - maxY);
      i.x = maxX;
      i.y = maxY;
    }
    else {
      return null;
    }
  }
  else
    return null;

  return i;
};

/**
 * Grow this rectangle to include the given coordinates.
 * @param {number}  xx  x coordinate
 * @param {number}  yy  y coordinate
 */
dvt.Rectangle.prototype.grow = function(xx, yy) 
{
  var minX = this.x;
  var minY = this.y;
  var maxX = this.x + this.w;
  var maxY = this.y + this.h;

  if (xx < minX) {
    minX = xx;
  }
  if (xx > maxX) {
    maxX = xx;
  }
  if (yy < minY) {
    minY = yy;
  }
  if (yy > maxY) {
    maxY = yy;
  }
  this.x = minX;
  this.y = minY;
  this.w = maxX - minX;
  this.h = maxY - minY;
};


/**
 * Returns true if the rectangle intersectes the supplied rectangle.
 * @param {dvt.Rectangle}  rect  the supplied rectangle.
 */
dvt.Rectangle.prototype.intersects = function(rect) 
{
  if (rect && rect.w !== 0 && rect.h !== 0) {  // ignore zero size rect's
    if (this.w !== 0 && this.h !== 0) {        //  ..     ..   ..    ..
      var thisRight = this.x + this.w;             // this right
      var thisBottom = this.y + this.h;             // this bottom
      var rectRight = rect.x + rect.w;             // rect right
      var rectBottom = rect.y + rect.h;             // rect bottom

      return !(rect.x > thisRight || rectRight < this.x || rect.y > thisBottom || rectBottom < this.y);
    }
  }
  return false;
};


/**
 * Returns a clone of itself.
 * @return {dvt.Rectangle} Its clone.
 */
dvt.Rectangle.prototype.clone = function() {
  return new dvt.Rectangle(this.x, this.y, this.w, this.h);
};

/**
 * Return true if the specified object is equal to this one.
 * @param {object} obj
 * @return {boolean}
 */
dvt.Rectangle.prototype.equals = function(obj) {
  return (obj instanceof dvt.Rectangle) && this.x == obj.x && this.y == obj.y && this.w == obj.w && this.h == obj.h;
};

/**
 * @override
 */
dvt.Rectangle.prototype.toString = function() {
  return this.x + ', ' + this.y + ', ' + this.w + ', ' + this.h;
};
// Copyright (c) 2013, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * Vector math utilities.
 * @class dvt.VectorUtils
 * @extends {dvt.Obj}
 */
dvt.VectorUtils = {};

dvt.Obj.createSubclass(dvt.VectorUtils, dvt.Obj);

/**
 * Creates a vector from the origin to the specified coordinate
 *
 * @param {number} x the x coordinate of the vector
 * @param {number} y the y coordinate of the vector
 * @return {object} an object with x and y properties representing the vector
 */
dvt.VectorUtils.createVector = function(x, y) {
  var v = {};
  v.x = x;
  v.y = y;
  return v;
};

/**
 * Adds two vectors
 *
 * @param {object} v1 an object with x and y properties representing the first addend
 * @param {object} v2 an object with x and y properties representing the second addend
 * @return {object} an object with x and y properties representing the sum
 */
dvt.VectorUtils.addVectors = function(v1, v2) {
  return dvt.VectorUtils.createVector(v1.x + v2.x, v1.y + v2.y);
};


/**
 * Subtracts two vectors
 *
 * @param {object} v1 an object with x and y properties representing the minuend
 * @param {object} v2 an object with x and y properties representing the subtrahend
 * @return {object} an object with x and y properties representing the difference
 */
dvt.VectorUtils.subtractVectors = function(v1, v2) {
  return dvt.VectorUtils.createVector(v1.x - v2.x, v1.y - v2.y);
};

/**
 * Scales a vector
 *
 * @param {object} v an object with x and y properties representing the vector
 * @param {number} s the scalar by which to scale the vector
 * @return {object} an object with x and y properties representing the scaled vector
 */
dvt.VectorUtils.scaleVector = function(v, s) {
  return dvt.VectorUtils.createVector(v.x * s, v.y * s);
};

/**
 * Scales a vector
 *
 * @param {object} v an object with x and y properties representing the vector
 * @return {number} the magnitude of the vector
 */
dvt.VectorUtils.getMagnitude = function(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
};
/**
 * 2D array implementation for use in improving performance.  Alternate implementation options may be added in
 * the future as needed.
 * @class dvt.Array2D
 * @extends {dvt.Obj}
 * @constructor
 */
dvt.Array2D = function() {
  this.Init();
};

dvt.Obj.createSubclass(dvt.Array2D, dvt.Obj);

/**
 * Initializes the array and its underlying data structures.
 */
dvt.Array2D.prototype.Init = function() {
  this._data = [];
};

/**
 * Retrieves the value corresponding to the keys from the array.
 * @param {number} keyA
 * @param {number} keyB
 * @return {object}
 */
dvt.Array2D.prototype.get = function(keyA, keyB) {
  return this._getInner(keyA)[keyB];
};

/**
 * Stores the value corresponding to the keys in the array.
 * @param {number} keyA
 * @param {number} keyB
 * @param {object} value
 * @return {object} The previous value, if one existed.
 */
dvt.Array2D.prototype.put = function(keyA, keyB, value) {
  var innerMap = this._getInner(keyA);
  var oldValue = innerMap[keyB];
  innerMap[keyB] = value;
  return oldValue;
};

/**
 * Returns the inner array corresponding to the specified key, creating it if necessary.
 * @param {number} keyA
 * @return {array} The inner array.
 * @private
 */
dvt.Array2D.prototype._getInner = function(keyA) {
  var innerMap = this._data[keyA];
  if (!innerMap) {
    innerMap = [];
    this._data[keyA] = innerMap;
  }
  return innerMap;
};
/**
 * LRU cache implementation for use in improving performance.  Alternate cache implementation options may be added in
 * the future as needed.
 * @param {number} targetSize The target size of the cache. Once populated, this is the minimum size of the cache.
 * @class dvt.Cache
 * @extends {dvt.Obj}
 * @constructor
 */
dvt.Cache = function(targetSize) {
  this.Init(targetSize);
};

dvt.Obj.createSubclass(dvt.Cache, dvt.Obj);


/**
 * The default target size of the cache.
 * @private
 */
dvt.Cache._TARGET_SIZE = 1000;


/**
 * The overflow allowed in cache size before a removal of old keys is performed.
 * @private
 */
dvt.Cache._BUFFER_SIZE = 0.50;


/**
 * Initializes the cache and its underlying data structures.
 * @param {number} targetSize The target size of the cache. Once populated, this is the minimum size of the cache.
 */
dvt.Cache.prototype.Init = function(targetSize) {
  this._targetSize = targetSize != null ? targetSize : dvt.Cache._TARGET_SIZE;
  this._maxSize = Math.ceil(this._targetSize * (1 + dvt.Cache._BUFFER_SIZE));

  // Initialize the cache and array of keys, where the first key is the least recently used.
  this._cache = {};
  this._lruArray = [];

  // Initialize debug params for cache tuning
  this._hits = 0;
  this._misses = 0;
};


/**
 * Retrieves the value corresponding to the key from the cache.  If the key cannot be found in the cache, returns null.
 * @param {object} key
 * @return {object}
 */
dvt.Cache.prototype.get = function(key) {
  var ret = this._cache[key];
  if (ret != null) {
    this._hits++;
    return ret;
  }
  else {
    this._misses++;
    return null;
  }
};


/**
 * Stores the value corresponding to the key in the cache.  If the cache has reached the maximum size, then the least
 * recently used key will be removed from the cache.
 * @param {object} key
 * @param {object} value
 */
dvt.Cache.prototype.put = function(key, value) {
  // Optimize the cache update based on whether the key already existed in the cache
  var bKeyExists = (this._cache[key] != null);

  // Update the cache first
  this._cache[key] = value;

  // Update the array tracking recently used items
  if (bKeyExists) {
    // Already exists, remove before we add to the end of the list
    var keyIndex = dvt.ArrayUtils.getIndex(this._lruArray, key);
    this._lruArray.splice(keyIndex, 1);
    this._lruArray.push(key);
  }
  else {
    // Doesn't exist already, add to the array.  This indicates the cache size has increased.
    this._lruArray.push(key);

    // If the cache size exceeds the max length, then remove the least recently used items.
    if (this._lruArray.length > this._maxSize) {
      var removedKeys = this._lruArray.splice(0, this._maxSize - this._targetSize);
      for (var i = 0; i < removedKeys.length; i++) {
        delete this._cache[removedKeys[i]];
      }
    }
  }
};


/**
 * @override
 */
dvt.Cache.prototype.toString = function() {
  // Returns a variety of tuning information
  var ret = 'Cache Size: ' + this._lruArray.length;
  ret += '\nHits: ' + this._hits;
  ret += '\nMisses: ' + this._misses;
  ret += '\nHit %: ' + Math.round(10000 * this._hits / (this._hits + this._misses)) / 100;
  return ret;
};
/**
 *  A static class for DnD support.
 *  @class dvt.DragAndDropUtils
 */
dvt.DragAndDropUtils = {};

dvt.Obj.createSubclass(dvt.DragAndDropUtils, dvt.Obj);

/**
 * Returns a {dvt.Rectangle} representing the drag feedback bounds.
 * @param {object} displayables The dvt.Displayable or array of DvtDisplayables to display for drag feedback.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the coordinate space of the resulting bounds.  The
 *                                               parent coordinate space is used if none is provided.
 */
dvt.DragAndDropUtils.getDragFeedbackBounds = function(displayables, targetCoordinateSpace) {
  if (!displayables)
    return null;

  var bounds = null;
  if (!(displayables instanceof Array)) {
    // for simple objects, just return the object bounds
    // TODO: eventually should ensure that bounds are in container coordinates
    bounds = displayables.getDimensions(targetCoordinateSpace ? targetCoordinateSpace : displayables.getParent());
  }
  else if (displayables.length > 0) {
    // TODO: eventually should ensure that bounds are in container coordinates
    // for arrays, initialize bounds based on the first object
    bounds = displayables[0].getDimensions(targetCoordinateSpace ? targetCoordinateSpace : displayables[0].getParent());

    // ... and adjust it to acommodate other objects in the collection
    for (var i = 1; i < displayables.length; i++) {
      var obj = displayables[i];
      var objBounds = obj.getDimensions(targetCoordinateSpace ? targetCoordinateSpace : obj.getParent());

      if (objBounds.x < bounds.x) {
        bounds.w += (bounds.x - objBounds.x);
        bounds.x = objBounds.x;
      }
      if (objBounds.y < bounds.y) {
        bounds.h += (bounds.y - objBounds.y);
        bounds.y = objBounds.y;
      }
      if ((objBounds.x + objBounds.w) > (bounds.x + bounds.w)) {
        bounds.w = objBounds.x + objBounds.w - bounds.x;
      }
      if ((objBounds.y + objBounds.h) > (bounds.y + bounds.h)) {
        bounds.h = objBounds.y + objBounds.h - bounds.y;
      }
    }
  }
  return bounds;
};
/**
 *  A static class for chart layout.
 *  @class dvt.LayoutUtils
 *  @constructor
*/
dvt.LayoutUtils = {};

dvt.Obj.createSubclass(dvt.LayoutUtils, dvt.Obj);


/**
 * Positions the specified displayable in the available space.
 * @param {dvt.Rectangle} availSpace The available space.
 * @param {string} position The position within the available space.  Valid values are "top", "bottom", "left", "right", "start", "end".
 * @param {dvt.Displayable} displayable The displayable to be positioned.
 * @param {number} width The width of the displayable.
 * @param {number} height The height of the displayable.
 * @param {number} gap The gap to leave between the displayable and other content.  This gap is applied only if
 *                     the displayable's area is greater than 0.
 */
dvt.LayoutUtils.position = function(availSpace, position, displayable, width, height, gap) {
  if (!displayable)
    return;

  // Adjust the gap if the displayable has no area
  gap = (width * height > 0) ? gap : 0;

  if (position == 'start')
    position = dvt.Agent.isRightToLeft(displayable.getCtx()) ? 'right' : 'left';
  else if (position == 'end')
    position = dvt.Agent.isRightToLeft(displayable.getCtx()) ? 'left' : 'right';

  if (position == 'top') {
    displayable.setTranslate(availSpace.x + availSpace.w / 2 - width / 2, availSpace.y);
    availSpace.y += (height + gap);
    availSpace.h -= (height + gap);
  }
  else if (position == 'bottom') {
    displayable.setTranslate(availSpace.x + availSpace.w / 2 - width / 2, availSpace.y + availSpace.h - height);
    availSpace.h -= (height + gap);
  }
  else if (position == 'left') {
    displayable.setTranslate(availSpace.x, availSpace.y + availSpace.h / 2 - height / 2);
    availSpace.x += (width + gap);
    availSpace.w -= (width + gap);
  }
  else if (position == 'right') {
    displayable.setTranslate(availSpace.x + availSpace.w - width, availSpace.y + availSpace.h / 2 - height / 2);
    availSpace.w -= (width + gap);
  }
};


/**
 * Aligns the specified displayable in the available space.
 * @param {dvt.Rectangle} availSpace The available space.
 * @param {string} align The position within the available space.  Valid values are "start", "center", and "end".
 * @param {dvt.Displayable} displayable The displayable to be positioned.
 * @param {number} width The width of the displayable.
 */
dvt.LayoutUtils.align = function(availSpace, align, displayable, width) {
  if (!displayable)
    return;

  // Account for the locale and find the position
  var position = align;
  if (position == 'start')
    position = dvt.Agent.isRightToLeft(displayable.getCtx()) ? 'right' : 'left';
  else if (position == 'end')
    position = dvt.Agent.isRightToLeft(displayable.getCtx()) ? 'left' : 'right';

  // Align the text
  if (position == 'left')
    displayable.setX(availSpace.x);
  else if (position == 'center')
    displayable.setX(availSpace.x + availSpace.w / 2 - width / 2);
  else if (position == 'right')
    displayable.setX(availSpace.x + availSpace.w - width);
};

/**
 * Returns the bubble marker size for a data item.
 * @param {number} z The z value of the data item.
 * @param {number} minZ The minimum z value in the data set.
 * @param {number} maxZ The maximum z value in the data set.
 * @param {number} minSize The smallest allowable bubble size.
 * @param {number} maxSize The largest allowable bubble size.
 * @return {number}
 */
dvt.LayoutUtils.getBubbleSize = function(z, minZ, maxZ, minSize, maxSize) {
  if (z <= 0)
    return 0;

  // Marker shape doesn't matter, so assume square markers
  var minArea = minSize * minSize;
  var maxArea = maxSize * maxSize;

  // If the z value range is less than the area range, reduce the are range to match the z value range by
  // increasing minArea and decreasing maxArea by the same factor
  if ((maxZ / minZ) < (maxArea / minArea)) {
    // The formula below guarantees that:
    // 1) the new area range matches the z value range, i.e. (maxArea / minArea) == (maxZ / minZ)
    // 2) the new area range is within than the original area range, i.e. (maxArea < origMaxArea) && (minArea > origMinArea)
    // 3) the max area is decreased by the same factor as the min area is increased, i.e. (origMaxArea / maxArea) == (minArea / origMinArea)
    var avgArea = Math.sqrt(minArea * maxArea);
    var avgZ = Math.sqrt(minZ * maxZ);

    // Handle the case where z == minZ == maxZ
    if (z == avgZ)
      return Math.sqrt(avgArea);

    maxArea = maxZ / avgZ * avgArea;
    minArea = minZ / avgZ * avgArea;
  }

  // The bubble area is linearly proportional to the z value
  var area = minArea + (z - minZ) / (maxZ - minZ) * (maxArea - minArea);
  return Math.sqrt(area);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Defines miscellaneous math constants and utilities.
 * @class dvt.Math
 */
dvt.Math = new Object();

dvt.Obj.createSubclass(dvt.Math, dvt.Obj);

/**
 *  Number of radians in 1 degree.
 *  @type {number}
 *  @const
 */
dvt.Math.RADS_PER_DEGREE = (Math.PI / 180);

/**
 *  Number of degrees in 1 radian.
 *  @type {number}
 *  @const
 */
dvt.Math.DEGREES_PER_RAD = (180 / Math.PI);

/**
 *  Twice value of Pi radians.
 *  @type {number}
 *  @const
 */
dvt.Math.TWO_PI = (Math.PI * 2);

/**
 *  Half the value of Pi radians.
 *  @type {number}
 *  @const
 */
dvt.Math.HALF_PI = (Math.PI / 2);

/**
 *  One quarter the value of Pi radians.
 *  @type {number}
 *  @const
 */
dvt.Math.QUARTER_PI = (Math.PI / 4);

/**
 *  Fudge factor deal with floating point rounding error
 *  @type {number}
 *  @const
 */
dvt.Math.TOLERANCE = 0.1;

/**
 * Cantor pairing function. Uniquely encodes two positive natural numbers (a, b) into a single natural number.
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
dvt.Math.cantorPairing = function(a, b) {
  if (a < 0 || b < 0)// works for non-negative integers only!
    return - 1;

  return (a + b) * (a + b + 1) / 2 + a;
};

/**
 * Converts degrees to radians.
 * @param {number} deg The value in degrees to be converted.
 * @return {number}
 */
dvt.Math.degreesToRads = function(deg) {
  return (deg * dvt.Math.RADS_PER_DEGREE);
};

/**
 * Converts radians to degrees.
 * @param {number} rad The value in radians to be converted.
 * @return {number}
 */
dvt.Math.radsToDegrees = function(rad) {
  return (rad * dvt.Math.DEGREES_PER_RAD);
};

/**
 * Interpolate a number between the original and destination values for the given percent.
 * @param {number} origVal The original value
 * @param {number} destVal The destination value
 * @param {number} percent The percent value to interpolate
 * @return {number}
 */
dvt.Math.interpolateNumber = function(origVal, destVal, percent) {
  return (origVal + percent * (destVal - origVal));
};

/**
 * Returns the log base 10 of the value.
 * @param {number} value
 * @return {number}
 */
dvt.Math.log10 = function(value) {
  return Math.log(value) / Math.LN10;
};
/**
 * 2D map implementation for use in improving performance.  Alternate implementation options may be added in
 * the future as needed.
 * @class dvt.Map2D
 * @extends {dvt.Obj}
 * @constructor
 */
dvt.Map2D = function() {
  this.Init();
};

dvt.Obj.createSubclass(dvt.Map2D, dvt.Obj);

/**
 * Initializes the map and its underlying data structures.
 */
dvt.Map2D.prototype.Init = function() {
  this._map = {};
};

/**
 * Retrieves the value corresponding to the keys from the map.
 * @param {object} keyA
 * @param {object} keyB
 * @return {object}
 */
dvt.Map2D.prototype.get = function(keyA, keyB) {
  return this._getInnerMap(keyA)[keyB];
};

/**
 * Stores the value corresponding to the keys in the map.
 * @param {object} keyA
 * @param {object} keyB
 * @param {object} value
 * @return {object} The previous value, if one existed.
 */
dvt.Map2D.prototype.put = function(keyA, keyB, value) {
  var innerMap = this._getInnerMap(keyA);
  var oldValue = innerMap[keyB];
  innerMap[keyB] = value;
  return oldValue;
};

/**
 * Returns the inner map corresponding to the specified key, creating it if necessary.
 * @param {object} keyA
 * @return {object} The inner map.
 * @private
 */
dvt.Map2D.prototype._getInnerMap = function(keyA) {
  var innerMap = this._map[keyA];
  if (!innerMap) {
    innerMap = {};
    this._map[keyA] = innerMap;
  }
  return innerMap;
};
/**
 * A specialized map used for tracking whether a set of pixel coords has been drawn to.
 * @param {number=} scale The scale factor determining how many pixels in each direction the map coords correspond to.
 *                         Defaults to 1 if not specified. The scale factor must be an exact multiple of the inner map's
 *                         scale factor.
 * @param {dvt.PixelMap=} innerMap A map with smaller scale factor.
 * @class dvt.PixelMap
 * @extends {dvt.Array2D}
 * @constructor
 */
dvt.PixelMap = function(scale, innerMap) {
  this.Init(scale, innerMap);
};

dvt.Obj.createSubclass(dvt.PixelMap, dvt.Array2D);

/** @private @const **/
dvt.PixelMap._INITIAL_SIZE = 1500;

/**
 * Initializes the map and its underlying data structures.
 * @param {number=} scale The scale factor determining how many pixels in each direction the map coords correspond to.
 *                         Defaults to 1 if not specified. The scale factor must be an exact multiple of the inner map's
 *                         scale factor.
 * @param {dvt.PixelMap=} innerMap A map with smaller scale factor.
 */
dvt.PixelMap.prototype.Init = function(scale, innerMap) {
  dvt.PixelMap.superclass.Init.call(this);

  // Store the inner map and add the outer map reference back to this.
  this._innerMap = innerMap;
  if (this._innerMap) {
    this._innerMap._outerMap = this;
    this._innerMap._bOuterMap = true;
  }

  // Store the scale and cache capacity.
  this._scale = scale || 1;
  this._capacity = this._scale * this._scale;

  // Cache the presence of inner and outer maps, since they are checked frequently.
  this._bInnerMap = (this._innerMap != null);
  this._bOuterMap = false; // set to true if passed to an outer map.

  // Prepopulate a section of the underlying data structure for performance reasons.
  // Testing has shown that subsequent use of a pre-populated 2D array is significantly
  // faster than populating the data structure as we go.
  var initialSize = dvt.PixelMap._INITIAL_SIZE / this._scale;
  for (var x = 0; x < initialSize; x++) {
    for (var y = 0; y < initialSize; y++) {
      this.put(x, y, 0);
    }
  }
};

/**
 * Returns true if the specified coordinates are fully obscured.
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @return {boolean}
 */
dvt.PixelMap.prototype.isObscured = function(x1, y1, x2, y2) {
  // Evaluate the scaled areas to determine whether the coords are obscured.
  var scaledX1 = this._adjustForScale(x1);
  var scaledY1 = this._adjustForScale(y1);
  var scaledX2 = this._adjustForScale(x2);
  var scaledY2 = this._adjustForScale(y2);
  for (var xCoord = scaledX1; xCoord <= scaledX2; xCoord++) {
    for (var yCoord = scaledY1; yCoord <= scaledY2; yCoord++) {
      // Check this map's information. If known to be obscured, search the next area.
      var pixelValue = this.get(xCoord, yCoord);
      if (pixelValue !== true) {
        // Not known to be obscured, check the inner map.
        if (this._bInnerMap) {
          var innerX1 = Math.max(x1, xCoord * this._scale);
          var innerY1 = Math.max(y1, yCoord * this._scale);
          var innerX2 = Math.min(x2, ((xCoord + 1) * this._scale) - 1);
          var innerY2 = Math.min(y2, ((yCoord + 1) * this._scale) - 1);
          if (!this._innerMap.isObscured(innerX1, innerY1, innerX2, innerY2))
            return false;
        }
        else // no inner map, not obscured.
          return false;
      }
    }
  }
  // If not obscured, would've returned false earlier.
  return true;
};

/**
 * Obscures the specified coordinates.
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} alpha The amount of the pixel to obscure.
 */
dvt.PixelMap.prototype.obscure = function(x1, y1, x2, y2, alpha) {
  // Evaluate the scaled segments to determine whether the coords are obscured.
  var scaledX1 = this._adjustForScale(x1);
  var scaledY1 = this._adjustForScale(y1);
  var scaledX2 = this._adjustForScale(x2);
  var scaledY2 = this._adjustForScale(y2);
  for (var xCoord = scaledX1; xCoord <= scaledX2; xCoord++) {
    for (var yCoord = scaledY1; yCoord <= scaledY2; yCoord++) {
      // Check this map's information. If not known to be obscured, check the inner maps.
      var pixelValue = this.get(xCoord, yCoord);
      if (pixelValue !== true) {
        if (this._bInnerMap) {
          var innerX1 = Math.max(x1, xCoord * this._scale);
          var innerY1 = Math.max(y1, yCoord * this._scale);
          var innerX2 = Math.min(x2, ((xCoord + 1) * this._scale) - 1);
          var innerY2 = Math.min(y2, ((yCoord + 1) * this._scale) - 1);
          this._innerMap.obscure(innerX1, innerY1, innerX2, innerY2, alpha);
        }
        else {
          // No inner map, increment. The scale should always be 1 here.
          this._increment(xCoord, yCoord, alpha);
        }
      }
    }
  }
};

/**
 * Increments the map for the specified coordinates.
 * @param {number} x The unscaled x coordinate.
 * @param {number} y The unscaled y coordinate.
 * @param {number} incr The amount to increment.
 * @private
 */
dvt.PixelMap.prototype._increment = function(x, y, incr) {
  // First adjust the coordinates for this map's scale.
  var scaledX = this._adjustForScale(x);
  var scaledY = this._adjustForScale(y);

  // Increment the value. If value is greater than capacity, store as true (occupied).
  var value = this.get(scaledX, scaledY);
  value = (value != null) ? value + incr : incr;
  if (value >= this._capacity)
    value = true;

  // Update the map.
  this.put(scaledX, scaledY, value);

  // If at capacity, update the outer map.
  if (value === true && this._bOuterMap)
    this._outerMap._increment(x, y, this._capacity);
};

/**
 * Returns the scaled value for the specified coordinate.
 * @param {number} coord The unscaled coordinate.
 * @return {number}
 * @private
 */
dvt.PixelMap.prototype._adjustForScale = function(coord) {
  return Math.floor(coord / this._scale);
};
/**
 * @constructor
 * property map
 */
dvt.PropMap = function() {
  this.Init();
};

dvt.PropMap.REGEXP = new RegExp('#\\{([^\\}]*)\\}', 'g');


/**
 * make dvt.PropMap a subclass of dvt.Obj
 */
dvt.Obj.createSubclass(dvt.PropMap, dvt.Obj);

/**
 * Initializes the instance.
 */
dvt.PropMap.prototype.Init = function() {
  //Note: there is no Init method in superclass
  // dvt.PropMap.superclass.Init.call(this);
  this._props = {};
};


/*-------------------------------------------------------------------------*/
/*   AfComponent properties                                                */
/*-------------------------------------------------------------------------*/
dvt.PropMap.prototype.getProperty = function(propName) {
  return this._props[propName];
};

dvt.PropMap.prototype.setProperty = function(propName, val) {
  this._props[propName] = val;
};


dvt.PropMap.prototype.getStringProp = function(propName, defString) {
  var val = this._props[propName];
  return val ? val : defString;
};


/**
 * Returns boolean value of the specified property
 * @param {string} propName  property name
 * @param {boolean} defBool default value
 * @return {boolean} boolean value of the specified property
 */
dvt.PropMap.prototype.getBooleanProp = function(propName, defBool) {
  var val = this._props[propName];
  var ret = defBool;
  if (typeof val === 'boolean')
    ret = val;
  else if (val === 0)
    ret = false;
  else if (val === 1)
    ret = true;
  else if (typeof val === 'string')
    ret = (val.toLowerCase() === 'true' || val.toLowerCase() === 'yes' || val.toLowerCase() === 'on');

  return ret;
};

dvt.PropMap.prototype.getIntegerProp = function(propName, defInt) {
  var val = this._props[propName];
  var ret;
  if (val)
    ret = parseInt(val);
  return (ret) ? ret : defInt;
};

dvt.PropMap.prototype.getFloatProp = function(propName, defFloat) {
  var val = this._props[propName];
  var ret;
  if (val)
    ret = parseFloat(val);
  return (ret) ? ret : defFloat;
};


/**
 * Returns the id of this component.
 * @type {String}
 */
dvt.PropMap.prototype.getId = function() {
  return this.getProperty('id');
};


/**
 * Set the id of this component.
 * @param {String} id  ID for the component
 */
dvt.PropMap.prototype.setId = function(id) {
  this.setProperty('id', id);
};


/**
 * set a list of properties
 * @param {NamedNodeMap} attributes array
 */
dvt.PropMap.prototype.setProperties = function(attrArray) {
  for (var i = 0; i < attrArray.length; i++) {
    var attr = attrArray[i];
    if (attr.name && attr.value !== undefined) {
      this.setProperty(attr.name, attr.value);
    }
  }
};


/*-------------------------------------------------------------------------*/
/*   stamp                                                                 */
/*-------------------------------------------------------------------------*/


/**
 * Stamp out this template object only.
 * @param {} elcontext EL binding context
 * @return {DvtAfComponent} a new DvtAfComponent tree
 */
dvt.PropMap.prototype.stamp = function(elcontext) {

  // create a new DvtAfComponent object of the same type
  var result = new this.constructor();

  // copy properties
  var newProps = {};
  //   var regexp = /#{([^\}]*)}/g;
  for (var attr in this._props) {
    //TODO: test for string
    if (this._props[attr] && this._props[attr].replace) {
      newProps[attr] = this._props[attr].replace(dvt.PropMap.REGEXP,
          function(str, bindVar) {
            if (elcontext && elcontext[bindVar] !== undefined) {
              return elcontext[bindVar];
            }
            return str;
          }
          );
    } else {
      newProps[attr] = this._props[attr];
    }
  }

  result._props = newProps;
  return result;
};


/**
 * Convert an attribute array of a EL node to an EL context object
 * @param {dvt.XmlNode} xmlNode The EL xml node
 */
dvt.PropMap.toELContext = function(xmlNode) {
  var arr = xmlNode.getAttributes();
  var prop;
  var obj = {};
  for (var i = 0; i < arr.length; i++) {
    prop = arr[i];
    obj[prop.name] = prop.value;
  }
  return obj;
};

// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * usage
 * dvt.ImageLoader.loadImage("pic.png", function(image) {
 *   alert(image.width);
 *   alert(image.height);
 * });
 *
 */


/**
 * dvt.ImageLoader
 */
dvt.ImageLoader = {};

dvt.Obj.createSubclass(dvt.ImageLoader, dvt.Obj);


/**
 * Load an image.
 *
 * @param {dvt.Context} context The context object
 * @param src URL of the image to load
 * @param onComplete function to call when the image is loaded
 *
 * @return image if image is already loaded and onComplete
 *         function is null, otherwise null
 */
dvt.ImageLoader.loadImage = function(context, src, onComplete) {

  var loader = context.getImplFactory().getImageLoader();
  return loader.loadImage(src, onComplete);

};


// Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.


/**
 * JSON utilities.
 * @class
 */
dvt.JsonUtils = new Object();

dvt.Obj.createSubclass(dvt.JsonUtils, dvt.Obj);


/**
 * Returns a deep clone of the object.
 * @param {object} obj The object to clone.
 * @param {function} keyFunc An optional boolean-valued function that will be called for each key.  If the function returns false, the key will not be copied over
 * @param {object=} noClone List of keys to not clone.
 * @return {object} The clone.
 */
dvt.JsonUtils.clone = function(obj, keyFunc, noClone) {
  if (obj == null)
    return null;
  var ret = null;

  if (obj instanceof Array) {
    ret = [];

    // Loop through and copy the Array
    for (var i = 0; i < obj.length; i++) {
      if (dvt.JsonUtils._isDeepClonable(obj[i])) // deep clone objects
        ret[i] = dvt.JsonUtils.clone(obj[i], keyFunc);
      else // copy values
        ret[i] = obj[i];
    }
  }
  else if (obj instanceof dvt.CSSStyle) {
    ret = obj.clone();
  }
  else if (obj instanceof Date) { // convert Date to time millis
    ret = obj.getTime();
  }
  else if (dvt.JsonUtils._isClonableObject(obj)) {
    ret = {};

    // Loop through all properties of the object
    for (var key in obj) {
      if (!keyFunc || keyFunc(key)) {
        var value = obj[key];
        if (!(noClone && noClone[key] == true) && dvt.JsonUtils._isDeepClonable(value) && key != '_widgetConstructor') { // deep clone objects
          var subNoClone = noClone ? noClone[key] : null;
          ret[key] = dvt.JsonUtils.clone(value, keyFunc, subNoClone);
        }
        else // copy values
          ret[key] = value;
      }
    }
  }

  return ret;
};


/**
 * Returns a new object with the merged properties of the given objects.  Properties
 * in the first object take precedence.
 * @param {object} a
 * @param {object} b
 * @param {object=} noClone an object of keys not to be cloned.
 * @return {object} A new object containing the merged properties.
 */
dvt.JsonUtils.merge = function(a, b, noClone) {
  // Clone so that contents aren't modified
  var one = dvt.JsonUtils.clone(a, null, noClone);
  var two = dvt.JsonUtils.clone(b, null, noClone);
  if (one == null)
    return two;
  else if (two == null)
    return one;
  else {
    dvt.JsonUtils._copy(one, two);
    return two;
  }
};


/**
 * Copys the properties from the first object onto the second.
 * @param {object} a The source of the properties to copy.
 * @param {object} b The destination of the copied properties.
 * @private
 */
dvt.JsonUtils._copy = function(a, b) {
  for (var key in a) {
    var value = a[key];
    if ((value && (value instanceof Array)) || key == '_widgetConstructor') {
      // Copy the array over, since we don't want arrays to be merged
      // We also don't want the widget constructor to be copied/cloned
      b[key] = value;
    }
    else if (b[key] && (b[key] instanceof dvt.CSSStyle)) {
      // If an object is defined as CSS in the base object, merge the CSS
      if (value instanceof dvt.CSSStyle)
        b[key].merge(value);
      else // value is String
        b[key].merge(new dvt.CSSStyle(value));
    }
    else if (dvt.JsonUtils._isDeepClonable(value)) {
      // Deep clone if object exists in b, copy otherwise
      if (b[key])
        dvt.JsonUtils._copy(value, b[key]);
      else
        b[key] = value;
    }
    else
      b[key] = value;
  }
};

/**
 * Checks the type of an object and returns whether it is deep clonable
 * @param {Object} obj The object to check the type of
 * @return {boolean} Whether the object is deep clonable
 * @private
 */
dvt.JsonUtils._isDeepClonable = function(obj) {
  if (typeof obj == 'undefined')
    return false;
  else
    return (obj instanceof Object) && !(obj instanceof Boolean) && !(obj instanceof String) && !(obj instanceof Number) && !(obj instanceof Function) && !(obj.then);
};

/**
 * Checks the type of an object and returns whether it is supported for cloning. Returns false if object is not a JavaScript Object.
 * @param {Object} obj The object to check the type of
 * @return {boolean} Whether the object is supported
 * @private
 */
dvt.JsonUtils._isClonableObject = function(obj) {
  if (obj instanceof Object) {
    if (obj.then) // Promise
      return false;
    else if (obj.jquery) // JQuery Object
      return false;
    else if (typeof NodeList != 'undefined' && obj instanceof NodeList) // DOM NodeList
      return false;
    else if (typeof Node != 'undefined' && obj instanceof Node) // DOM objects
      return false;
    else
      return true;
  }
  return false;
};
/**
 * Abstract class for wrapper classes for native DOM events.
 * Internal events like dvt.ScrollEvent/dvt.ResizeEvent that do not wrap native DOM events should not extend this class.
 * @constructor
 */
dvt.BaseEvent = function() {};

dvt.Obj.createSubclass(dvt.BaseEvent, dvt.Obj);


/**
 * Object initializer
 * @param {Object} event The native event
 * @protected
 */
dvt.BaseEvent.prototype.Init = function(event)
{
  this.type = event.type;

  // Adding the string version to make it easier to refactor the events
  this['type'] = this.type;

  // Find the dvt.Obj corresponding to the event target
  this.target = dvt.BaseEvent.FindDisplayable(event.target);
  this._isPropagationStopped = false;
  this._event = event;
};


/**
 * Returns the native event that we are wrapping
 * @return {Object} The native event that we are wrapping
 */
dvt.BaseEvent.prototype.getNativeEvent = function() {
  return this._event;
};


/**
 * Prevents the default browser action that the native event would have triggered
 */
dvt.BaseEvent.prototype.preventDefault = function() {
  if (this._event.cancelable)
    this._event.preventDefault();
};


/**
 * Stops propagation of the native event in the browser's event bubbling phase.
 */
dvt.BaseEvent.prototype.stopPropagation = function() {
  if (this._event.stopPropagation)
    this._event.stopPropagation();
  this._event.cancelBubble = true;
  this._event.cancel = true;
  this._event.returnValue = false;
  this._isPropagationStopped = true;
};


/**
 * Checks whether event propagation was stopped
 * @return {boolean}
 */
dvt.BaseEvent.prototype.isPropagationStopped = function() {
  return this._isPropagationStopped;
};


/**
 * Returns the event type for this event.
 * @return {string} The event type for this event.
 */
dvt.BaseEvent.prototype.getType = function() {
  return this.type;
};

/**
 * Given an SVG DOM target, returns the corresponding dvt.Displayable.
 * @param {DOMElement} target The original DOM element target
 * @return {dvt.Displayable} The corresponding displayable, if any.
 * @protected
 */
dvt.BaseEvent.FindDisplayable = function(target) {
  while (target) {
    // If this object has a displayable, return it
    if (target._obj && target._obj.getObj && target._obj.getObj())
      return target._obj.getObj();
    else // Otherwise look at the parent
      target = target.parentNode;
  }

  return null;
};
/**
 * Base class for component level events.
 * @class The base class for component level events.
 * @constructor
 */
dvt.BaseComponentEvent = function() {};

dvt.Obj.createSubclass(dvt.BaseComponentEvent, dvt.Obj);


dvt.BaseComponentEvent.CLIENT_ROW_KEY = 'clientRowKey';


/**
 * @param {string} type The event type for this event.
 * @protected
 */
dvt.BaseComponentEvent.prototype.Init = function(type) {
  this._type = type;

  // TEMP: Adding so that we can check for event type both ways until this class is removed.
  this['type'] = type;
};


/**
 * Returns the event type for this event.
 * @return {string} The event type for this event.
 */
dvt.BaseComponentEvent.prototype.getType = function() {
  return this._type;
};

/**
 * Add an additional parameter (key, value) to this event (ex clientRowKey)
 * @param {String} paramKey parameter key
 * @param {String} paramValue parameter value
 */
dvt.BaseComponentEvent.prototype.addParam = function(paramKey, paramValue) {
  if (! this._paramKeys) {
    this._paramKeys = [];
    this._paramValues = [];
  }

  this._paramKeys.push(paramKey);
  this._paramValues.push(paramValue);

  // TEMP: Apply the params onto the object until this class is removed.
  this[paramKey] = paramValue;
};


/**
 * Get parameter value in this event
 * @param {String} paramKey parameter key
 * @return {String} paramValue parameter value
 */
dvt.BaseComponentEvent.prototype.getParamValue = function(paramKey) {
  if (! paramKey || ! this._paramKeys || ! this._paramValues) {
    return null;
  }

  var index = -1;
  for (var i = 0; i < this._paramKeys.length; i++) {
    if (this._paramKeys[i] == paramKey) {
      index = i;
      break;
    }
  }

  if (index != -1) {
    return this._paramValues[index];
  }

  // TEMP: Look for the key on the object.
  return this[paramKey];
};




// Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * @constructor
 * Platform independent class for Focus Events. This class roughly follows the DOM Level 3 API.
 * @param {FocusEvent} event The native FocusEvent
 */
var DvtFocusEvent = function(event) 
{
  this.Init(event);
};

dvt.Obj.createSubclass(DvtFocusEvent, dvt.BaseEvent);

/**
 * Focus event key
 */
DvtFocusEvent.FOCUS = dvt.Obj.defineConstant('focus');
/**
 * Focus in event key
 */
DvtFocusEvent.FOCUSIN = dvt.Obj.defineConstant('focusin');
/**
 * Focus out event key
 */
DvtFocusEvent.FOCUSOUT = dvt.Obj.defineConstant('focusout');
/**
 * Blur event key
 */
DvtFocusEvent.BLUR = dvt.Obj.defineConstant('blur');

/**
 * Object initializer.
 * @param {FocusEvent} event The native FocusEvent
 * @protected
 */
DvtFocusEvent.prototype.Init = function(event)
{
  DvtFocusEvent.superclass.Init.call(this, event);
  this.bubbles = event.bubbles;
  this.cancelable = event.cancelable;
  this.view = event.view;
  // Find the dvt.Obj corresponding to the event target
  if (event.relatedTarget != null)
    this.relatedTarget = dvt.BaseEvent.FindDisplayable(event.relatedTarget);
};
/**
 * Platform independent class for Keyboard Events.
 * @constructor
 * @param {KeyboardEvent} event The DOM KeyboardEvent
 */
dvt.KeyboardEvent = function(event)
{
  this.Init(event);
};

dvt.Obj.createSubclass(dvt.KeyboardEvent, dvt.BaseEvent);

// Constants for keyboard event types
//: indirectly assign the value so the closure compiler will abbreviate references to the constant

/** Key down event type **/
dvt.KeyboardEvent.KEYDOWN = dvt.Obj.defineConstant('keydown');
/** Key up event type **/
dvt.KeyboardEvent.KEYUP = dvt.Obj.defineConstant('keyup');

/** Key press event type **/
dvt.KeyboardEvent.KEYPRESS = dvt.Obj.defineConstant('keypress');

/** Tab key **/
dvt.KeyboardEvent.TAB = 9;
/** Enter key **/
dvt.KeyboardEvent.ENTER = 13;
/** Shift key **/
dvt.KeyboardEvent.SHIFT = 16;
/** Control key **/
dvt.KeyboardEvent.CONTROL = 17;
/** HOME key code **/
dvt.KeyboardEvent.HOME = 36;
/** END key code **/
dvt.KeyboardEvent.END = 35;
/** Escape key **/
dvt.KeyboardEvent.ESCAPE = 27;
/** Space key **/
dvt.KeyboardEvent.SPACE = 32;
/** Page up key **/
dvt.KeyboardEvent.PAGE_UP = 33;
/** Page down key **/
dvt.KeyboardEvent.PAGE_DOWN = 34;
/** Up arrow key **/
dvt.KeyboardEvent.UP_ARROW = 38;
/** Down arrow key **/
dvt.KeyboardEvent.DOWN_ARROW = 40;
/** Delete key **/
dvt.KeyboardEvent.DELETE = 46;
/** Left arrow key **/
dvt.KeyboardEvent.LEFT_ARROW = 37;
/** Right arrow key **/
dvt.KeyboardEvent.RIGHT_ARROW = 39;
/** Open bracket key **/
dvt.KeyboardEvent.OPEN_BRACKET = 219;
/** Close bracket key **/
dvt.KeyboardEvent.CLOSE_BRACKET = 221;
/** Back slash key **/
dvt.KeyboardEvent.BACK_SLASH = 220;
/** Forward slash key **/
dvt.KeyboardEvent.FORWARD_SLASH = 191;
/** Standard 0 key code **/
dvt.KeyboardEvent.ZERO = 48;
/** Numpad 0 key code **/
dvt.KeyboardEvent.NUMPAD_ZERO = 96;
/** Standard 1 key code **/
dvt.KeyboardEvent.ONE = 49;
/**  Numpad 1 key code **/
dvt.KeyboardEvent.NUMPAD_ONE = 97;
/** Standard 2 key code **/
dvt.KeyboardEvent.TWO = 50;
/** Numpad 2 key code **/
dvt.KeyboardEvent.NUMPAD_TWO = 98;
/** Standard 3 key code **/
dvt.KeyboardEvent.THREE = 51;
/** Numpad 3 key code **/
dvt.KeyboardEvent.NUMPAD_THREE = 99;
/** Standard 4 key code **/
dvt.KeyboardEvent.FOUR = 52;
/** Numpad 4 key code **/
dvt.KeyboardEvent.NUMPAD_FOUR = 100;
/** Standard 5 key code **/
dvt.KeyboardEvent.FIVE = 53;
/** Numpad 5 key code **/
dvt.KeyboardEvent.NUMPAD_FIVE = 101;
/** Standard 6 key code **/
dvt.KeyboardEvent.SIX = 54;
/** Plus key **/
dvt.KeyboardEvent.NUMPAD_PLUS = 107;
/** Minus key **/
dvt.KeyboardEvent.NUMPAD_MINUS = 109;
/** Chrome/safari plus key **/
dvt.KeyboardEvent.WEBKIT_PLUS = 187;
/** Chrome/safari minus key **/
dvt.KeyboardEvent.WEBKIT_MINUS = 189;
/** Firefox plus key **/
dvt.KeyboardEvent.GECKO_PLUS = 61;
/** Firefox minus key **/
dvt.KeyboardEvent.GECKO_MINUS = 173;
/** Chrome/Safari Semicolon key code **/
dvt.KeyboardEvent.WEBKIT_SEMICOLON = 186;
/** Firefox Semicolon key code **/
dvt.KeyboardEvent.GECKO_SEMICOLON = 59;
/** Key code for letter A key **/
dvt.KeyboardEvent.A = 65;
/** Key code for letter F key **/
dvt.KeyboardEvent.F = 70;
/** Key code for letter L key **/
dvt.KeyboardEvent.L = 76;
/** Key code for letter M key **/
dvt.KeyboardEvent.M = 77;
/** Key code for letter N key **/
dvt.KeyboardEvent.N = 78;
/** Period key **/
dvt.KeyboardEvent.PERIOD = 190;
/** Numpad period key **/
dvt.KeyboardEvent.NUMPAD_PERIOD = 110;
/** Single quote key **/
dvt.KeyboardEvent.SINGLE_QUOTE = 222;
/** Star key **/
dvt.KeyboardEvent.STAR = 56;
/** Numpad star key **/
dvt.KeyboardEvent.NUMPAD_STAR = 144;
/** Open angled bracket key **/
dvt.KeyboardEvent.OPEN_ANGLED_BRACKET = 188;
/** Closed angled bracket key **/
dvt.KeyboardEvent.CLOSE_ANGLED_BRACKET = 190;
/** Grave accent key **/
dvt.KeyboardEvent.GRAVE_ACCENT = 192;

/**
 * Object initializer.  This essentially mirrors the DOM initKeyboardEvent() API
 * @param {KeyboardEvent} event The DOM KeyboardEvent
 * @protected
 */
dvt.KeyboardEvent.prototype.Init = function(event) {
  dvt.KeyboardEvent.superclass.Init.call(this, event);
  this.bubbles = event.bubbles;
  this.cancelable = event.cancelable;
  this.view = event.view;
  this.charCode = event.charCode;
  this.keyCode = event.keyCode;
  this.location = event.location;
  this.ctrlKey = event.ctrlKey || event.metaKey; //treat the meat key same as ctrl;
  this.altKey = event.altKey;
  this.shiftKey = event.shiftKey;
  this.repeat = event.repeat;
  this.locale = event.locale;
};


/**
 * Utility method that returns true if the keyboard event is a plus keystroke. Handy because keycodes differ
 * across different render kits
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} true if the event is a "+" keystroke
 */
dvt.KeyboardEvent.isPlus = function(event)
{
  var keyCode = event.keyCode;
  if (keyCode == dvt.KeyboardEvent.NUMPAD_PLUS)
    return true;

  if (dvt.Agent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    if (keyCode == dvt.KeyboardEvent.GECKO_PLUS && event.shiftKey)
      return true;
    else
      return false;
  }
  else
  {
    if (keyCode == dvt.KeyboardEvent.WEBKIT_PLUS && event.shiftKey)
      return true;
    else
      return false;
  }
  return false;
};


/**
 * Utility method that returns true if the keyboard event is a equals keystroke. Handy because keycodes differ
 * across different render kits
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} true if the event is a "+" keystroke
 */
dvt.KeyboardEvent.isEquals = function(event)
{
  var keyCode = event.keyCode;

  if (dvt.Agent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    if (keyCode == dvt.KeyboardEvent.GECKO_PLUS && !event.shiftKey)
      return true;
    else
      return false;
  }
  else
  {
    if (keyCode == dvt.KeyboardEvent.WEBKIT_PLUS && !event.shiftKey)
      return true;
    else
      return false;
  }
  return false;
};


/**
 * Utility method that returns true if the keyboard event is a minus keystroke. Handy because keycodes differ
 * across different render kits
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} true if the event is a "-" keystroke
 */
dvt.KeyboardEvent.isMinus = function(event)
{
  var keyCode = event.keyCode;

  if (keyCode == dvt.KeyboardEvent.NUMPAD_MINUS)
    return true;

  if (dvt.Agent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    if (keyCode == dvt.KeyboardEvent.GECKO_MINUS && !event.shiftKey)
      return true;
    else
      return false;
  }
  else
  {
    if (keyCode == dvt.KeyboardEvent.WEBKIT_MINUS && !event.shiftKey)
      return true;
    else
      return false;
  }
  return false;
};


/**
 * Utility method that returns true if the keyboard event is an underscore keystroke. Handy because keycodes differ
 * across different render kits
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} true if the event is a "_" keystroke
 */
dvt.KeyboardEvent.isUnderscore = function(event)
{
  var keyCode = event.keyCode;

  if (dvt.Agent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    if (keyCode == dvt.KeyboardEvent.GECKO_MINUS && event.shiftKey)
      return true;
    else
      return false;
  }
  else
  {
    if (keyCode == dvt.KeyboardEvent.WEBKIT_MINUS && event.shiftKey)
      return true;
    else
      return false;
  }
  return false;
};
/**
 * Utility method that returns true if the keyboard event is a semicolon keystroke. Handy because keycodes differ
 * across different render kits
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} true if the event is a ";" keystroke
 */
dvt.KeyboardEvent.isSemicolon = function(event)
{
  var keyCode = event.keyCode;
  if (dvt.Agent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    return keyCode == dvt.KeyboardEvent.GECKO_SEMICOLON;
  }
  else
  {
    return keyCode == dvt.KeyboardEvent.WEBKIT_SEMICOLON;
  }
};
/**
 * @constructor
 * Wrapper class for Mouse Events.  This class roughly follows the DOM Level 2 API.
 * @param {MouseEvent} event The DOM MouseEvent
 */
dvt.MouseEvent = function(event) 
{
  this.Init(event);
};

dvt.Obj.createSubclass(dvt.MouseEvent, dvt.BaseEvent);

// Constants for mouse event types
//: indirectly assign the value so the closure compiler will abbreviate references to the constant
/** @const **/
dvt.MouseEvent.CLICK = dvt.Obj.defineConstant('click');
/** @const **/
dvt.MouseEvent.DBLCLICK = dvt.Obj.defineConstant('dblclick');
/** @const **/
dvt.MouseEvent.MOUSEOVER = dvt.Obj.defineConstant('mouseover');
/** @const **/
dvt.MouseEvent.MOUSEOUT = dvt.Obj.defineConstant('mouseout');
/** @const **/
dvt.MouseEvent.MOUSEDOWN = dvt.Obj.defineConstant('mousedown');
/** @const **/
dvt.MouseEvent.MOUSEUP = dvt.Obj.defineConstant('mouseup');
/** @const **/
dvt.MouseEvent.MOUSEMOVE = dvt.Obj.defineConstant('mousemove');
/** @const **/
dvt.MouseEvent.MOUSEWHEEL = dvt.Obj.defineConstant('wheel');

/** @const **/
dvt.MouseEvent.RIGHT_CLICK_BUTTON = 2;


/**
 * Object initializer. This essentially mirrors the DOM initMouseEvent() API
 * @param {MouseEvent} event The DOM MouseEvent
 * @protected
 */
dvt.MouseEvent.prototype.Init = function(event) {
  dvt.MouseEvent.superclass.Init.call(this, event);
  // Find the dvt.Obj corresponding to the event target
  if (event.relatedTarget != null)
    this.relatedTarget = dvt.BaseEvent.FindDisplayable(event.relatedTarget);

  // Copy the remaining information
  this.button = event.button;
  this.ctrlKey = event.ctrlKey || event.metaKey;
  this.shiftKey = event.shiftKey;
  this.pageX = event.pageX;
  this.pageY = event.pageY;
  //: Flag indicates if the event is modified for Internet Explorer
  this._isEventModifiedForIE = false;

  if (event.wheelDeltaY != null)
    this.wheelDelta = event.wheelDeltaY / 40;
  else if (event.deltaY != null) {
    this.deltaMode = event.deltaMode;
    this.deltaY = event.deltaY;

    // Approximate the wheel delta from the deltaY and deltaMode
    if (event.deltaMode == event.DOM_DELTA_LINE)
      this.wheelDelta = -event.deltaY;
    else if (event.deltaMode == event.DOM_DELTA_PIXEL)
      this.wheelDelta = -event.deltaY / 15;
  }
  else if (event.wheelDelta != null)
    this.wheelDelta = event.wheelDelta / 40;
  else
    this.wheelDelta = event.detail;
};

/**
 * Modify the event for IE with the new event type and new target element
 * @param {string} newType  New MouseEvent type
 * @param {DOMElement} newTargetElement  New SVG DOM Target Element
 */
dvt.MouseEvent.prototype.modifyEventForIE = function(newType, newTargetElement) {
  //: Set the event type as newType, relatedTarget as current target and target as displayable of newTargetElement
  //This will target the event to newTargetElement and change the event type
  //Modify the event target only once because every dvt.MouseEvent instance has unique native event.
  //Doing this more than once will make relatedTarget and target same as displayable of newTargetElement
  if (!this._isEventModifiedForIE) {
    this.type = newType;
    this.relatedTarget = this.target;
    this.target = dvt.BaseEvent.FindDisplayable(newTargetElement);
    this._isEventModifiedForIE = true;
  }
};
/**
 * Wrapper class for Touch Events.
 * @param {TouchEvent} event The DOM TouchEvent
 * @constructor
 */
dvt.TouchEvent = function(event) {
  this.Init(event);
};

dvt.Obj.createSubclass(dvt.TouchEvent, dvt.BaseEvent);

// Constants for touch event types
//: indirectly assign the value so the closure compiler will abbreviate references to the constant
/** @const **/
dvt.TouchEvent.TOUCHSTART = dvt.Obj.defineConstant('touchstart');
/** @const **/
dvt.TouchEvent.TOUCHMOVE = dvt.Obj.defineConstant('touchmove');
/** @const **/
dvt.TouchEvent.TOUCHEND = dvt.Obj.defineConstant('touchend');
/** @const **/
dvt.TouchEvent.TOUCHCANCEL = dvt.Obj.defineConstant('touchcancel');

/**
 * @param {TouchEvent} event The DOM TouchEvent
 * @protected
 */
dvt.TouchEvent.prototype.Init = function(event) {
  dvt.TouchEvent.superclass.Init.call(this, event);
  // Convert touchcancel to touchend
  if (event.type == dvt.TouchEvent.TOUCHCANCEL) {
    this.type = dvt.TouchEvent.TOUCHEND;
  }
  this.touches = dvt.TouchEvent.createTouchArray(event.touches);
  this.targetTouches = dvt.TouchEvent.createTouchArray(event.targetTouches);
  this.changedTouches = dvt.TouchEvent.createTouchArray(event.changedTouches);

  this._touchManager = null;
};

/**
 * Blocks a touch hold event
 */
dvt.TouchEvent.prototype.blockTouchHold = function() {
  this.getNativeEvent()._touchHoldBlocked = true;
};

/**
 * Returns true if this is the initial touch event
 * @return {boolean}
 */
dvt.TouchEvent.prototype.isInitialTouch = function() {
  return (this.touches.length - this.changedTouches.length) == 0;
};

/**
 * Returns true if a touch hold event has been blocked and false otherwise.
 * @return {boolean}
 */
dvt.TouchEvent.prototype.isTouchHoldBlocked = function() {
  return (this.getNativeEvent()._touchHoldBlocked) ? true : false;
};

/**
 * Creates an array of DvtTouchEvents from native TouchEvents
 * @param {Array} nativeTouchArray The array of native touch events
 * @return {Array}
 */
dvt.TouchEvent.createTouchArray = function(nativeTouchArray) {
  var touches = new Array();
  for (var i = 0; i < nativeTouchArray.length; i++) {
    var nativeTouch = nativeTouchArray[i];
    var touch = new dvt.Touch(nativeTouch);
    touches.push(touch);
  }
  return touches;
};

/**
 * Prevents further propagation of the current event
 */
dvt.TouchEvent.prototype.stopPropagation = function() {
  dvt.TouchEvent.superclass.stopPropagation.call(this);
  if (this._touchManager)
    this._touchManager.postEventBubble(this);
};


/**
 * Sets a touch manager object
 * @param {dvt.TouchManager} touchManager The touch manager object for the event
 */
dvt.TouchEvent.prototype.setTouchManager = function(touchManager) {
  this._touchManager = touchManager;
};
/**
 * @constructor
 * Wrapper class providing access to a Touch.
 * @extends {dvt.Obj}
 * @class dvt.Touch
 * <p>The supported fields are:
 * <ul>
 * <li>clientX</li>
 * <li>clientY</li>
 * <li>screenX</li>
 * <li>screenY</li>
 * <li>pageX</li>
 * <li>pageY</li>
 * <li>target</li>
 * <li>identifier</li>
 * </ul>
 * <p>
 */
dvt.Touch = function(touch) {
  this.Init(touch);
};

dvt.Obj.createSubclass(dvt.Touch, dvt.Obj);


/**
 * @protected
 * @param {Touch} the DOM Touch
 */
dvt.Touch.prototype.Init = function(touch) {
  this.clientX = touch.clientX;
  this.clientY = touch.clientY;
  this.screenX = touch.screenX;
  this.screenY = touch.screenY;
  this.pageX = touch.pageX;
  this.pageY = touch.pageY;
  this.target = touch.target;
  this.identifier = (touch.identifier == null || isNaN(touch.identifier)) ? 1 : touch.identifier;
};
/**
 * @constructor
 * Keeps track of the current state of touches and fires higher-level logical events
 * @extends {dvt.Obj}
 * @class dvt.TouchManager
 */
dvt.TouchManager = function(id, context) {
  this.Init(id, context);
};

dvt.Obj.createSubclass(dvt.TouchManager, dvt.Obj);

dvt.TouchManager.TOUCH_MODE = 'mode';
dvt.TouchManager.TOUCH_MODE_DEFAULT = 'defaultMode';
dvt.TouchManager.TOUCH_MODE_LONG_PRESS = 'longPressMode';

dvt.TouchManager.PREV_HOVER_OBJ = 'prevHoverObj';

dvt.TouchManager.HOVER_TOUCH_KEY = 'hoverTouch';


/**
 * @protected
 * Helper method called by the constructor to initialize this object.
 * @param {string} id Id for the this TouchManager instance
 * @param {dvt.Context} context An application specific context
 */
dvt.TouchManager.prototype.Init = function(id, context) {
  this._context = context;
  this._id = id;

  // Total number of touches on the screen
  this._touchCount = 0;

  // Single timer for touch hold
  this._touchHoldTimer = new dvt.Timer(this._context, 200, this._handleTouchHoldStartTimer, this);
  this._blockTouchHold = false;

  // Stored mapping for history information on touches
  this._touchMap = new Object();

  // Save information on touches which are already associated with listeners
  this._savedTouchInfo = new Array();

  // internal listener to translate to hover
  this._addTouchHoldMoveEventListener(this._onTouchHoldHover, this);

  // Single timer for double tap
  // We are using 600 ms because 300ms is too fast in VoiceOver mode to recognize the second tap.
  // Do not change this value without checking VoiceOver.
  this._doubleTapTimer = new dvt.Timer(this._context, 600, this._handleDoubleTapTimer, this, 1);

  // dvt.Touch event
  this._dvtTouchEvent = null;

};


/**
 * Block touch hold event. We might want to prevent touch hold during zoom oparation.
 */
dvt.TouchManager.prototype.blockTouchHold = function() {
  this._stopTouchHoldTimer();
  this._blockTouchHold = true;
};


/**
 * Releases touch hold block.
 */
dvt.TouchManager.prototype.unblockTouchHold = function() {
  this._blockTouchHold = false;
};

dvt.TouchManager.prototype._addTouchHoldMoveEventListener = function(listener, obj) {
  this.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOLD_START_TYPE, listener, obj);
  this.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOLD_MOVE_TYPE, listener, obj);
  this.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOLD_END_TYPE, listener, obj);
};


/**
 * Internal touch hold listener to translate to hover events
 * @private
 * @param {dvt.ComponentTouchEvent} evt A touch hold event.
 */
dvt.TouchManager.prototype._onTouchHoldHover = function(evt) {
  var type = evt.getType();
  var touch = evt.touch;
  var nativeEvt = evt.getNativeEvent();

  var info = this._touchMap[touch.identifier];

  var obj = evt.target;
  if (type == dvt.ComponentTouchEvent.TOUCH_HOLD_END_TYPE) {
    var hoverEvt = new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_END_TYPE, touch, obj, null, nativeEvt);
    hoverEvt._isCancelEvent = this._isCancelEvent;

    if (obj != null)
      this.FireListener(new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, touch, obj, null, nativeEvt));
    info[dvt.TouchManager.PREV_HOVER_OBJ] = null;

    this.FireListener(hoverEvt);
  } else if (type == dvt.ComponentTouchEvent.TOUCH_HOLD_START_TYPE) {
    info[dvt.TouchManager.PREV_HOVER_OBJ] = null;
    if (obj != null)
      this.FireListener(new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, touch, obj, null, nativeEvt));
    info[dvt.TouchManager.PREV_HOVER_OBJ] = obj;

    this.FireListener(new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_START_TYPE, touch, obj, null, nativeEvt));
  } else if (type == dvt.ComponentTouchEvent.TOUCH_HOLD_MOVE_TYPE) {
    this._fireHoverOverOutEvents(obj, info[dvt.TouchManager.PREV_HOVER_OBJ], touch, nativeEvt);
    info[dvt.TouchManager.PREV_HOVER_OBJ] = obj;
    this.FireListener(new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE, touch, obj, null, nativeEvt));

  }
};

dvt.TouchManager.prototype._getObjFromTouch = function(touch) {
  var obj = null;

  if (touch) {
    // If the rendering impl doesn't define document utils for finding the element at a point, don't continue
    var documentUtils = this._context.getDocumentUtils();
    if (documentUtils) {
      obj = documentUtils.elementFromTouch(touch);
    }
  }
  return obj;
};

/**
 * @private
 * Fire logical hover events
 * @param {object} currentObj  Current element that triggered the event
 * @param {object} prevHoverObj  Previous element that triggered the event
 * @param {dvt.Touch} touch A single point of contact with the surface
 * @param {TouchEvent} nativeEvt  Native touch event
 */
dvt.TouchManager.prototype._fireHoverOverOutEvents = function(currentObj, prevHoverObj, touch, nativeEvt) {
  if (prevHoverObj != currentObj) {
    if (prevHoverObj != null)
      this.FireListener(new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, touch, prevHoverObj, currentObj, nativeEvt));
    if (currentObj != null)
      this.FireListener(new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, touch, currentObj, prevHoverObj, nativeEvt));
  }
};


/**
 * Adds an event listener.
 * @param {string} type One of the dvt.ComponentTouchEvent types
 * @param {function} listener Listener to add
 * @param {object} obj Optional object on which the listener function is defined
 */
dvt.TouchManager.prototype.addTouchEventListener = function(type, listener, obj) {
  // Store a reference to the listener
  var listenersArray = this._getListeners(type, true);
  listenersArray.push(listener);
  listenersArray.push(obj);
};


/**
 * Removes an event listener.
 * @param {string} type One of the dvt.ComponentTouchEvent types
 * @param {function} listener Listener to remove
 * @param {object} obj Optional object on which the listener function is defined
 */
dvt.TouchManager.prototype.removeTouchEventListener = function(type, listener, obj) {
  // Remove the listener
  var listenersArray = this._getListeners(type, false);
  if (listenersArray) {
    for (var i = 0; i < listenersArray.length; i += 2) {
      if (listenersArray[i] === listener &&
          listenersArray[i + 1] === obj) {
        listenersArray.splice(i, 2);
        break;
      }
    }
  }
};


/**
 * Returns the listeners of the given event type and capture mode.
 **/
dvt.TouchManager.prototype._getListeners = function(type, createNew) {
  // First find the object where the listener arrays are stored
  if (!this._listenerObj) {
    if (createNew) {
      this._listenerObj = {
      };
    }
    else {
      return null;
    }
  }

  // Then find the array for this event type, creating if necessary
  var eventKey = type;
  var listenersArray = this._listenerObj[eventKey];
  if (!listenersArray && createNew) {
    listenersArray = [];
    this._listenerObj[eventKey] = listenersArray;
  }

  return listenersArray;
};


/**
 * Notifies all applicable event listeners of the given event.
 **/
dvt.TouchManager.prototype.FireListener = function(event) {
  var listenersArray = this._getListeners(event.getType(), false);
  if (listenersArray) {
    for (var i = 0; i < listenersArray.length; i += 2) {
      var obj = listenersArray[i + 1];
      listenersArray[i].call(obj, event);
    }
  }
};

/**
 * Start touch hold
 * @param {dvt.TouchEvent} evt  Wrapper for the native event
 */
dvt.TouchManager.prototype.startTouchHold = function(evt) {
  var touchid = this._startSingleFingerTouchId;
  if (touchid != null && !isNaN(touchid)) {
    var info = this._touchMap[touchid];
    if (info) {

      var touchStartObj = info['startTarget'];
      var startTouch = info['startTouch'];
      var nativeEvt = evt.getNativeEvent();

      // If there are any immediate touches for this id, end it since touch hold has started
      var matches = this._findMatches('touchId', touchid);
      for (var i = 0; i < matches.length; i++) {
        var savedInfo = matches[i];
        var touchObj = savedInfo['touchObj'];
        var touchId = savedInfo['touchId'];
        if (touchObj != dvt.TouchManager.HOVER_TOUCH_KEY) {
          var touchInfo = this.getTouchInfo(touchId);
          var touch = touchInfo['startTouch'];
          this.performAssociatedTouchEnd(touch, touchObj, null);
        }
      }

      // Save mode on touch
      info[dvt.TouchManager.TOUCH_MODE] = dvt.TouchManager.TOUCH_MODE_LONG_PRESS;
      this.saveProcessedTouch(touchid, dvt.TouchManager.HOVER_TOUCH_KEY, null, dvt.TouchManager.HOVER_TOUCH_KEY, dvt.TouchManager.HOVER_TOUCH_KEY, this.HoverMoveInternal, this.HoverEndInternal, this);

      var touchHoldStartEvent = new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOLD_START_TYPE, startTouch, touchStartObj, null, nativeEvt);
      this.FireListener(touchHoldStartEvent);

    }
  }
};

/**
 * Execute listeners for logical events.
 * Note that there is no way to bubble logical events in the framework at the moment
 * @param {dvt.TouchEvent} touchEvent  Dvt touch event
 */
dvt.TouchManager.prototype.fireLogicalEvents = function(touchEvent) {
  var type = touchEvent.type;
  var nativeEvent = touchEvent.getNativeEvent();
  if (type == dvt.TouchEvent.TOUCHSTART) {
    if (!touchEvent.isTouchHoldBlocked()) {
      this.processAssociatedTouchAttempt(touchEvent, dvt.TouchManager.HOVER_TOUCH_KEY, this.HoverStartInternal, this);
    }
    if (this._doubleTapAttemptStarted) {
      touchEvent.preventDefault();
    }
  } else if (type == dvt.TouchEvent.TOUCHMOVE) {
    this.processAssociatedTouchMove(touchEvent, dvt.TouchManager.HOVER_TOUCH_KEY);
  } else if (type == dvt.TouchEvent.TOUCHEND) {
    this.processAssociatedTouchEnd(touchEvent, dvt.TouchManager.HOVER_TOUCH_KEY);
  }

  if (type == dvt.TouchEvent.TOUCHEND) {
    var changedTouches = this._getStoredTouches(touchEvent.changedTouches);
    for (var i = 0; i < changedTouches.length; i++) {
      var touch = changedTouches[i];
      var identifier = touch.identifier;
      var info = this.getTouchInfo(identifier);

      var targetObj = info['currentObj'];

      if (info[dvt.TouchManager.TOUCH_MODE] != dvt.TouchManager.TOUCH_MODE_LONG_PRESS) {
        if (info['fireClick']) {
          var touchClickEvt = new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_CLICK_TYPE, touch, targetObj, null, nativeEvent);
          touchClickEvt.touchEvent = touchEvent;
          this.FireListener(touchClickEvt);

          if (this._doubleTapAttemptStarted) {
            var prevTapObj = this._doubleTapAttemptObj;
            this.resetDoubleTap();
            if (targetObj == prevTapObj) {
              var touchDblClickEvt = new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE, touch, targetObj, null, nativeEvent);
              touchDblClickEvt.touchEvent = touchEvent;
              this.FireListener(touchDblClickEvt);
            }
          } else {
            this.resetDoubleTap();
            this._doubleTapTimer.start();
            this._doubleTapAttemptStarted = true;
            this._doubleTapAttemptObj = targetObj;
          }
        }
      }
    }
  }
};

dvt.TouchManager.prototype.getTouchInfo = function(touchId) {
  return this._touchMap[touchId];
};


/**
 * Handler for the touch event. Starts timer for the potential hover event.
 * @param {dvt.TouchEvent} event Wrapper for the native event
 * @param {dvt.Touch} touch Touch object for the event
 * @protected
 */
dvt.TouchManager.prototype.HoverStartInternal = function(event, touch) {
  if (this._blockTouchHold)
    return;
  var identifier = touch.identifier;
  this._startSingleFingerTouchId = identifier;
  this._stopTouchHoldTimer();
  this._startTouchHoldTimer(event);
};

/**
 * Handler for the touch hover move
 * @param {dvt.TouchEvent} event Wrapper for the native event
 * @param {dvt.Touch} touch Touch object for the event
 * @protected
 */
dvt.TouchManager.prototype.HoverMoveInternal = function(event, touch) {
  var identifier = touch.identifier;
  var info = this.getTouchInfo(identifier);
  var targetObj = info['currentObj'];
  var touchHoldMoveEvent = new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOLD_MOVE_TYPE, touch, targetObj, null, event.getNativeEvent());
  this.FireListener(touchHoldMoveEvent);
  event.preventDefault();
};

/**
 * Handler for the touch hover end.
 * @param {dvt.TouchEvent} event Wrapper for the native event
 * @param {dvt.Touch} touch Touch object for the event
 * @protected
 */
dvt.TouchManager.prototype.HoverEndInternal = function(event, touch) {
  var identifier = touch.identifier;
  var info = this.getTouchInfo(identifier);
  var targetObj = info['currentObj'];
  var touchHoldEndEvent = new dvt.ComponentTouchEvent(dvt.ComponentTouchEvent.TOUCH_HOLD_END_TYPE, touch, targetObj, null, event.getNativeEvent());
  this.FireListener(touchHoldEndEvent);
  if (event)
    event.preventDefault();
};

/**
 * Reset touch hold
 */
dvt.TouchManager.prototype.resetTouchHold = function() {
  this._startSingleFingerTouchId = null;
  this._stopTouchHoldTimer();
};


/**
 * Updates state information for current touches before logical event "bubbles"
 * @param {dvt.TouchEvent} touchEvent Touch event
 */
dvt.TouchManager.prototype.preEventBubble = function(touchEvent) {
  if (touchEvent.setTouchManager)
    touchEvent.setTouchManager(this);

  var type = touchEvent.type;
  if (type == dvt.TouchEvent.TOUCHSTART) {
    this.processTouchStart(touchEvent);
  } else if (type == dvt.TouchEvent.TOUCHMOVE) {
    this.processTouchMove(touchEvent);
  } else if (type == dvt.TouchEvent.TOUCHEND) {
    this.processTouchEnd(touchEvent);
  }
};

// Updates state information after logical event is done "bubbling"
dvt.TouchManager.prototype.postEventBubble = function(touchEvent) {
  var type = touchEvent.type;

  if (type == dvt.TouchEvent.TOUCHSTART) {
  } else if (type == dvt.TouchEvent.TOUCHMOVE) {
  } else if (type == dvt.TouchEvent.TOUCHEND) {
    var changedTouches = this._getStoredTouches(touchEvent.changedTouches);
    for (var i = 0; i < changedTouches.length; i++)
    {
      var changedTouch = changedTouches[i];
      var identifier = changedTouch.identifier;

      delete this._touchMap[identifier];
      if (this._startSingleFingerTouchId == identifier) {
        this._startSingleFingerTouchId = null;
      }
      // Stop propagation may not allow touch manager to clear saved touch info.  Need to check for any remaining
      // info and remove
      var savedMatches = this._findMatches('touchId', identifier);
      for (var j = 0; j < savedMatches.length; j++) {
        var match = savedMatches[j];
        this.removeTooltipInfo(match['touchId'], match['touchObj']);
      }
    }
  }
};

dvt.TouchManager.prototype.saveProcessedTouch = function(touchId, touchObj, tooltipObjOverride, grouping, type, moveListener, endListener, listenerObj) {
  if (touchId != null && !isNaN(touchId)) {
    var info = dvt.TouchManager.createSavedTouchInfo(touchId, touchObj, tooltipObjOverride, grouping, type, moveListener, endListener, listenerObj);
    this._savedTouchInfo.push(info);
    return true;
  }
  return false;
};

dvt.TouchManager.prototype.saveProcessedTouchDefault = function(touchId, touchObj, tooltipObjOverride, grouping, type, listenerObj) {
  var movedListener = null;
  if (listenerObj['immediateTouchMoved'])
    movedListener = listenerObj['immediateTouchMoved'];
  var endListener = null;
  if (listenerObj['immediateTouchEnded'])
    endListener = listenerObj['immediateTouchEnded'];

  this.saveProcessedTouch(touchId, touchObj, tooltipObjOverride, grouping, type, movedListener, endListener, listenerObj);
};

dvt.TouchManager.prototype.processAssociatedTouch = function(event, uniqueKey, startListener, listenerObj) {
  var type = event.type;
  if (type == dvt.TouchEvent.TOUCHSTART) {
    this.processAssociatedTouchAttempt(event, uniqueKey, startListener, listenerObj);
  } else if (type == dvt.TouchEvent.TOUCHMOVE) {
    this.processAssociatedTouchMove(event, uniqueKey);
  } else if (type == dvt.TouchEvent.TOUCHEND) {
    this.processAssociatedTouchEnd(event, uniqueKey);
  }
};

// immediateTouchObj implements a defined interface for handling single touches on the object
dvt.TouchManager.prototype.processAssociatedTouchDefault = function(event, immediateTouchObj) {
  this.processAssociatedTouch(event, immediateTouchObj, immediateTouchObj['immediateTouchAttempted'], immediateTouchObj);
};

dvt.TouchManager.prototype.cancelTouchHold = function() {
  var uniqueKey = dvt.TouchManager.HOVER_TOUCH_KEY;
  var touchIds = this.getTouchIdsForObj(uniqueKey);
  for (var i = 0; i < touchIds.length; i++) {
    var touchId = touchIds[i];
    var info = this.getTouchInfo(touchId);
    var touch = info['startTouch'];
    if (touch) {
      this._isCancelEvent = true;
      this.performAssociatedTouchEnd(touch, uniqueKey, null);
      this._isCancelEvent = false;
      delete this._touchMap[touchId];
    }
  }

};

dvt.TouchManager.prototype.performAssociatedTouchEnd = function(touch, uniqueKey, event) {
  var identifier = touch.identifier;
  var savedInfo = this.getSavedTouchInfo(identifier, uniqueKey);
  if (savedInfo) {
    var listenerObj = savedInfo['listenerObj'];
    var endListener = savedInfo['endListener'];

    // Remove tooltip info first
    this.removeTooltipInfo(identifier, uniqueKey);
    if (endListener) {
      endListener.call(listenerObj, event, touch, savedInfo);
    }
  }
};

dvt.TouchManager.prototype.processAssociatedTouchAttempt = function(event, uniqueKey, startListener, listenerObj) {
  var touches = event.changedTouches;
  for (var i = 0; i < touches.length; i++) {
    var touch = touches[i];
    if (touch) {
      if (startListener)
        startListener.call(listenerObj, event, touch);
    }
  }
};

dvt.TouchManager.prototype.processAssociatedTouchMove = function(event, uniqueKey) {
  var touchIds = this.getTouchIdsForObj(uniqueKey);
  for (var i = 0; i < touchIds.length; i++) {
    var touchId = touchIds[i];
    if (touchId != null && !isNaN(touchId)) {
      var touch = dvt.TouchManager.getTouchById(touchId, this._getStoredTouches(event.changedTouches));
      if (touch) {
        var savedInfo = this.getSavedTouchInfo(touch.identifier, uniqueKey);
        if (savedInfo) {
          var listenerObj = savedInfo['listenerObj'];
          var moveListener = savedInfo['moveListener'];

          if (moveListener)
            moveListener.call(listenerObj, event, touch);

        }
      }
    }
  }
};

dvt.TouchManager.prototype.processAssociatedTouchEnd = function(event, uniqueKey) {
  var touchIds = this.getTouchIdsForObj(uniqueKey);
  for (var i = 0; i < touchIds.length; i++) {
    var touchId = touchIds[i];
    var touch = dvt.TouchManager.getTouchById(touchId, this._getStoredTouches(event.changedTouches));
    if (touch) {
      this.performAssociatedTouchEnd(touch, uniqueKey, event);
    }
  }
};

dvt.TouchManager.prototype._findMatch = function(matchProp, matchValue) {
  var idx = -1;
  for (var i = 0; i < this._savedTouchInfo.length; i++) {
    var info = this._savedTouchInfo[i];
    if (info[matchProp] == matchValue) {
      idx = i;
    }
  }
  return idx;
};
dvt.TouchManager.prototype._findMatches = function(matchProp, matchValue) {
  var results = new Array();
  for (var i = 0; i < this._savedTouchInfo.length; i++) {
    var info = this._savedTouchInfo[i];
    if (info[matchProp] == matchValue) {
      results.push(info);
    }
  }
  return results;
};



dvt.TouchManager.prototype.getSavedTouchInfo = function(touchId, uniqueKey) {
  var matches = this._findMatches('touchId', touchId);
  for (var i = 0; i < matches.length; i++) {
    var info = matches[i];
    if (info['touchObj'] == uniqueKey) {
      return info;
    }
  }
  return null;
};
dvt.TouchManager.prototype.containsTouchId = function(touchId) {
  var matches = this._findMatches('touchId', touchId);
  return matches.length > 0;
};

dvt.TouchManager.prototype.getTouchIdsForObj = function(touchObj) {
  var results = new Array();
  var matches = this._findMatches('touchObj', touchObj);
  for (var i = 0; i < matches.length; i++) {
    var info = matches[i];
    var touchId = info['touchId'];
    results.push(touchId);
  }
  return results;
};

dvt.TouchManager.prototype.removeTooltipInfo = function(touchId, uniqueKey) {
  var matches = this._findMatches('touchId', touchId);
  var removeObjects = new Array();
  for (var i = 0; i < matches.length; i++) {
    var info = matches[i];
    if (info['touchObj'] == uniqueKey) {
      removeObjects.push(info);
    }
  }
  for (var i = 0; i < removeObjects.length; i++) {
    var removeObj = removeObjects[i];
    var removeIdx = -1;
    for (var j = 0; j < this._savedTouchInfo.length; j++) {
      var info = this._savedTouchInfo[j];
      if (info == removeObj) {
        removeIdx = j;
      }
    }
    if (removeIdx != -1) {
      this._savedTouchInfo.splice(removeIdx, 1);
      if (this._savedTouchInfo.length == 0) {
        this._context.getTooltipManager().hideTooltip();
      }
    }
  }
};

dvt.TouchManager.prototype.setTooltipEnabled = function(touchId, enabled) {
  var tooltipInfoArray = this._savedTouchInfo;
  for (var i = 0; i < tooltipInfoArray.length; i++) {
    var tooltipInfo = tooltipInfoArray[i];
    var tooltipTouchId = tooltipInfo['touchId'];
    if (tooltipTouchId == touchId) {
      tooltipInfo['allowTooltips'] = enabled;
    }
  }
};

dvt.TouchManager.prototype.getTooltipInfo = function() {
  var tooltipInfoObj = new Object();
  var touchIds = new Array();
  var tooltipTarget = null;

  var firstGroup = null;
  var multipleGroups = false;

  var matches = this._findMatches('allowTooltips', true);
  for (var i = 0; i < matches.length; i++) {
    var tooltipInfo = matches[i];
    var touchId = tooltipInfo['touchId'];

    if (!firstGroup) {
      firstGroup = tooltipInfo['grouping'];
    } else {
      // Multiple groups are not supported for tooltips yet
      if (tooltipInfo['grouping'] != firstGroup) {
        multipleGroups = true;
      }
    }

    var tooltipObj;
    var touchInfo = this._touchMap[touchId];
    // By default, show tooltip for item under finger
    if (touchInfo)
      tooltipObj = touchInfo['currentObj'];
    // If an override is present, use this instead
    if (tooltipInfo['tooltipObjOverride']) {
      tooltipObj = tooltipInfo['tooltipObjOverride'];
    }

    touchIds.push(touchId);
    tooltipTarget = tooltipObj;

  }
  if (multipleGroups)
    touchIds = new Array();
  tooltipInfoObj['touchIds'] = touchIds;
  tooltipInfoObj['tooltipTarget'] = tooltipTarget;

  return tooltipInfoObj;
};


dvt.TouchManager.prototype.containsGrouping = function(type) {
  var matches = this._findMatches('grouping', type);
  return matches.length > 0;
};

dvt.TouchManager.prototype.processTouchStart = function(touchEvent) {
  var changedTouches = touchEvent.changedTouches;
  var touches = touchEvent.touches;

  this._touchCount = touches.length;
  for (var i = 0; i < changedTouches.length; i++)
  {
    var changedTouch = changedTouches[i];
    var screenX = changedTouch.screenX;
    var screenY = changedTouch.screenY;
    var identifier = changedTouch.identifier;
    var targetObj = this._getObjFromTouch(changedTouch);
    var touchInfo = {
      'x': screenX,
      'y': screenY,
      'prevX': screenX,
      'prevY': screenY,
      'pageX': changedTouch.pageX,
      'pageY': changedTouch.pageY,
      'prevPageX': changedTouch.pageX,
      'prevPageY': changedTouch.pageY,
      'dx': 0,
      'dy': 0,
      'fireClick': true,
      'startTarget': targetObj,
      'currentObj': targetObj,
      'touchMoved': false,
      'touchtype': null,
      'startTouch': changedTouch
    };
    touchInfo[dvt.TouchManager.TOUCH_MODE] = dvt.TouchManager.TOUCH_MODE_DEFAULT;
    touchInfo['origx'] = screenX;
    touchInfo['origy'] = screenY;

    this._touchMap[identifier] = touchInfo;

  }

  // For now, keep the restriction of only one finger being able to be in hover mode at a time
  if (this._isHovering() || !this._isTouchHoldAllowed()) {
    touchEvent.blockTouchHold();
  }
  return true;
};

dvt.TouchManager.prototype._isTouchHoldAllowed = function() {
  var touchMoved = false;
  var count = 0;
  for (var id in this._touchMap) {
    var info = this.getTouchInfo(id);
    if (info['touchMoved'])
      touchMoved = true;
    count++;
  }
  if (count > 1 && !touchMoved) {
    this.resetTouchHold();
    return false;
  }
  return true;
};

dvt.TouchManager.prototype._isHovering = function() {
  for (var id in this._touchMap) {
    var info = this.getTouchInfo(id);
    if (info[dvt.TouchManager.TOUCH_MODE] == dvt.TouchManager.TOUCH_MODE_LONG_PRESS) {
      return true;
    }
  }
  return false;
};

dvt.TouchManager.prototype._getStoredTouches = function(touches) {
  var storedTouches = new Array();
  for (var i = 0; i < touches.length; i++) {
    var touch = touches[i];
    var touchid = touch.identifier;
    var info = this.getTouchInfo(touchid);
    if (info) {
      storedTouches.push(touch);
    }
  }
  return storedTouches;
};

/**
 * Process touch move event
 * @param {dvt.TouchEvent} touchEvent Dvt touch move event
 * @return {boolean} true if the touch move event is processed successfully
 */
dvt.TouchManager.prototype.processTouchMove = function(touchEvent) {
  var changedTouches = this._getStoredTouches(touchEvent.changedTouches);
  var touches = this._getStoredTouches(touchEvent.touches);

  for (var i = 0; i < changedTouches.length; i++) {
    var touch = changedTouches[i];
    var targetObj = this._getObjFromTouch(touch);
    var touchid = touch.identifier;
    var info = this.getTouchInfo(touchid);

    info['currentObj'] = targetObj;
    info['touchMoved'] = true;
    // If the single finger touch id moves, don't attempt a touch hold
    if (info[dvt.TouchManager.TOUCH_MODE] != dvt.TouchManager.TOUCH_MODE_LONG_PRESS) {
      var pageDx = Math.abs(info['pageX'] - touch.pageX);
      var pageDy = Math.abs(info['pageY'] - touch.pageY);

      // Reset touch hold
      if (this._startSingleFingerTouchId == touchid && (pageDx > 0 || pageDy > 0))
        this.resetTouchHold();
      // Ignore any touch move less than 3px, decreasing sensitivity for recognizing tap
      info['touchMoved'] = (pageDx > 3 || pageDy > 3);
    }

    // If the move ever goes out of the initial object, don't fire a click
    if (info['fireClick']) {
      if (info[dvt.TouchManager.TOUCH_MODE] == dvt.TouchManager.TOUCH_MODE_LONG_PRESS) {
      } else {
        if (info['currentObj'] != info['startTarget']) {
          info['fireClick'] = false;
        }
      }
    }

  }

  for (var i = 0; i < touches.length; i++) {
    var touch = touches[i];
    var identifier = touch.identifier;
    var info = this.getTouchInfo(identifier);
    var screenX = touch.screenX;
    var screenY = touch.screenY;
    var deltaX = screenX - info['x'];
    var deltaY = screenY - info['y'];

    info['prevX'] = info['x'];
    info['prevY'] = info['y'];
    info['dx'] = deltaX;
    info['dy'] = deltaY;
    info['x'] = screenX;
    info['y'] = screenY;
    info['prevPageX'] = info['pageX'];
    info['prevPageY'] = info['pageY'];
    info['pageX'] = touch.pageX;
    info['pageY'] = touch.pageY;
  }
  return true;
};

dvt.TouchManager.prototype.processTouchEnd = function(touchEvent) {
  var changedTouches = touchEvent.changedTouches;
  this._touchCount = touchEvent.touches.length;

  for (var i = 0; i < changedTouches.length; i++) {
    var touch = changedTouches[i];
    var targetObj = this._getObjFromTouch(touch);
    var touchid = touch.identifier;
    var info = this.getTouchInfo(touchid);
    if (!info)
      continue;
    if (info['fireClick']) {
      if (info[dvt.TouchManager.TOUCH_MODE] == dvt.TouchManager.TOUCH_MODE_LONG_PRESS) {
        this._startSingleFingerTouchId = null;
      } else {
        var sameTarget = targetObj == info['startTarget'];
        var touchMoved = info['touchMoved'];
        var fireClick = (sameTarget && !touchMoved);
        info['fireClick'] = fireClick;
      }
    }
  }

  // 
  // Clear the cached stage position on touch end. This prevents the cached position value from being caried over
  // and breaking interaction when there are layout or device orientation changes.
  this._context.clearStageAbsolutePosition();

  return true;
};

dvt.TouchManager.getTouchById = function(id, touches) {
  if (id != null && !isNaN(id)) {
    for (var i = 0; i < touches.length; i++) {
      var touch = touches[i];
      if (touch.identifier == id) {
        return touch;
      }
    }
  }
  return null;
};

dvt.TouchManager.createSavedTouchInfo = function(touchId, touchObj, tooltipObjOverride, grouping, type, moveListener, endListener, listenerObj) {
  var obj = {'touchId' : touchId, 'tooltipObjOverride' : tooltipObjOverride, 'grouping' : grouping, 'type' : type, 'touchObj' : touchObj, 'allowTooltips' : true};
  obj['moveListener'] = moveListener;
  obj['endListener'] = endListener;
  obj['listenerObj'] = listenerObj;
  return obj;
};

/**
 * @private
 * Timer used for touch hold event
 */
dvt.TouchManager.prototype._handleTouchHoldStartTimer = function() {
  var event = this._dvtTouchEvent;
  this._stopTouchHoldTimer();
  this.startTouchHold(event);
};

/**
 * @private
 * Start touch hold timer
 * @param {dvt.TouchEvent} evt  Wrapper for the native event
 */
dvt.TouchManager.prototype._startTouchHoldTimer = function(evt) {
  this._dvtTouchEvent = evt;
  if (this._touchHoldTimer)
    this._touchHoldTimer.start();
};

/**
 * @private
 * Stop touch hold timer
 */
dvt.TouchManager.prototype._stopTouchHoldTimer = function() {
  this._dvtTouchEvent = null;
  if (this._touchHoldTimer)
    this._touchHoldTimer.stop();
};

dvt.TouchManager.prototype._handleDoubleTapTimer = function() {
  this.resetDoubleTap();
};

dvt.TouchManager.prototype.resetDoubleTap = function() {
  this._doubleTapAttemptStarted = false;
  this._doubleTapAttemptObj = null;
  this._doubleTapTimer.stop();
};


/**
 * Returns a map containing touch data for two finger touch events.
 * The map contins the following:
 * dz - The distance moved since the last touch event
 * cx - The current center of the two finger touch
 * dcx - The horizontal distance moved for the center of the two finger touch since the last touch event
 * dcy - The vertical distance moved for the center of the two finger touch since the last tch event
 */
dvt.TouchManager.prototype.getMultiTouchData = function(touchIds) {
  if (touchIds.length == 2) {
    var touch1Data = this._touchMap[touchIds[0]];
    var touch2Data = this._touchMap[touchIds[1]];
    if (touch1Data == null || touch2Data == null)
      return null;

    if (touch1Data['dx'] == 0 && touch2Data['dy'] == 0)
      return null;

    //: use page coords instead of screen coords, which the component can then turn into
    //stage-relative coords

    // current distance 2 fingers are apart
    var dx = touch1Data.pageX - touch2Data.pageX;
    var dy = touch1Data.pageY - touch2Data.pageY;
    var dist = Math.sqrt(dx * dx + dy * dy);

    // previous distance 2 fingers are apart
    var prevdx = touch1Data['prevPageX'] - touch2Data['prevPageX'];
    var prevdy = touch1Data['prevPageY'] - touch2Data['prevPageY'];
    var prevdist = Math.sqrt(prevdx * prevdx + prevdy * prevdy);

    var dz = (dist - prevdist);

    // calculate the distance the center btwn the two fingers has moved
    var cx = (touch1Data.pageX + touch2Data.pageX) / 2;
    var cy = (touch1Data.pageY + touch2Data.pageY) / 2;
    var prevcx = (touch1Data['prevPageX'] + touch2Data['prevPageX']) / 2;
    var prevcy = (touch1Data['prevPageY'] + touch2Data['prevPageY']) / 2;
    var dcx = (cx - prevcx);
    var dcy = (cy - prevcy);

    return {dz: dz, cx: cx, cy: cy, dcx: dcx, dcy: dcy, dist: dist};
  }
  return null;
};

// pan code
dvt.TouchManager.prototype.getMultiTouchDelta = function(touchIds)
{

  //Touches are a list of those currently being tracked
  // When a touch is moved, we will compare its screenX and screenY from its last known point.
  // We will then call the handlerCallback, passing in the deltaX and deltaY information.
  //var touches = touchEvent.touches;
  // Handle the case when the number of touches on the surfaces is equal to this._touchCount:
  if (touchIds)
  {
    var touchData;
    var touchType;
    // Have we determined the type of touch this is (only applicable for two finger touches)?
    if (touchIds.length == 2)
    {
      var touch1Data = this._touchMap[touchIds[0]];
      var touch2Data = this._touchMap[touchIds[1]];
      if (touch1Data == null || touch2Data == null)
      {
        // Missing touch data
        return;
      }

      if (touch1Data['touchtype'] == null)
      {
        // Determine if the touches are going away from each other, towards each other, or are
        // moving in unison.
        var touch1Direction = this._determineTouchDirection(touch1Data);
        if (touch1Direction != null)
        {
          var touch2Direction = this._determineTouchDirection(touch2Data);
          if (touch2Direction != null)
          {

            // We have enough data to determine which direction each touch is going.
            touchType = this._isSameDirection(touch1Direction, touch2Direction) ?
                'scroll' : 'pinch';

            touch1Data['touchtype'] = touchType;
          }
        }
      }

      touchType = touch1Data['touchtype'];
      if (touchType == null)
      {
        return;
      }
      else if (touchType == 'pinch')
      {
        return null;
      }
    }
    // If we have the right number of touches that were moved or less (the devices tend to pick up
    // one finger on occassion).
    //if (changedTouches.length <= this._touchCount)
    // {
    // Compute the average deltas:
    var averageXDelta = 0;
    var averageYDelta = 0;
    for (var j = 0; j < touchIds.length; j++)
    {
      touchData = this._touchMap[touchIds[j]];
      averageXDelta += touchData['dx'];
      averageYDelta += touchData['dy'];
    }
    averageXDelta /= touchIds.length;
    averageYDelta /= touchIds.length;

    // Determine if each delta was within a small tolerance from the average:
    var changesWereMovement = true;
    /*
      for (j=0; j<touchIds.length; j++)
      {
        touchId = touchIds[j];
        touchData = this._touchMap[touchId];
        var DISTANCE_TOLERANCE = 20; // pixels
        if (Math.abs(touchData["dx"] - averageXDelta) > DISTANCE_TOLERANCE ||
            Math.abs(touchData["dy"] - averageYDelta) > DISTANCE_TOLERANCE)
        {
          changesWereMovement = false;
          break;
        }
      }

    */
    if (changesWereMovement)
    {
      // Prevent the default event handling if we've determined that the touch event was in fact
      // for a movement.
      //touchEvent.preventDefault();

      // If there was non-zero movement:
      //      if (averageXDelta != 0 || averageYDelta != 0)
      //    {
      var scaleFactor = 1;//(window.outerWidth / window.innerWidth);
      return {deltaX: averageXDelta * scaleFactor, deltaY: averageYDelta * scaleFactor};
      // Notify the registered function of the deltas:
      //this._handlerCallback(averageXDelta * scaleFactor, averageYDelta * scaleFactor);
      //  }
    }
  }
  return null;
};


/**
 * Given two directions (see _determineTouchDirection) determine if they are moving roughly in
 * the same direction or opposite directions (pinch vs. scroll).
 */
dvt.TouchManager.prototype._isSameDirection = function(
    direction1,
    direction2)
{
  if (direction1 == direction2)
  {
    return true;
  }

  // Code below determines that the directions are the same if they are adjacent to each other.
  // Example: treat "ul" as the same direction as "l" and "u".
  if (direction1.length == 2 && direction2.length == 1)
  {
    return direction1.charAt(0) == direction2 || direction1.charAt(1) == direction2;
  }
  else if (direction1.length == 1 && direction2.length == 2)
  {
    return direction1 == direction2.charAt(0) || direction2 == direction1.charAt(1);
  }
  else
  {
    return false;
  }
};


/**
 * Given a touch data object (see _handleTouchMove), determine which direction it is moving.
 * Values are "ul", "u", "ur", "l", "r", "dl", "d" or "dr",
 * where "u" is up, "l" is left, "r" is right and "d" is down.
 * "
 * @return {String} the direction or null if the distance is not significant enough.
 */
dvt.TouchManager.prototype._determineTouchDirection = function(touchData)
{
  var origX = touchData['origx'];
  var origY = touchData['origy'];

  if (origX == null || origY == null)
  {
    return null;
  }

  var currentX = touchData['x'];
  var currentY = touchData['y'];

  var MINIMUM_DISTANCE_REQUIRED_RATIO = 0.01; // 1% of zoomed screen

  // Distance formula = sqrt( (x2 - x1)^2 + (y2 - y2)^2 )
  var distanceX = currentX - origX;
  var distanceY = currentY - origY;

  var distance = Math.sqrt(Math.pow(distanceX, 2) + Math.pow(distanceY, 2));
  var minDistance = window.innerWidth * MINIMUM_DISTANCE_REQUIRED_RATIO;
  if (distance < minDistance)
  {
    // Touch has not moved far enough to determine
    return null;
  }

  // Given a change to both the x and the y coordinates, determine if one is insignificant.
  var INSIGNIFICANT_RATIO = 0.25;
  var directionX = null;
  if (Math.abs(distanceX / distanceY) >= INSIGNIFICANT_RATIO)
  {
    directionX = (distanceX < 0) ? 'l' : 'r'; // note that we are not considering LTR/RTL here.
    // This is okay as we are not currently concerned with left or right, only if the touches
    // are in the same or different directions.
  }

  var directionY = null;
  if (Math.abs(distanceY / distanceX) >= INSIGNIFICANT_RATIO)
  {
    directionY = (distanceY < 0) ? 'u' : 'd';
  }

  if (directionX != null && directionY != null)
  {
    return directionY + directionX;
  }
  else if (directionX == null)
  {
    return directionY;
  }
  else if (directionY == null)
  {
    return directionX;
  }

  // Should never reach here
  return null;
};

dvt.TouchManager.prototype.calcAveragePosition = function(touchIds) {
  var pointX = 0;
  var pointY = 0;
  var touchCount = touchIds.length;
  for (var i = 0; i < touchCount; i++) {
    var touchId = touchIds[i];
    var touchData = this.getTouchInfo(touchId);
    pointX += touchData.pageX;
    pointY += touchData.pageY;
  }
  pointX /= touchCount;
  pointY /= touchCount;
  return new dvt.Point(pointX, pointY);
};


/**
 * Returns an array of start targets for corresponding touch ids
 * @param {array} touchIds An array of touch ids
 * @return {array} An array of touch targets
 */
dvt.TouchManager.prototype.getStartTargetsByIds = function(touchIds) {
  var targets = new Array();
  for (var i = 0; i < touchIds.length; i++) {
    var touchData = this.getTouchInfo(touchIds[i]);
    targets.push(touchData['startTarget']);
  }
  return targets;
};


/**
 * Resets touch info, touch map and timers.
 */
dvt.TouchManager.prototype.reset = function() {
  this._touchMap = new Object();
  this._savedTouchInfo = new Array();
  this.resetTouchHold();
  this.resetDoubleTap();
};
/**
 * @constructor
 */
dvt.ViewportChangeEvent = function(oldDim, newDim, evt) {
  this.Init(dvt.ViewportChangeEvent.TYPE);
  this._oldDim = oldDim;
  this._newDim = newDim;
  this._evt = evt;
};

dvt.ViewportChangeEvent.TYPE = 'viewportChange';

dvt.Obj.createSubclass(dvt.ViewportChangeEvent, dvt.BaseComponentEvent);

dvt.ViewportChangeEvent.prototype.getNativeEvent = function() {
  return this._evt;
};

dvt.ViewportChangeEvent.prototype.getOldDimensions = function() {
  return this._oldDim;
};

dvt.ViewportChangeEvent.prototype.getNewDimensions = function() {
  return this._newDim;
};
// Events when a custom tooltip action menu is interacted with
/**
 * @constructor
 */
var DvtActionTooltipEvent = function(type, target) {
  this.Init(type);
  this.target = target;
};

// TODO NAMESPACE: THIS MAY NOT BE USED.

DvtActionTooltipEvent.TOOLTIP_CLOSED_TYPE = 'actiontooltipclosed';
DvtActionTooltipEvent.TOOLTIP_STARTED_TYPE = 'actiontooltipstarted';

dvt.Obj.createSubclass(DvtActionTooltipEvent, dvt.BaseComponentEvent);

DvtActionTooltipEvent.prototype.Init = function(type) {
  DvtActionTooltipEvent.superclass.Init.call(this, type);
};
/**
 * @constructor
 * A higher-level class that represents a single touch event.
 * The target and the relatedTarget simulate target and relatedTarget of the MouseEvent
 * and the target does not match target on the native TouchEvent.
 * @param {string} type One of the dvt.ComponentTouchEvent event types.
 * @param {dvt.Touch} touch A single point of contact with the surface
 * @param {object} target An element that triggered the event
 * @param {object} relatedTarget An element related to the element that triggered the event
 * @param {TouchEvent} nativeEvent  Native touch event
 * @extends {dvt.BaseComponentEvent}
 * @class dvt.ComponentTouchEvent
 */
dvt.ComponentTouchEvent = function(type, touch, target, relatedTarget, nativeEvent) {
  this.Init(type, touch, target, relatedTarget, nativeEvent);
};


/**
 * Touch hold start event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_HOLD_START_TYPE = 'touchholdstart';


/**
 * Touch hold move event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_HOLD_MOVE_TYPE = 'touchholdmove';


/**
 * Touch hold end event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_HOLD_END_TYPE = 'touchholdend';


/**
 * Touch hover start event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_HOVER_START_TYPE = 'touchhoverstart';


/**
 * Touch hover move event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE = 'touchhovermove';


/**
 * Touch hover end event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_HOVER_END_TYPE = 'touchhoverend';


/**
 * Touch hover over event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_HOVER_OVER_TYPE = 'touchhoverover';


/**
 * Touch hover out event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_HOVER_OUT_TYPE = 'touchhoverout';


/**
 * Touch click event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_CLICK_TYPE = 'touchclick';


/**
 * Touch double click event
 * @const
 */
dvt.ComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE = 'touchdblclick';

dvt.Obj.createSubclass(dvt.ComponentTouchEvent, dvt.BaseComponentEvent);


/**
 * Helper method called by the constructor to initialize this object.
 * @param {string} type One of the dvt.ComponentTouchEvent event types
 * @param {dvt.Touch} touch A single point of contact with the surface
 * @param {object} target An element that triggered the event
 * @param {object} relatedTarget An element related to the element that triggered the event
 * @param {TouchEvent} nativeEvent  Native touch event
 */
dvt.ComponentTouchEvent.prototype.Init = function(type, touch, target, relatedTarget, nativeEvent) {
  dvt.ComponentTouchEvent.superclass.Init.call(this, type);
  this.target = target;
  this.touch = touch;
  this.relatedTarget = relatedTarget;
  this._isPropagationStopped = false;
  this._nativeEvent = nativeEvent;
};

// Stub methods so that mouse click handlers don't break
dvt.ComponentTouchEvent.prototype.preventDefault = function() {
};

dvt.ComponentTouchEvent.prototype.stopPropagation = function() {
  this._isPropagationStopped = true;
};

dvt.ComponentTouchEvent.prototype.isPropagationStopped = function() {
  return this._isPropagationStopped;
};

/**
 * Get native touch event
 * @return {TouchEvent}  native touch event
 */
dvt.ComponentTouchEvent.prototype.getNativeEvent = function() {
  return this._nativeEvent;
};
// Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * @param {number} ww The width of the resize
 * @param {number} hh The height of the resize
 * @param {number} xx The x coordinate of the resize
 * @param {number} yy The y coordinate of the resize
 * @constructor
 */
dvt.ResizeEvent = function(ww, hh, xx, yy) {
  this.Init(ww, hh, xx, yy);
};

dvt.Obj.createSubclass(dvt.ResizeEvent, dvt.Obj);

/** @const **/
dvt.ResizeEvent.RESIZE_EVENT = 'dvtResizeEvent';

/**
 * Helper initiailizer method
 * @param {number} ww The width of the resize
 * @param {number} hh The height of the resize
 * @param {number} xx The x coordinate of the resize
 * @param {number} yy The y coordinate of the resize
 * @protected
 */
dvt.ResizeEvent.prototype.Init = function(ww, hh, xx, yy) {
  this.type = dvt.ResizeEvent.RESIZE_EVENT;
  this._ww = ww;
  this._hh = hh;
  this._xx = xx;
  this._yy = yy;
};

/**
 * Returns the width of the resize event
 * @return {number}
 */
dvt.ResizeEvent.prototype.getWidth = function() {
  return this._ww;
};

/**
 * Returns the height of the resize event
 * @return {number}
 */
dvt.ResizeEvent.prototype.getHeight = function() {
  return this._hh;
};

/**
 * Returns the x coordinate of the resize event
 * @return {number}
 */
dvt.ResizeEvent.prototype.getX = function() {
  return this._xx;
};

/**
 * Returns the y coordinate of the resize event
 * @return {number}
 */
dvt.ResizeEvent.prototype.getY = function() {
  return this._yy;
};

/**
 * Returns the event type for this event.
 * @return {string} The event type for this event.
 */
dvt.ResizeEvent.prototype.getType = function() {
  return this.type;
};
// Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * @param {number} x The x coordinate of the scroll
 * @param {number} y The y coordinate of the scroll
 * @constructor
 */
dvt.ScrollEvent = function(x, y) {
  this.Init(x, y);
};

dvt.Obj.createSubclass(dvt.ScrollEvent, dvt.Obj);

/** @const **/
dvt.ScrollEvent.SCROLL_EVENT = 'dvtScrollEvent';


/**
 * Initializer
 * @param {number} x The x coordinate of the scroll
 * @param {number} y The y coordinate of the scroll
 * @protected
 */
dvt.ScrollEvent.prototype.Init = function(x, y) {
  this.type = dvt.ScrollEvent.SCROLL_EVENT;
  this._x = x;
  this._y = y;
};

/**
 * Returns the x coordinate of the scroll event
 * @return {number}
 */
dvt.ScrollEvent.prototype.getX = function() {
  return this._x;
};

/**
 * Returns the y coordinate of the scroll event
 * @return {number}
 */
dvt.ScrollEvent.prototype.getY = function() {
  return this._y;
};

/**
 * Returns the event type for this event.
 * @return {string} The event type for this event.
 */
dvt.ScrollEvent.prototype.getType = function() {
  return this.type;
};
/**
 * @constructor
 * @param {string} type Event type.
 * @param {number} x Marquee x.
 * @param {number} y Marquee y.
 * @param {number} w Marquee w.
 * @param {number} h Marquee h.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed.
 */
dvt.MarqueeEvent = function(subtype, x, y, w, h, ctrlKey) {
  this.Init(dvt.MarqueeEvent.TYPE);
  this.subtype = subtype;
  this.x = x;
  this.y = y;
  this.w = w;
  this.h = h;
  this.ctrlKey = ctrlKey;
};

dvt.Obj.createSubclass(dvt.MarqueeEvent, dvt.BaseComponentEvent);

dvt.MarqueeEvent.TYPE = 'dvtMarquee';

dvt.MarqueeEvent.SUBTYPE_START = 'dvtMarqueeStartEvent';
dvt.MarqueeEvent.SUBTYPE_MOVE = 'dvtMarqueeMoveEvent';
dvt.MarqueeEvent.SUBTYPE_END = 'dvtMarqueeEndEvent';


/**
 * @return {number} Event subtype.
 */
dvt.MarqueeEvent.prototype.getSubtype = function() {
  return this.subtype;
};
/**
 * @constructor
 * @param {string} type Event subtype.
 * @param {number} dxMin The delta of the xMin.
 * @param {number} dxMax The delta of the xMax.
 * @param {number} dyMin The delta of the yMin.
 * @param {number} dyMax The delta of the yMax.
 * @param {number=} dxMinTotal The total delta of the xMin (relative to the beginning of action).
 * @param {number=} dxMaxTotal The total delta of the xMax (relative to the beginning of action).
 * @param {number=} dyMinTotal The total delta of the yMin (relative to the beginning of action).
 * @param {number=} dyMaxTotal The total delta of the yMax (relative to the beginning of action).
 */
dvt.PanZoomEvent = function(subtype, dxMin, dxMax, dyMin, dyMax, dxMinTotal, dxMaxTotal, dyMinTotal, dyMaxTotal) {
  this.Init(dvt.PanZoomEvent.TYPE);
  this.subtype = subtype;
  this.dxMin = dxMin;
  this.dxMax = dxMax;
  this.dyMin = dyMin;
  this.dyMax = dyMax;
  this.dxMinTotal = dxMinTotal;
  this.dxMaxTotal = dxMaxTotal;
  this.dyMinTotal = dyMinTotal;
  this.dyMaxTotal = dyMaxTotal;
};

dvt.Obj.createSubclass(dvt.PanZoomEvent, dvt.BaseComponentEvent);

dvt.PanZoomEvent.TYPE = 'dvtPanZoom';

dvt.PanZoomEvent.SUBTYPE_PAN_START = 'dvtPanStartEvent';
dvt.PanZoomEvent.SUBTYPE_PAN_MOVE = 'dvtPanMoveEvent';
dvt.PanZoomEvent.SUBTYPE_PAN_END = 'dvtPanEndEvent';
dvt.PanZoomEvent.SUBTYPE_ZOOM = 'dvtZoomEvent';
dvt.PanZoomEvent.SUBTYPE_PINCH_START = 'dvtPinchStartEvent';
dvt.PanZoomEvent.SUBTYPE_PINCH_MOVE = 'dvtPinchMoveEvent';
dvt.PanZoomEvent.SUBTYPE_PINCH_END = 'dvtPinchEndEvent';


/**
 * @return {string} Event subtype.
 */
dvt.PanZoomEvent.prototype.getSubtype = function() {
  return this.subtype;
};
/**
 * An event fired by dvt.SimpleScrollbar.
 * @param {string} subtype The subtype of event.
 * @param {number} newMin The new scrollbar minimum.
 * @param {number} newMax The new scrollbar maximum.
 * @class
 * @constructor
 */
dvt.SimpleScrollbarEvent = function(subtype, newMin, newMax) {
  this.Init(dvt.SimpleScrollbarEvent.TYPE);
  this._subtype = subtype;
  this._newMin = newMin;
  this._newMax = newMax;
};

dvt.Obj.createSubclass(dvt.SimpleScrollbarEvent, dvt.BaseComponentEvent);

/** @const */
dvt.SimpleScrollbarEvent.TYPE = 'dvtSimpleScrollbar';

/** @const */
dvt.SimpleScrollbarEvent.SUBTYPE_MOVE = 'dvtMoveEvent';
/** @const */
dvt.SimpleScrollbarEvent.SUBTYPE_END = 'dvtEndEvent';

/**
 * @return {string} subtype
 */
dvt.SimpleScrollbarEvent.prototype.getSubtype = function() {
  return this._subtype;
};

/**
 * @return {number} new minimum
 */
dvt.SimpleScrollbarEvent.prototype.getNewMin = function() {
  return this._newMin;
};

/**
 * @return {number} new maximum
 */
dvt.SimpleScrollbarEvent.prototype.getNewMax = function() {
  return this._newMax;
};
/**
 * Event factory for DOM events.
 * @class
 */
dvt.DomEventFactory = new Object();

dvt.Obj.createSubclass(dvt.DomEventFactory, dvt.Obj);

// Note: this doesn't need to live in the factory because it will always be called
// by impl specific code looking to wrap the event.
/**
 * Creates a DVT wrapper for a mouse, keyboard, focus or touch event
 * @param {MouseEvent|KeyboardEvent|TouchEvent|FocusEvent} nativeEvent native event
 * @param {dvt.Context} context rendering context
 * @return {dvt.BaseEvent} a wrapper for a mouse, keyboard, focus or touch event
 */
dvt.DomEventFactory.newEvent = function(nativeEvent, context) {
  // TODO detect the event type and perform wrapping as needed
  var eventType = nativeEvent.type;
  if (eventType == dvt.TouchEvent.TOUCHSTART || eventType == dvt.TouchEvent.TOUCHMOVE || eventType == dvt.TouchEvent.TOUCHEND || eventType == dvt.TouchEvent.TOUCHCANCEL) {
    return new dvt.TouchEvent(nativeEvent);
  }
  else if (eventType == dvt.KeyboardEvent.KEYDOWN || eventType == dvt.KeyboardEvent.KEYUP || eventType == dvt.KeyboardEvent.KEYPRESS) {
    return new dvt.KeyboardEvent(nativeEvent);
  }
  else {
    //: if the native event is the same as the last one, return the stored logical event,
    //otherwise create a new logical event and store the pair of events
    if (context._nativeEvent != nativeEvent) {
      context._nativeEvent = nativeEvent;
      if (eventType == DvtFocusEvent.FOCUS || eventType == DvtFocusEvent.FOCUSIN || eventType == DvtFocusEvent.FOCUSOUT || eventType == DvtFocusEvent.BLUR) {
        context._logicalEvent = new DvtFocusEvent(nativeEvent);
      }
      else { // default to mouse event
        context._logicalEvent = new dvt.MouseEvent(nativeEvent);
      }
    }
    return context._logicalEvent;
  }
};


/**
 * Returns a dvt.MouseEvent that wraps the given keyboard event.  The given stageX and stageY coordinates are used to
 * compute the dvt.MouseEvent's pageX and pageY fields
 *
 * @param {dvt.KeyboardEvent} keyboardEvent
 * @param {dvt.Context} context
 * @param {String} eventType
 * @param {DvtStage} stage
 * @param {Number} stageX
 * @param {Number} stageY
 * @return {dvt.MouseEvent}
 */
dvt.DomEventFactory.generateMouseEventFromKeyboardEvent = function(keyboardEvent, context, eventType, stage, stageX, stageY)
{
  var nativeEvent = null;

  if (document.createEvent)
  {
    nativeEvent = document.createEvent('MouseEvents');

    var pageCoord = context.stageToPageCoords(stageX, stageY);

    nativeEvent.initMouseEvent(eventType, true, true, window, 1, pageCoord.x, pageCoord.y, pageCoord.x, pageCoord.y,
        keyboardEvent.ctrlKey, keyboardEvent.altKey, keyboardEvent.shiftKey, keyboardEvent.metaKey,
        0, null);
  }

  if (nativeEvent)
  {
    var mouseEvent = dvt.DomEventFactory.newEvent(nativeEvent, context);
    mouseEvent.target = keyboardEvent.target;
    return mouseEvent;
  }
  else
    return null;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * Utility functions for SVG paths taken from 3rd party sources.
 * @class
 */
var Dvt3rdPartyPathUtils = {};

dvt.Obj.createSubclass(Dvt3rdPartyPathUtils, dvt.Obj);

/**
 * Adapted from D3.js -- d3_svg_lineLinear
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @return {string} Path commands.
 */
Dvt3rdPartyPathUtils.lineLinear = function(points) {
  return points.join('L');
};

/**
 * Adapted from D3.js -- d3_svg_lineCardinalClosed
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @param {number} tension A number from 0 to 1 specifying the tension.
 * @return {string} Path commands.
 */
Dvt3rdPartyPathUtils.lineCardinalClosed = function(points, tension) {
  return points.length < 3 ? Dvt3rdPartyPathUtils.lineLinear(points) : points[0] + Dvt3rdPartyPathUtils.lineHermite((points.push(points[0]),
      points), Dvt3rdPartyPathUtils.lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
};

/**
 * Adapted from D3.js -- d3_svg_lineCardinal
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @param {number} tension A number from 0 to 1 specifying the tension.
 * @return {string} Path commands.
 */
Dvt3rdPartyPathUtils.lineCardinal = function(points, tension) {
  return points.length < 3 ? Dvt3rdPartyPathUtils.lineLinear(points) : points[0] + Dvt3rdPartyPathUtils.lineHermite(points, Dvt3rdPartyPathUtils.lineCardinalTangents(points, tension));
};

/**
 * Adapted from D3.js -- d3_svg_lineHermite
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @param {array} tangents Tangents in the form of [[t0x t0y] [t1x t1y] ...].
 * @return {string} Path commands.
 */
Dvt3rdPartyPathUtils.lineHermite = function(points, tangents) {
  if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
    return Dvt3rdPartyPathUtils.lineLinear(points);
  }
  var quad = points.length != tangents.length, path = '', p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
  if (quad) {
    path += 'Q' + Math.round(p[0] - t0[0] * 2 / 3) + ',' + Math.round(p[1] - t0[1] * 2 / 3) + ',' + Math.round(p[0]) + ',' + Math.round(p[1]);
    p0 = points[1];
    pi = 2;
  }
  if (tangents.length > 1) {
    t = tangents[1];
    p = points[pi];
    pi++;
    path += 'C' + Math.round(p0[0] + t0[0]) + ',' + Math.round(p0[1] + t0[1]) + ',' + Math.round(p[0] - t[0]) + ',' + Math.round(p[1] - t[1]) + ',' + Math.round(p[0]) + ',' + Math.round(p[1]);
    for (var i = 2; i < tangents.length; i++, pi++) {
      p = points[pi];
      t = tangents[i];
      path += 'S' + Math.round(p[0] - t[0]) + ',' + Math.round(p[1] - t[1]) + ',' + Math.round(p[0]) + ',' + Math.round(p[1]);
    }
  }
  if (quad) {
    var lp = points[pi];
    path += 'Q' + Math.round(p[0] + t[0] * 2 / 3) + ',' + Math.round(p[1] + t[1] * 2 / 3) + ',' + Math.round(lp[0]) + ',' + Math.round(lp[1]);
  }
  return path;
};

/**
 * Adapted from D3.js -- d3_svg_lineCardinalTangents
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @param {number} tension A number from 0 to 1 specifying the tension.
 * @return {array} Tangents in the form of [[t0x t0y] [t1x t1y] ...].
 */
Dvt3rdPartyPathUtils.lineCardinalTangents = function(points, tension) {
  var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
  while (++i < n) {
    p0 = p1;
    p1 = p2;
    p2 = points[i];
    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
  }
  return tangents;
};

/**
 * Adapted from D3.js -- d3_svg_lineSlope
 * @param {array} p0 Point in the form of [x y].
 * @param {array} p1 Point in the form of [x y].
 * @return {number} Slope.
 */
Dvt3rdPartyPathUtils.lineSlope = function(p0, p1) {
  return (p1[1] - p0[1]) / (p1[0] - p0[0]);
};

/**
 * Adapted from D3.js -- d3_svg_lineFiniteDifferences
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @return {array} Finite differences.
 */
Dvt3rdPartyPathUtils.lineFiniteDifferences = function(points) {
  var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = Dvt3rdPartyPathUtils.lineSlope(p0, p1);
  while (++i < j) {
    m[i] = (d + (d = Dvt3rdPartyPathUtils.lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
  }
  m[i] = d;
  return m;
};

/**
 * Adapted from D3.js -- d3_svg_lineMonotoneTangents
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @param {boolean} isHoriz If true, the spline is monotonic in X. Otherwise, it is monotonic in Y.
 * @return {array} Tangents in the form of [[t0x t0y] [t1x t1y] ...].
 */
Dvt3rdPartyPathUtils.lineMonotoneTangents = function(points, isHoriz) {
  if (isHoriz) // swap x and y
    points = Dvt3rdPartyPathUtils._rotatePoints(points);

  var tangents = [], d, a, b, s, m = Dvt3rdPartyPathUtils.lineFiniteDifferences(points), i = -1, j = points.length - 1;
  while (++i < j) {
    d = Dvt3rdPartyPathUtils.lineSlope(points[i], points[i + 1]);
    if (Math.abs(d) < 1e-6) {
      m[i] = m[i + 1] = 0;
    } else {
      a = m[i] / d;
      b = m[i + 1] / d;
      s = a * a + b * b;
      if (s > 9) {
        s = d * 3 / Math.sqrt(s);
        m[i] = s * a;
        m[i + 1] = s * b;
      }
    }
  }
  i = -1;
  while (++i <= j) {
    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
    tangents.push([s || 0, m[i] * s || 0]);
  }

  if (isHoriz) // swap x and y again
    tangents = Dvt3rdPartyPathUtils._rotatePoints(tangents);

  return tangents;
};

/**
 * Adapted from D3.js -- d3_svg_lineMonotone
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @param {boolean} isHoriz If true, the spline is monotonic in X. Otherwise, it is monotonic in Y.
 * @return {string} Path commands.
 */
Dvt3rdPartyPathUtils.lineMonotone = function(points, isHoriz) {
  return points.length < 3 ? Dvt3rdPartyPathUtils.lineLinear(points) : points[0] + Dvt3rdPartyPathUtils.lineHermite(points, Dvt3rdPartyPathUtils.lineMonotoneTangents(points, isHoriz));
};

/**
 * Rotate the points by swapping the x and y.
 * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].
 * @return {array} Rotated points.
 * @private
 */
Dvt3rdPartyPathUtils._rotatePoints = function(points) {
  var rPoints = [];
  for (var i = 0; i < points.length; i++)
    rPoints.push([points[i][1], points[i][0]]);
  return rPoints;
};
/**
 *   Static Utility Functions for dvt.Displayable
 *   @class dvt.DisplayableUtils
 *   @constructor
 */
dvt.DisplayableUtils = function()
{};

dvt.Obj.createSubclass(dvt.DisplayableUtils, dvt.Obj);

/*
 * Temporarily add the display object to the stage to get dimensions.
 * Remove it from stage after done
 */
dvt.DisplayableUtils.getDimensionsForced = function(context, obj) {
  //save original parent and index
  var oParent = obj.getParent();
  var oIndex;
  if (oParent)
    oIndex = oParent.getChildIndex(obj);

  var stage = context.getStage();
  stage.addChild(obj);

  var dim = obj.getDimensions();
  stage.removeChild(obj);

  //restore original parent
  if (oParent) {
    oParent.addChildAt(obj, oIndex);
  }

  return dim;
};


/*
 * Temporarily add the display object to the stage to get dimensions.
 * Remove it from stage after done
 * cached dimensions in obj._dim
 */
dvt.DisplayableUtils.getDimForced = function(context, obj) {
  //if there is a cache or context is null, return it.
  if (obj._dim || ! context) {
    return obj._dim;
  }

  var dim = dvt.DisplayableUtils.getDimensionsForced(context, obj);

  //cached the dimensions
  dvt.DisplayableUtils._setDimForced(obj, dim);
  return dim;
};


/*
 * cached dimensions in obj._dim
 */
dvt.DisplayableUtils._setDimForced = function(obj, dim) {
  //cached the dimensions
  obj._dim = dim;
};


/**
 * Determine if a displayable is an ancestor of another displayable.
 *
 * @param {dvt.Displayable} ancestor  The potential ancestor displayable.
 * @param {dvt.Displayable} descendant  The potential descendant displayable.
 * @type {Boolean}
 */
dvt.DisplayableUtils.isAncestor = function(ancestor, descendant) {
  var disp = descendant;
  while (disp) {
    if (disp == ancestor) {
      return true;
    }
    if (disp instanceof dvt.Container) {
      disp = disp.getParent();
    }
  }
  return false;
};


// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*  dvt.PathUtils()       Utility functions for SVG paths               */
/*---------------------------------------------------------------------*/

dvt.PathUtils = {};

dvt.Obj.createSubclass(dvt.PathUtils, dvt.Obj);

dvt.PathUtils.SPLINE_TYPE_MONOTONE_VERTICAL = 'mv';
dvt.PathUtils.SPLINE_TYPE_MONOTONE_HORIZONTAL = 'mh';
dvt.PathUtils.SPLINE_TYPE_CARDINAL_CLOSED = 'cc';
dvt.PathUtils.SPLINE_TYPE_CARDINAL = 'c';

/** @private **/
dvt.PathUtils._MIN_CORNER_RADIUS = 2.5;

/**
 * Returns a path command for a move to the specified coordinates
 * @param x the destination x coordinate
 * @param y the destination y coordinate
 * @return the moveTo path command
 */
dvt.PathUtils.moveTo = function(x,y) {
  return 'M' + dvt.ToolkitUtils.roundDecimal(x) + ',' + dvt.ToolkitUtils.roundDecimal(y);
};


/**
 * Returns a path command for a line to the specified coordinates
 * @param x the destination x coordinate
 * @param y the destination y coordinate
 * @return the lineTo path command
 */
dvt.PathUtils.lineTo = function(x,y) {
  return 'L' + dvt.ToolkitUtils.roundDecimal(x) + ',' + dvt.ToolkitUtils.roundDecimal(y);
};

dvt.PathUtils.quadTo = function(x1,y1,x,y) {
  return 'Q' + dvt.ToolkitUtils.roundDecimal(x1) + ',' + dvt.ToolkitUtils.roundDecimal(y1) + ',' +
      dvt.ToolkitUtils.roundDecimal(x) + ',' + dvt.ToolkitUtils.roundDecimal(y);
};

dvt.PathUtils.cubicTo = function(x1,y1,x2,y2,x,y) {
  return 'C' + dvt.ToolkitUtils.roundDecimal(x1) + ',' + dvt.ToolkitUtils.roundDecimal(y1) + ',' +
      dvt.ToolkitUtils.roundDecimal(x2) + ',' + dvt.ToolkitUtils.roundDecimal(y2) + ',' +
          dvt.ToolkitUtils.roundDecimal(x) + ',' + dvt.ToolkitUtils.roundDecimal(y);
};


/**
 * Returns a path command for an arc to the specified coordinates
 * @param rx the x radius of the ellipse whose arc will be drawn
 * @param ry the y radius of the ellipse whose arc will be drawn
 * @param angleExtent the sweep of the arc to be drawn
 * @param direction 1 for clockwise, 0 for counter-clockwise
 * @param x the ending x coordinate
 * @param y the ending y coordinate
 */
dvt.PathUtils.arcTo = function(rx, ry, angleExtent, direction, x, y) {
  var cmd = 'A' + dvt.ToolkitUtils.roundDecimal(rx) + ',' + dvt.ToolkitUtils.roundDecimal(ry) + ',0,';
  if (angleExtent > Math.PI) {
    cmd += '1,';
  }
  else {
    cmd += '0,';
  }
  cmd += (direction + ',' + dvt.ToolkitUtils.roundDecimal(x) + ',' + dvt.ToolkitUtils.roundDecimal(y));
  return cmd;
};


/**
 * Returns a path command that closes the path.
 */
dvt.PathUtils.closePath = function() {
  return 'Z';
};


/**
 * Returns a path command for a rounded rectangle.
 * @param {number} x Rectangle x.
 * @param {number} y Rectangle y.
 * @param {number} w Rectangle width.
 * @param {number} h Rectangle height.
 * @param {number} tlcr Top left corner radius.
 * @param {number} trcr Top right corner radius.
 * @param {number} brcr Bottom right corner radius.
 * @param {number} blcr Bottom left corner radius.
 * @return {string} Path command.
 */
dvt.PathUtils.roundedRectangle = function(x, y, w, h, tlcr, trcr, brcr, blcr) {
  return dvt.PathUtils._roundedRectangle(x, y, w, h, tlcr, tlcr, trcr, trcr, brcr, brcr, blcr, blcr);
};

/**
 * Parse corner radii and return the new shape.
 *
 * Sample (valid) radius values:
 *  '5px' - 5px all corners
 *  '50% 50% 0 0' - 50% top corners, 0 bottom corners
 *  '50% 10' - 50% top left bottom right, 10px top right bottom left.
 *  '5px / 10px' - 5px horizontal radius, 10px vertical radius all corners
 *  '50% 50% 25% 25% / 25% 25% 50% 50%' - 50% h radius 25% v radius top corners, 25% h radius 50% v radius bottom corners
 *
 * Note that all non-% values (including unitless) get interpreted as 'px'.
 *
 * @param {number} x Rectangle x.
 * @param {number} y Rectangle y.
 * @param {number} w Rectangle width.
 * @param {number} h Rectangle height.
 * @param {String} radius The options attribute to be parsed
 * @param {number} multiplier The value used for when a percent radius is provided
 * @param {string} defaultValue A specified value for the border radius
 * @return {string} Path command of shape with border radius.
 */
dvt.PathUtils.rectangleWithBorderRadius = function(x, y, w, h, radius, multiplier, defaultValue) {
  var topLeftX = defaultValue;
  var topLeftY = defaultValue;
  var topRightX = defaultValue;
  var topRightY = defaultValue;
  var bottomRightX = defaultValue;
  var bottomRightY = defaultValue;
  var bottomLeftX = defaultValue;
  var bottomLeftY = defaultValue;
  if (radius) {
    if (radius.indexOf('/') != -1) {
      var splitHorizVert = radius.split('/');
      var horiz = dvt.StringUtils.trim(splitHorizVert[0]).split(/\s+/);
      var vert = dvt.StringUtils.trim(splitHorizVert[1]).split(/\s+/);
      if (horiz.length == 1)
        topLeftX = topRightX = bottomRightX = bottomLeftX = horiz[0];
      else if (horiz.length == 2) {
        topLeftX = bottomRightX = horiz[0];
        topRightX = bottomLeftX = horiz[1];
      }
      else if (horiz.length == 3) {
        topLeftX = horiz[0];
        topRightX = bottomLeftX = horiz[1];
        bottomRightX = horiz[2];
      }
      else if (horiz.length == 4) {
        topLeftX = horiz[0];
        topRightX = horiz[1];
        bottomRightX = horiz[2];
        bottomLeftX = horiz[3];
      }
      if (vert.length == 1)
        topLeftY = topRightY = bottomRightY = bottomLeftY = vert[0];
      else if (vert.length == 2) {
        topLeftY = bottomRightY = vert[0];
        topRightY = bottomLeftY = vert[1];
      }
      else if (vert.length == 3) {
        topLeftY = vert[0];
        topRightY = bottomLeftY = vert[1];
        bottomRightY = vert[2];
      }
      else if (vert.length == 4) {
        topLeftY = vert[0];
        topRightY = vert[1];
        bottomRightY = vert[2];
        bottomLeftY = vert[3];
      }
    }
    else if (radius != 'auto') {
      var split = dvt.StringUtils.trim(radius).split(/\s+/);
      if (split.length == 1) {
        topLeftX = topRightX = bottomRightX = bottomLeftX =
            topLeftY = topRightY = bottomRightY = bottomLeftY = split[0];
      }
      else if (split.length == 2) {
        topLeftX = bottomRightX = topLeftY = bottomRightY = split[0];
        topRightX = bottomLeftX = topRightY = bottomLeftY = split[1];
      }
      else if (split.length == 3) {
        topLeftX = topLeftY = split[0];
        topRightX = bottomLeftX = topRightY = bottomLeftY = split[1];
        bottomRightX = bottomRightY = split[2];
      }
      else if (split.length == 4) {
        topLeftX = topLeftY = split[0];
        topRightX = topRightY = split[1];
        bottomRightX = bottomRightY = split[2];
        bottomLeftX = bottomLeftY = split[3];
      }
    }
  }

  return dvt.PathUtils._roundedRectangle(x, y, w, h,
      dvt.PathUtils._parseBorderRadiusItem(topLeftX, multiplier),
      dvt.PathUtils._parseBorderRadiusItem(topLeftY, multiplier),
      dvt.PathUtils._parseBorderRadiusItem(topRightX, multiplier),
      dvt.PathUtils._parseBorderRadiusItem(topRightY, multiplier),
      dvt.PathUtils._parseBorderRadiusItem(bottomRightX, multiplier),
      dvt.PathUtils._parseBorderRadiusItem(bottomRightY, multiplier),
      dvt.PathUtils._parseBorderRadiusItem(bottomLeftX, multiplier),
      dvt.PathUtils._parseBorderRadiusItem(bottomLeftY, multiplier));
};

/**
 * Parse a single corner radius dimension
 * @param {String} item The x or y radius input need to be parsed
 * @param {number} multiplier The value used for when a percent radius is provided
 * @return {number} The integer value of the corner radius
 * @private
 */
dvt.PathUtils._parseBorderRadiusItem = function(item, multiplier) {
  var radius = Math.min(parseFloat(item), multiplier / 2);
  if (item.indexOf('%') != -1) {
    radius = Math.min(50, parseFloat(item)) * .01 * multiplier;
  }
  return radius < dvt.PathUtils._MIN_CORNER_RADIUS ? 0 : radius;
};

/**
 * Returns a path command for a rounded rectangle.
 * @param {number} x Rectangle x.
 * @param {number} y Rectangle y.
 * @param {number} w Rectangle width.
 * @param {number} h Rectangle height.
 * @param {number} tlcrX Top left corner x radius.
 * @param {number} tlcrY Top left corner y radius.
 * @param {number} trcrX Top right corner x radius.
 * @param {number} trcrY Top right corner y radius.
 * @param {number} brcrX Bottom right corner x radius.
 * @param {number} brcrY Bottom right corner y radius.
 * @param {number} blcrX Bottom left corner x radius.
 * @param {number} blcrY Bottom left corner  y radius.
 * @return {string} Path command.
 * @private
 */
dvt.PathUtils._roundedRectangle = function(x, y, w, h, tlcrX, tlcrY, trcrX, trcrY, brcrX, brcrY, blcrX, blcrY) {
  tlcrY = Math.min(tlcrY, .5 * h);
  trcrY = Math.min(trcrY, .5 * h);
  brcrY = Math.min(brcrY, .5 * h);
  blcrY = Math.min(blcrY, .5 * h);
  tlcrX = Math.min(tlcrX, .5 * w);
  trcrX = Math.min(trcrX, .5 * w);
  brcrX = Math.min(brcrX, .5 * w);
  blcrX = Math.min(blcrX, .5 * w);
  var cmd = dvt.PathUtils.moveTo(x + tlcrX, y) +
            dvt.PathUtils.lineTo(x + w - trcrX, y) +
            dvt.PathUtils.arcTo(trcrX, trcrY, Math.PI / 2, 1, x + w, y + trcrY) +
            dvt.PathUtils.lineTo(x + w, y + h - brcrY) +
            dvt.PathUtils.arcTo(brcrX, brcrY, Math.PI / 2, 1, x + w - brcrX, y + h) +
            dvt.PathUtils.lineTo(x + blcrX, y + h) +
            dvt.PathUtils.arcTo(blcrX, blcrY, Math.PI / 2, 1, x, y + h - blcrY) +
            dvt.PathUtils.lineTo(x, y + tlcrY) +
            dvt.PathUtils.arcTo(tlcrX, tlcrY, Math.PI / 2, 1, x + tlcrX, y) +
            dvt.PathUtils.closePath();

  return cmd;
};

/**
 * Returns a polyline path cmd based on the points array.
 * @param {array} points Polyline points array.
 * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.
 * @return {string} Path command.
 */
dvt.PathUtils.polyline = function(points, connectWithLine) {
  if (points.length < 2)
    return '';

  var cmd = connectWithLine ? dvt.PathUtils.lineTo(points[0], points[1]) : dvt.PathUtils.moveTo(points[0], points[1]);
  for (var i = 2; i < points.length; i += 2) {
    cmd += dvt.PathUtils.lineTo(points[i], points[i + 1]);
  }

  return cmd;
};

/**
 * Returns a curved path command, based on cubic hermite splines, that goes through the points in the points array.
 * @param {array} points Polyline points array.
 * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.
 * @param {string} type The spline type.
 * @return {string} Path commands.
 */
dvt.PathUtils.curveThroughPoints = function(points, connectWithLine, splineType) {
  if (points.length == 0)
    return '';

  var pts = [];
  for (var i = 0; i < points.length; i += 2) // convert to D3 points format
    pts.push([points[i], points[i + 1]]);
  var prefix = connectWithLine ? 'L' : 'M';

  if (splineType == dvt.PathUtils.SPLINE_TYPE_MONOTONE_VERTICAL)
    return prefix + Dvt3rdPartyPathUtils.lineMonotone(pts, false);
  else if (splineType == dvt.PathUtils.SPLINE_TYPE_MONOTONE_HORIZONTAL)
    return prefix + Dvt3rdPartyPathUtils.lineMonotone(pts, true);
  else if (splineType == dvt.PathUtils.SPLINE_TYPE_CARDINAL_CLOSED)
    return prefix + Dvt3rdPartyPathUtils.lineCardinalClosed(pts, 0.7);
  else
    return prefix + Dvt3rdPartyPathUtils.lineCardinal(pts, 0.7);
};

/**
  *  Creates an array of path/coords from an Svg path string.
  *  @param {String} cmds A string containing SVG path command sequences.
  *  @return {Array}  an array of consecutive path command/coords, or null
  *                    if no command string supplied.
  */
dvt.PathUtils.createPathArray = function(sCmds)
{
  if (! sCmds)
    return null;

  //  Unpack into an array of commands and coords.
  var cmds = sCmds.replace(/([mlqhvzca])/gi, ',$1,'); // create array of coords from the string
  var ar = cmds.split(/[ ,]/g);
  var len = ar.length;
  var i;
  //  Convert coordinates in command array to floats.
  for (i = 0; i < len; i++) {
    var s = ar[i];
    if (!s) {
      ar.splice(i, 1);
      i--;
      len--;
    }
    else if (!isNaN(s)) {
      ar[i] = parseFloat(s);
    }
  }

  return ar;
};


/**
 * Returns the bounding box of the supplied path commands.
 * @param {Array} arCmds the path commands.
 * @return {dvt.Rectangle} the bounding box of the supplied path commands.
 */
dvt.PathUtils.getDimensions = function(aCmds)
{
  if (! (aCmds && aCmds.length)) {
    return new dvt.Rectangle();
  }

  var len = aCmds.length;
  var c;
  var xSubPath, ySubPath;
  var bFirst = true;           // false after first command
  var bRel;                    // true if relative command
  var x, y, x2, y2, x3, y3;

  var minX = Number.MAX_VALUE;
  var maxX = Number.MIN_VALUE;
  var minY = Number.MAX_VALUE;
  var maxY = Number.MIN_VALUE;
  var aPos = [];
  var i, j, k;

  for (i = 0; i < len; i++) {
    bRel = false;
    var iMulti = 0;
    j = 0;

    c = aCmds[i];

    switch (c)
    {
      case 'm' : bRel = true;
      case 'M' : do {
        x = aCmds[i + 1];
        y = aCmds[i + 2];

        if (bFirst) {        // note if first is 'm', it is treated as absolute.
          bFirst = false;
        }
        else if (bRel) {
          x += xSubPath;
          y += ySubPath;
        }
        xSubPath = x;
        ySubPath = y;

        aPos[j++] = x;
        aPos[j++] = y;
        iMulti++;
        i += 2;
      } while (! isNaN(aCmds[i + 1]));
      break;

      case 'c' : bRel = true;
      case 'C' : do {
        x = aCmds[i + 1];
        y = aCmds[i + 2];
        x2 = aCmds[i + 3];
        y2 = aCmds[i + 4];
        x3 = aCmds[i + 5];
        y3 = aCmds[i + 6];

        if (bRel) {
          x += xSubPath;
          y += ySubPath;
          x2 += xSubPath;
          y2 += ySubPath;
          x3 += xSubPath;
          y3 += ySubPath;
        }
        xSubPath = x3;
        ySubPath = y3;

        aPos[j++] = x3;
        aPos[j++] = y3;
        iMulti++;
        i += 6;
      } while (! isNaN(aCmds[i + 1]));
      break;

      case 'q' : bRel = true;
      case 'Q' : do {
        x = aCmds[i + 1];
        y = aCmds[i + 2];
        x2 = aCmds[i + 3];
        y2 = aCmds[i + 4];
        if (bRel) {
          x += xSubPath;
          y += ySubPath;
          x2 += xSubPath;
          y2 += ySubPath;
        }
        xSubPath = x2;
        ySubPath = y2;

        aPos[j++] = x2;
        aPos[j++] = y2;
        iMulti++;
        i += 4;
      } while (! isNaN(aCmds[i + 1]));
      break;

      case 'l' : bRel = true;
      case 'L' :
        do {
          x = aCmds[i + 1];
          y = aCmds[i + 2];
          if (bRel) {
            x += xSubPath;
            y += ySubPath;
          }
          xSubPath = x;
          ySubPath = y;

          aPos[j++] = x;
          aPos[j++] = y;
          iMulti++;
          i += 2;
        } while (! isNaN(aCmds[i + 1]));
        break;

      case 'h' : bRel = true;
      case 'H' :
        do {
          x = aCmds[i + 1];
          if (bRel) {
            x += xSubPath;
          }
          xSubPath = x;

          aPos[j++] = x;
          aPos[j++] = ySubPath;
          iMulti++;
          i += 1;
        } while (! isNaN(aCmds[i + 1]));
        break;

      case 'v' : bRel = true;
      case 'V' :
        do {
          y = aCmds[i + 1];
          if (bRel) {
            y += ySubPath;
          }
          ySubPath = y;

          aPos[j++] = xSubPath;
          aPos[j++] = y;
          iMulti++;
          i += 1;
        } while (! isNaN(aCmds[i + 1]));
        break;

      case 'z' :
      case 'Z' : break;

      default : break;
    }                                    // end switch

    j = 0;
    for (k = 0; k < iMulti; k++) {
      x = aPos[j++];
      y = aPos[j++];
      minX = Math.min(minX, x);
      maxX = Math.max(maxX, x);
      minY = Math.min(minY, y);
      maxY = Math.max(maxY, y);
    }
  }

  return new dvt.Rectangle(minX, minY, Math.abs(maxX - minX), Math.abs(maxY - minY));
};


/**
 *  Converts a platform independent array of consecutive commands and coords
 *  to an SVG path string.
 *  @param {Array} ar  The array of commands and coordinates to be converted.
 *  @type {String}
 */
dvt.PathUtils.getPathString = function(ar)
{
  var sOut = '';
  var len = ar.length;
  var s;

  for (var i = 0; i < len; i++) {
    s = ar[i];
    if (s !== undefined && s !== null)
      sOut += (((i > 0) ? ' ' : '') + ar[i]);
  }

  return sOut;
};


/**
  *  Initializes the shape to the specified coordinates.
  *  @private
  */
dvt.PathUtils.transformPath = function(sCmds, x, y, sx, sy)
{
  var scaledPath = '';                   // return string
  if (! sCmds)
    return;

  // Split the commands (command is recognized as a single letter followed
  // by any number of non-letter characters)

  var commands = sCmds.match(/[a-z][^a-z]*/ig);

  for (var i = 0; i < commands.length; i++)
  {
    var command = commands[i];
    var cmdType = command.charAt(0);
    var absCmd = cmdType === cmdType.toUpperCase();

    scaledPath += (cmdType + ' ');
    var strArgs = command.substring(1);

    strArgs = strArgs.replace(/,/g, ' ');         // replace all commas with spaces
    strArgs = strArgs.replace(/^\s+|\s+$/g, '');  // trim leading and trailing whitespace

    if (strArgs.length > 0)
    {
      var args = strArgs.split(/\s+/g); // split on whitespace
      if (cmdType.toUpperCase() === 'A')
      {
        // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)  only rx, ry, x, y should be scaled
        // only x,y should be translated for 'A', no translation for 'a'

        for (var j = 0; j < args.length; j += 7)            // loop to support multi-arc
        {
          scaledPath += (dvt.ToolkitUtils.roundDecimal(parseFloat(args[j]) * sx) + ' ');                      // rx
          scaledPath += (dvt.ToolkitUtils.roundDecimal(parseFloat(args[j + 1]) * sy) + ' ');                    // ry
          scaledPath += (dvt.ToolkitUtils.roundDecimal(args[j + 2]) + ' ');                                     // x-axis-rotation
          scaledPath += (dvt.ToolkitUtils.roundDecimal(args[j + 3]) + ' ');                                     // large-arc-flag
          scaledPath += (dvt.ToolkitUtils.roundDecimal(args[j + 4]) + ' ');                                     // sweep-flag
          scaledPath += (dvt.ToolkitUtils.roundDecimal(parseFloat(args[j + 5]) * sx + (absCmd ? x : 0)) + ' ');   // x
          scaledPath += (dvt.ToolkitUtils.roundDecimal(parseFloat(args[j + 6]) * sy + (absCmd ? y : 0)) + ' ');   // y
        }
      }
      else
      {
        // For all other cmdTypes, all numbers should be scaled
        // For all absolute cmdTypes, all numbers should be translated

        var scales = [];
        var translates = [];
        if (cmdType.toUpperCase() === 'H')
        {
          scales.push(sx); // All numbers should be scaled by sx
          translates.push(absCmd ? x : 0); // All numbers should be translated by x
        }
        else if (cmdType.toUpperCase() === 'V')
        {
          scales.push(sy); // All numbers should be scaled by sy
          translates.push(absCmd ? y : 0); // All numbers should be translated by y
        }
        else
        {
          // All other commands take a set of points, so even indices should be scaled
          //  by sx, odd indices by sy
          scales.push(sx);
          scales.push(sy);
          // For absolute commands, even indices should be translated by x, odd indices by y
          translates.push(absCmd ? x : 0);
          translates.push(absCmd ? y : 0);
        }

        for (var j = 0; j < args.length; j++)
        {
          var s = scales[j % scales.length];
          var t = translates[j % translates.length];

          scaledPath += (dvt.ToolkitUtils.roundDecimal(parseFloat(args[j]) * s + t) + ' ');  // scale and translate
        }
      }
    }
  }         // end for

  return scaledPath;
};


/**
 * Helper function for path simplification
 * @param {number} xMove The number of pixels that will be moved in the horizontal coordinate space.
 * @param {number} yMove The number of pixels that will be moved in the vertical coordinate space.
 * @param {number} scale The scale to test if the the x/y movement will show
 * @return {boolean} Whether or not the x/y movement will show in the given scale.
 */
dvt.PathUtils._fitsInScale = function(xMove, yMove, scale) {
  return (Math.abs(xMove) > scale || Math.abs(yMove) > scale);
};


/**
 * Simplifies a given path by scaling it down and discarding pixel movements that are too small to be seen in the
 * given scale.
 * @param {array} cmdAr The array of commands and coordinates to be converted.
 * @param {number} scale The scale to simplify the path to.
 * @return {string} The simplified string of path commands and coordinates.
 */
dvt.PathUtils.simplifyPath = function(cmdAr, scale) {
  var cmd;
  var simplifiedCmdStr = '';
  var tempSimplifiedStr = '';
  var partialX = 0;
  var partialY = 0;
  var simplifiedCmd;
  var mx = 0;
  var my = 0;
  // we expect all path commands to start with an m and end with a z
  var numCmds = 0;
  for (var i = 0; i < cmdAr.length; i++) {
    if (isNaN(cmdAr[i])) {
      cmd = cmdAr[i];
      if (cmd == 'Z' || cmd == 'z') {
        simplifiedCmd = cmd;
        tempSimplifiedStr += cmd;
        // if a command only contains move commands i.e. m[x] [y]z, do not add it but keep track of the relative position
        if (numCmds > 0) {
          simplifiedCmdStr += tempSimplifiedStr;
          mx = 0;
          my = 0;
        }
        tempSimplifiedStr = '';
        numCmds = 0;
        partialX = 0;
        partialY = 0;
      }
      continue;
    }

    switch (cmd) {
      case 'M':
        mx = 0;
        my = 0;
      case 'm':
        mx += cmdAr[i];
        my += cmdAr[i + 1];
        tempSimplifiedStr = tempSimplifiedStr + cmd + mx + ' ' + my;
        simplifiedCmd = cmd;
        i++;
        break;
      case 'l':
        partialX += cmdAr[i];
        partialY += cmdAr[i + 1];
        if (dvt.PathUtils._fitsInScale(partialX, partialY, scale)) {
          if (simplifiedCmd != cmd) {
            simplifiedCmd = cmd;
            tempSimplifiedStr += cmd;
          } else {
            tempSimplifiedStr += ' ';
          }
          tempSimplifiedStr = tempSimplifiedStr + partialX + ' ' + partialY;
          partialX = 0;
          partialY = 0;
          numCmds++;
        }
        i++;
        break;
      case 'h':
      case 'v':
        if (cmd == 'h')
          partialX += cmdAr[i];
        else
          partialY += cmdAr[i];
        if (dvt.PathUtils._fitsInScale(partialX, partialY, scale)) {
          if (partialX != 0 && partialY != 0) {
            if (simplifiedCmd != 'l') {
              simplifiedCmd = 'l';
              tempSimplifiedStr += 'l';
            } else {
              tempSimplifiedStr += ' ';
            }
            tempSimplifiedStr = tempSimplifiedStr + partialX + ' ' + partialY;
          } else {
            simplifiedCmd = cmd;
            tempSimplifiedStr = tempSimplifiedStr + cmd + (cmd == 'h' ? partialX : partialY);
          }
          partialX = 0;
          partialY = 0;
          numCmds++;
        }
        break;
      default:
    }
  }
  return simplifiedCmdStr;
};
/**
 * @constructor
 * DvtMarkerDefElem
 */
var DvtMarkerDefElem = function() {
  this.Init();
};

/*
 * make DvtMarkerDefElem a subclass of dvt.Obj
 */
dvt.Obj.createSubclass(DvtMarkerDefElem, dvt.PropMap);

// dvt.MarkerDef Attributes
DvtMarkerDefElem.ATTR_ELEMENTS = 'elements';
DvtMarkerDefElem.ATTR_SHAPE = 'shape';
DvtMarkerDefElem.ATTR_BORDER_COLOR = 'bc';
DvtMarkerDefElem.ATTR_FILL_COLOR = 'fc';
DvtMarkerDefElem.ATTR_FILL_PATTERN = 'fp';
DvtMarkerDefElem.ATTR_FILL_GRADIENT = 'fg';
DvtMarkerDefElem.ATTR_DATA = 'd';
DvtMarkerDefElem.ATTR_POINTS = 'p';
DvtMarkerDefElem.ATTR_LINE_WIDTH = 'lw';

DvtMarkerDefElem.ATTR_FILL_GRAD_COLORS = 'c';
DvtMarkerDefElem.ATTR_FILL_GRAD_STOPS = 'p';
DvtMarkerDefElem.ATTR_FILL_GRAD_BOUNDS = 'b';
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR = 'dir';
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_RADIAL = 'gdR';
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_RIGHT = 'gdRi';
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_DOWN = 'gdD';
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_45 = 'gdD45';
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_135 = 'gdD135';
DvtMarkerDefElem.ATTR_FILL_GRAD_CX = 'cx';
DvtMarkerDefElem.ATTR_FILL_GRAD_CY = 'cy';
DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUS = 'r';
DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUSX = 'rx';
DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUSY = 'ry';

DvtMarkerDefElem.ATTR_ANGLES = 'ang';
DvtMarkerDefElem.ATTR_CLOSURE_TYPE = 'ct';

DvtMarkerDefElem.ATTR_TRANSFORM = 'transform';


/*
 * Initializes the instance.
 */
DvtMarkerDefElem.prototype.Init = function() {
  DvtMarkerDefElem.superclass.Init.call(this);
};


/*-------------------------------------------------------------------------*/
/*   dvt.MarkerDef attributes                                                */
/*-------------------------------------------------------------------------*/


/**
 * Gets the shape of the marker. The list of shapes are :
 * "circle"
 * "ellipse"
 * "line"
 * "path"
 * "polygone"
 * "polyline"
 * "rectangle"
 *
 * @return the shape of the marker
 */
DvtMarkerDefElem.prototype.getShape = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_SHAPE);
};


/**
 * Specifies the shape of the marker. The list of shapes are :
 * "circle"
 * "ellipse"
 * "line"
 * "path"
 * "polygone"
 * "polyline"
 * "rectangle"
 *
 * @param shape the shape of the marker
 */
DvtMarkerDefElem.prototype.setShape = function(shape) {
  this.setProperty(DvtMarkerDefElem.ATTR_SHAPE, shape);
};


/**
 * Gets the data of the component.
 * @return data of the component
 */
DvtMarkerDefElem.prototype.getData = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_DATA);
};


/**
 * Sets the data of the component.
 * @param data data of the component
 */
DvtMarkerDefElem.prototype.setData = function(data) {
  return this.setProperty(DvtMarkerDefElem.ATTR_DATA, data);
};


/**
 * Gets the points of the component.
 * @return points of the component
 */
DvtMarkerDefElem.prototype.getPoints = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_POINTS);
};


/**
 * Sets the points of the component.
 * @param points points of the component
 */
DvtMarkerDefElem.prototype.setPoints = function(points) {
  this.setProperty(DvtMarkerDefElem.ATTR_POINTS, points);
};


/**
 * Gets the closure type of the component.
 * @return closure type of the component
 */
DvtMarkerDefElem.prototype.getClosureType = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_CLOSURE_TYPE);
};


/**
 * Sets the closure type of the component.
 * @param closureType closure type of the component
 */
DvtMarkerDefElem.prototype.setClosureType = function(closureType) {
  this.setProperty(DvtMarkerDefElem.ATTR_CLOSURE_TYPE, closureType);
};


/**
 * Gets the angles of the component.
 * @return angles of the component
 */
DvtMarkerDefElem.prototype.getAngles = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_ANGLES);
};


/**
 * Sets the angles of the component.
 * @param angles angles of the component
 */
DvtMarkerDefElem.prototype.setAngles = function(angles) {
  return this.setProperty(DvtMarkerDefElem.ATTR_ANGLES, angles);
};


/**
 * Gets the border color of the component.
 * @return border color of the component
 */
DvtMarkerDefElem.prototype.getBorderColor = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_BORDER_COLOR);
};


/**
 * Sets the border color of the component.
 * @param borderColor border color of the component
 */
DvtMarkerDefElem.prototype.setBorderColor = function(borderColor) {
  this.setProperty(DvtMarkerDefElem.ATTR_BORDER_COLOR, borderColor);
};


/**
 * Gets the line width of the component.
 * @return line width of the component
 */
DvtMarkerDefElem.prototype.getLineWidth = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_LINE_WIDTH);
};


/**
 * Sets the line width of the component.
 * @param lineWidth line width of the component
 */
DvtMarkerDefElem.prototype.setLineWidth = function(lineWidth) {
  this.setProperty(DvtMarkerDefElem.ATTR_LINE_WIDTH, lineWidth);
};


/**
 * Gets the fill color of the component.
 * @return fill color of the component
 */
DvtMarkerDefElem.prototype.getFillColor = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_COLOR);
};


/**
 * Sets the fill color of the component.
 * @param fillColor fill color of the component
 */
DvtMarkerDefElem.prototype.setFillColor = function(fillColor) {
  this.setProperty(DvtMarkerDefElem.ATTR_FILL_COLOR, fillColor);
};


/**
 * Gets the fill pattern of the component.
 * @return fill pattern of the component
 */
DvtMarkerDefElem.prototype.getFillPattern = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_PATTERN);
};


/**
 * Sets the fill pattern of the component.
 * @param fillPattern fill pattern of the component
 */
DvtMarkerDefElem.prototype.setFillPattern = function(fillPattern) {
  this.setProperty(DvtMarkerDefElem.ATTR_FILL_PATTERN, fillPattern);
};


/**
 * Gets the fill gradient of the component.
 * @return fill gradient of the component
 */
DvtMarkerDefElem.prototype.getFillGradient = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRADIENT);
};


/**
 * Sets the fill gradient of the component.
 * @param fillGradient fill gradient of the component
 */
DvtMarkerDefElem.prototype.setFillGradient = function(fillGradient) {
  this.setProperty(DvtMarkerDefElem.ATTR_FILL_GRADIENT, fillGradient);
};


/**
 *   Gets the gradient color array of the component.
 */

DvtMarkerDefElem.prototype.getGradColors = function() {
  var s = this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_COLORS);
  var a = s.split(',');
  return a;
};

/**
 *   Gets the gradient stops of the component.
 */

DvtMarkerDefElem.prototype.getGradStops = function() {
  var s = this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_STOPS);
  var a = s.split(',');
  dvt.ArrayUtils.toFloat(a);

  return a;
};

/**
 *   Gets the gradient bounds of the component.
 */

DvtMarkerDefElem.prototype.getGradBounds = function() {
  var s = this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_BOUNDS);
  var a = s.split(',');
  dvt.ArrayUtils.toFloat(a);
  return a;
};


/**
 *   Gets the gradient direction.
 */

DvtMarkerDefElem.prototype.getGradDir = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_DIR);
};



/**
 *   Gets the radial gradient radius
 */

DvtMarkerDefElem.prototype.getGradRadius = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUS);
};


/**
 *   Gets the radial gradient x-radius
 */

DvtMarkerDefElem.prototype.getGradRadiusX = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUSX);
};


/**
 *   Gets the radial gradient y-radius
 */

DvtMarkerDefElem.prototype.getGradRadiusY = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUSY);
};

/**
 *   Gets the radial gradient cx.
 */

DvtMarkerDefElem.prototype.getGradCx = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_CX);
};


/**
 *   Gets the radial gradient cxy
 */

DvtMarkerDefElem.prototype.getGradCy = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_CY);
};


/**
 * Gets the transform of the component.
 * @return transform of the component
 */
DvtMarkerDefElem.prototype.getTransform = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_TRANSFORM);
};


/**
 * Sets the transform of the component.
 * @param transform transform of the component
 */
DvtMarkerDefElem.prototype.setTransform = function(transform) {
  return this.setProperty(DvtMarkerDefElem.ATTR_TRANSFORM, transform);
};

/**
 * @constructor
 * dvt.MarkerDef
 */
dvt.MarkerDef = function() {
  this.Init();
};

/*
 * make dvt.MarkerDef a subclass of dvt.Obj
 */
dvt.Obj.createSubclass(dvt.MarkerDef, dvt.PropMap);

dvt.MarkerDef.MARKER_DEF = 'markerDef';

// List of marker shapes
dvt.MarkerDef.MARKER_DEF_CIRCLE = 'c';
dvt.MarkerDef.MARKER_DEF_ELLIPSE = 'o';
dvt.MarkerDef.MARKER_DEF_LINE = 'l';
dvt.MarkerDef.MARKER_DEF_PATH = 'p';
dvt.MarkerDef.MARKER_DEF_POLYGON = 'pg';
dvt.MarkerDef.MARKER_DEF_POLYLINE = 'pl';
dvt.MarkerDef.MARKER_DEF_RECT = 'r';


// dvt.MarkerDef Attributes
dvt.MarkerDef.ATTR_ELEMENTS = 'elements';
dvt.MarkerDef.ATTR_BORDER_COLOR = 'bc';
dvt.MarkerDef.ATTR_LINE_WIDTH = 'lw';
dvt.MarkerDef.ATTR_FILL_COLOR = 'fc';
dvt.MarkerDef.ATTR_FILL_PATTERN = 'fp';
dvt.MarkerDef.ATTR_FILL_GRADIENT = 'fg';



dvt.MarkerDef.BI_DEFAULT_MARKER_SIZE = 9;

dvt.MarkerDef.HUMAN_CMDS = 'M 38.07,36.467856 q 13.414,0 13.414,-13.406 l 0,-9.258 q 0,-13.4039999 -13.414,' +
    '-13.4039999 -13.414,0 -13.414,13.4039999 l 0,9.258 q 0,13.406 13.414,13.406 l 0,0 z m 16.219,7.275 -32.435999,' +
    '0 q -10.139552,0 -15.9400009,7.443875 Q 0.5,58.133383 0.5,69.156856 l 0,54.396004 12.746001,0 0,-51.609004 q 0,' +
    '-2.824 0.793,-2.824 0.742,0 0.742,2.709 l 0,124.267994 q 0,2.82401 2.823999,2.82401 l 12.531,0 q 2.824,0 2.824,' +
    '-2.824 l 0,-66.25 10.219,0 0,66.25 q 0,2.824 2.824,2.824 l 12.528,0 q 2.825,0 2.825,-2.824 l 0,-124.268004 q 0,' +
    '-2.709 0.839,-2.709 0.792,0 0.792,2.824 l 0,51.609004 12.65,0 0,-54.396004 Q 75.6386,58.132927 70.227626,' +
    '51.186731 64.428999,43.742856 54.289,43.742856 l 0,0 z';

dvt.MarkerDef.HUMAN2_CMDS = 'M 306.40625 386.78125 C 304.19988 386.78125 302.40625 389.07579 302.40625 391.90625 ' +
    'C 302.40625 394.73671 304.19988 397.03125 306.40625 397.03125 C 308.61263 397.03125 310.40625 394.73671 310.40625 ' +
    '391.90625 C 310.40625 389.07579 308.61263 386.78125 306.40625 386.78125 z M 301.78125 396.0625 C 300.43025 397.2945 ' +
    '298.28125 400.28125 298.90625 403.15625 C 302.41725 405.79925 309.20225 406.154 314.03125 403 C 314.21825 399.828 ' +
    '312.68325 397.5635 310.90625 396.0625 C 308.65625 400.7185 304.28125 399.7815 301.78125 396.0625 z ';

/** Commands for creating a star shape */
dvt.MarkerDef.SHAPE_STAR_CMDS = [- 50, - 11.22, - 16.69, - 17.94, 0, - 47.55, 16.69, - 17.94, 50, - 11.22, 26.69, 13.8,
  30.9, 47.56, 0, 33.42, - 30.9, 47.56, - 26.69, 13.8];

/*
 * Initializes the instance.
 */
dvt.MarkerDef.prototype.Init = function() {
  dvt.MarkerDef.superclass.Init.call(this);
};



/*-------------------------------------------------------------------------*/
/*   dvt.MarkerDef attributes                                                */
/*-------------------------------------------------------------------------*/


/**
 * Gets the border color of the component.
 * @return border color of the component
 */
dvt.MarkerDef.prototype.getBorderColor = function() {
  return this.getProperty(dvt.MarkerDef.ATTR_BORDER_COLOR);
};


/**
 * Sets the border color of the component.
 * @param borderColor border color of the component
 */
dvt.MarkerDef.prototype.setBorderColor = function(borderColor) {
  this.setProperty(dvt.MarkerDef.ATTR_BORDER_COLOR, borderColor);
};


/**
 * Gets the line width of the component.
 * @return line width of the component
 */
dvt.MarkerDef.prototype.getLineWidth = function() {
  return this.getProperty(dvt.MarkerDef.ATTR_LINE_WIDTH);
};


/**
 * Sets the line width of the component.
 * @param lineWidth line width of the component
 */
dvt.MarkerDef.prototype.setLineWidth = function(lineWidth) {
  this.setProperty(dvt.MarkerDef.ATTR_LINE_WIDTH, lineWidth);
};


/**
 * Gets the fill color of the component.
 * @return fill color of the component
 */
dvt.MarkerDef.prototype.getFillColor = function() {
  return this.getProperty(dvt.MarkerDef.ATTR_FILL_COLOR);
};


/**
 * Sets the fill color of the component.
 * @param fillColor fill color of the component
 */
dvt.MarkerDef.prototype.setFillColor = function(fillColor) {
  this.setProperty(dvt.MarkerDef.ATTR_FILL_COLOR, fillColor);
};


/**
 * Gets the fill pattern of the component.
 * @return fill pattern of the component
 */
dvt.MarkerDef.prototype.getFillPattern = function() {
  return this.getProperty(dvt.MarkerDef.ATTR_FILL_PATTERN);
};


/**
 * Sets the fill pattern of the component.
 * @param fillPattern fill pattern of the component
 */
dvt.MarkerDef.prototype.setFillPattern = function(fillPattern) {
  this.setProperty(dvt.MarkerDef.ATTR_FILL_PATTERN, fillPattern);
};


/**
 * Gets the fill gradient of the component.
 * @return fill gradient of the component
 */
dvt.MarkerDef.prototype.getFillGradient = function() {
  return this.getProperty(dvt.MarkerDef.ATTR_FILL_GRADIENT);
};


/**
 * Sets the fill gradient of the component.
 * @param fillGradient fill gradient of the component
 */
dvt.MarkerDef.prototype.setFillGradient = function(fillGradient) {
  this.setProperty(dvt.MarkerDef.ATTR_FILL_GRADIENT, fillGradient);
};


/**
 * Gets the dimensions of the component.
 * @return dimensions of the component
 */
dvt.MarkerDef.prototype.getDimensions = function() {
  var x = this.getProperty('dx');
  var y = this.getProperty('dy');
  var w = this.getProperty('dw');
  var h = this.getProperty('dh');

  if (w && h) {
    return new dvt.Rectangle(x, y, w, h);
  }
  return null;
};


/**
 * Gets the elements of the marker. The list of elementss are :
 *
 * @return the elements of the marker
 */
dvt.MarkerDef.prototype.getElements = function() {
  return this.getProperty(dvt.MarkerDef.ATTR_ELEMENTS);
};


/**
 * Add an element to the marker.
 *
 * @param {DvtMarkerDefElem} element to be added
 */
dvt.MarkerDef.prototype.addElement = function(element) {
  var elems = this.getElements();
  if (! elems) {
    elems = [];
    this.setProperty(dvt.MarkerDef.ATTR_ELEMENTS, elems);
  }
  elems.push(element);
};


// TODO NAMESPACE: Candidate for move to DvtAfComponent
dvt.MarkerGradient = function() {};

dvt.Obj.createSubclass(dvt.MarkerGradient, dvt.Obj);

dvt.MarkerGradient.createMarkerGradient = function(color, marker, opacity)
{
  var arColors = [];
  var arRatios = [];
  var arAlphas = [opacity, opacity, opacity, opacity];
  var gfs = null;

  var shapeType = marker.getType();
  var dim = dvt.DisplayableUtils.getDimForced(marker.getCtx(), marker);
  var center = dim.getCenter();
  var size = Math.min(dim.w, dim.h);

  if (shapeType != dvt.Marker.HUMAN)
  {
    arRatios = [0.0, 0.5, 0.75, 1];
    var c0 = dvt.ColorUtils.getPastel(color, 0.20);
    var c1 = dvt.ColorUtils.getPastel(color, 0.10);
    var c2 = dvt.ColorUtils.getDarker(color, 0.8);

    var radius = size / 2.0;
    var cx = center.x;
    var cy = center.y;
    var arColors = [dvt.ColorUtils.getPound(c0), dvt.ColorUtils.getPound(c1), color, dvt.ColorUtils.getPound(c2)];
    var bound = new dvt.Rectangle(-radius, -radius, radius * 2.0, radius * 2.0);
    var arBound = [bound.x, bound.y, bound.w, bound.h];
    gfs = new dvt.RadialGradientFill(arColors, arAlphas, arRatios, cx, cy, radius, arBound);
  } else
  {
    arRatios = [0.0, 0.3, 0.7, 1];
    var c0 = dvt.ColorUtils.getPastel(color, 0.20);
    var c1 = dvt.ColorUtils.getDarker(color, 0.9);
    var c2 = dvt.ColorUtils.getDarker(color, 0.8);
    var arColors = [dvt.ColorUtils.getPound(c0), dvt.ColorUtils.getPound(c1), color, dvt.ColorUtils.getPound(c2)];
    var bound = new dvt.Rectangle(-size / 2.0, -size / 2.0, size, size);
    var arBound = [bound.x, bound.y, bound.w, bound.h];
    gfs = new dvt.LinearGradientFill(135, arColors, arAlphas, arRatios, arBound);
  }

  return gfs;
};
/**
 * dvt.MarkerUtils
 */
dvt.MarkerUtils = {_cache: {}};

dvt.Obj.createSubclass(dvt.MarkerUtils, dvt.Obj);


/**
 * @this {dvt.MarkerUtils}
 * parse markerDefXmlString and return a markerDef object
 */
dvt.MarkerUtils.createMarkerDef = function(context, markerDefNode) {

  var markerDef = new dvt.MarkerDef();
  markerDef.setProperties(markerDefNode.getAttributes());

  var childNodes = markerDefNode.getChildNodes();
  var childElems;

  for (var i = 0; i < childNodes.length; i++) {
    var child = childNodes[i];
    if (child) {
      childElems = new DvtMarkerDefElem();

      if (child.getName() == 'fillDef') {
        if (child.getChildNodes()) {
          child = child.getChildNodes()[0];    // want the child ( e.g. <g> )
        }
      }

      childElems.setProperties(child.getAttributes());
      childElems.setShape(child.getName());
      markerDef.addElement(childElems);
    }
  }

  if (markerDef) {
    this._addMarkerDef(context, markerDef);
  }
  return markerDef;
};


/**
 * @this {dvt.MarkerUtils}
 * add a markerDef object to the marker list
 */
dvt.MarkerUtils._addMarkerDef = function(context, markerDef) {
  var stageId = context.getStage().getId();
  var markerId = markerDef.getId();
  var markerList = dvt.MarkerUtils.getMarkerList(stageId);

  //first look for a cached copy of the custom marker
  //if not found, add to the custom marker list
  if (! markerList[markerId]) {
    var marker = this.createMultiPaths(context, markerDef, markerId);
    if (marker) {
      // set id on the root
      marker.setId('custom' + markerId);
      markerList[markerId] = marker;

      // get custom dimensions and cache it in the shape object
      var dim = markerDef.getDimensions();
      if (dim) {
        dvt.DisplayableUtils._setDimForced(marker, dim);
      }
    }
  }
};


/**
 * @this {dvt.MarkerUtils}
 * Get Custom Marker List
 */
dvt.MarkerUtils.getMarkerList = function(stageId)
{
  if (!this._cache[stageId]) {
    this._cache[stageId] = {};
  }
  return this._cache[stageId];
};


/**
 * @this {dvt.MarkerUtils}
 * Returns a dvt.Path
 *
 * @param context  the context
 * @param markerDef the custom marker definition
 */
dvt.MarkerUtils.createMarkerShape = function(context, markerDefElem, markerDef, markerId) {

  var marker;
  var type = markerDefElem.getShape();

  if (type == dvt.MarkerDef.MARKER_DEF_PATH) {
    marker = this.createPathMarker(context, markerDefElem, markerId);
  }
  /*
  else if (type == dvt.MarkerDef.MARKER_DEF_CIRCLE ||
      type == dvt.MarkerDef.MARKER_DEF_ELLIPSE) {
    marker = this.createCircleMarker(context, markerDef, markerId, type);
  }
  else if (type == dvt.MarkerDef.MARKER_DEF_LINE) {
    marker = this.createLineMarker(context, markerDef, markerId);
  }
  else if (type == dvt.MarkerDef.MARKER_DEF_POLYGON) {
    marker = this.createPolygoneMarker(context, markerDef, markerId);
  }
  else if (type == dvt.MarkerDef.MARKER_DEF_POLYLINE) {
    marker = this.createPolylineMarker(context, markerDef, markerId);
  }
  else if (type == dvt.MarkerDef.MARKER_DEF_RECT_TYPE) {
    marker = this.createRectMarker(context, markerDef, markerId);
  }
  */

  //set common attributes
  if (marker) {
    dvt.MarkerUtils.setCommonAttrs(markerDefElem, markerDef, marker);
  }

  return marker;
};


/**
 * @type {dvt.Path or dvt.Container (contains a list of DvtPaths)}
 */
dvt.MarkerUtils.createMultiPaths = function(context, markerDef, markerId) {
  var shapes = markerDef.getElements();
  if (! shapes || shapes.length == 0)
    return null;

  var root;
  if (shapes.length == 1) {
    root = dvt.MarkerUtils.createMarkerShape(context, shapes[0], markerDef, markerId);
  }
  else {
    root = new dvt.Container(context, markerId);
    var child;
    var childElem;
    for (var i = 0; i < shapes.length; i++) {
      child = shapes[i];
      childElem = dvt.MarkerUtils.createMarkerShape(context, child, markerDef, markerId + '_' + i);
      if (childElem)
        root.addChild(childElem);
    }
  }
  return root;

};

// type: circle or ellipse
dvt.MarkerUtils.createCircleMarker = function(context, markerDef, markerId, type) {
  var points = markerDef.getPoints();
  var cx = points[0];
  var cy = points[1];
  var rx = points[2];
  var ry;
  if (type == dvt.MarkerDef.MARKER_DEF_ELLIPSE) {
    ry = points[3];
  }
  var marker;
  var closureType = markerDef.getClosureType();
  if (closureType) {
    var angles = markerDef.getAngles();
    var anglesStart;
    var anglesExtent;
    if (angles) {
      anglesStart = angles[0];
      anglesExtent = angles[1];
    }
    marker = new dvt.Arc(context, cx, cy, rx, ry,
        anglesStart, anglesExtent, closureType, markerId);
  }
  else {
    marker = new dvt.Circle(context, cx, cy, rx, markerId);
  }

  return marker;
};


dvt.MarkerUtils.createRectMarker = function(context, markerDef, markerId) {
  var points = markerDef.getPoints();
  var x = points[0];
  var y = points[1];
  var w = points[2];
  var h = points[3];

  return new dvt.Rect(context, x, y, w, h, markerId);
};


dvt.MarkerUtils.createLineMarker = function(context, markerDef, markerId) {
  var points = markerDef.getPoints();
  var x1 = points[0];
  var y1 = points[1];
  var x2 = points[2];
  var y2 = points[3];

  return new dvt.Line(context, x1, y1, x2, y2, markerId);
};

dvt.MarkerUtils.createPathMarker = function(context, markerDefElem, markerId) {
  var data = markerDefElem.getData();

  return new dvt.Path(context, data, markerId);
};


dvt.MarkerUtils.createPolygoneMarker = function(context, markerDef, markerId) {
  var points = markerDef.getPoints();

  return new dvt.Polygon(context, points, markerId);
};


dvt.MarkerUtils.createPolylineMarker = function(context, markerDef, markerId) {
  var points = markerDef.getPoints();

  return new dvt.Polyline(context, points, markerId);
};


dvt.MarkerUtils.setCommonAttrs = function(markerDefElem, markerDef, marker) {
  // solid, gradient, pattern fill?
  var fc = markerDefElem.getFillColor();
  var fa = null; //TODO getAlpha
  var fg = markerDefElem.getFillGradient();
  var fp = markerDefElem.getFillPattern();

  if (fp) {
    marker.setFill(new dvt.PatternFill(fp, fc));
  }
  else if (fg) {                           // look for matching fillDef gradient id
    var elems = markerDef.getElements();
    var fd;
    var len = elems.length;
    for (var i = 0; i < len; i++) {
      var fillDef = elems[i];
      if (fillDef.getShape() == 'g' && fillDef.getId() == fg) {
        fd = fillDef;
        break;
      }
    }

    var stops;
    var bounds;
    var dir;
    var gradCx;
    var gradCy;
    var rad;
    if (fd) {
      fc = fd.getGradColors();
      stops = fd.getGradStops();
      bounds = fd.getGradBounds();
      dir = fd.getGradDir();
      if (dir == DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_RADIAL) {
        gradCx = parseFloat(fd.getGradCx());
        gradCy = parseFloat(fd.getGradCy());
        rad = parseFloat(fd.getGradRadius());
        if (! rad) {
          var radX = parseFloat(fd.getGradRadiusX());    // svg doesn't support rx, ry
          var radY = parseFloat(fd.getGradRadiusY());
          rad = Math.max(radX, radY);
        }
        marker.setFill(new dvt.RadialGradientFill(fc, fa, stops, gradCx, gradCy, rad, bounds));
      }
      else {
        var angle = 0;
        if (dir == DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_45)
          angle = -135;
        else if (dir == DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_135)
          angle = -45;
        else if (dir == DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_DOWN)
          angle = -90;
        marker.setFill(new dvt.LinearGradientFill(angle, fc, fa, stops, bounds));
      }
    }
    else {
      marker.setFill(new dvt.LinearGradientFill(0, ['#000', '#fff']));
    }
  }
  else if (fc || fa) {
    marker.setSolidFill(fc, fa);
  }

  var lw = parseFloat(markerDefElem.getLineWidth());
  var bc = markerDefElem.getBorderColor();

  if (lw || bc) {
    if (! lw)
      lw = 1;
    if (! bc)
      bc = 'black';

    var stroke = new dvt.SolidStroke(bc, 1, lw);
    marker.setStroke(stroke);
  }

};


/**
 * get a markerDef from the marker list
 * @type {dvt.Path or dvt.Container (contains a list of DvtPaths)}
 */
dvt.MarkerUtils.getCustomMarkerInfo = function(context, markerId) {
  var stageId = context.getStage().getId();
  var markerList = dvt.MarkerUtils.getMarkerList(stageId);

  if (markerList) {
    return markerList[markerId];
  }
  else {
    return undefined;
  }
};


/**
 * Returns the built in marker shape given the marker type and skin
 * @param {dvt.Context} The platform specific context object
 * @param {String} markerType The marker type
 * @param {String} skin The skin name
 * @return {dvt.Shape} The built in marker shape
 */
dvt.MarkerUtils.getBuiltinMarkerInfo = function(context, markerType, skin) {
  var stageId = context.getStage().getId();
  var markerList = dvt.MarkerUtils.getMarkerList(stageId);
  var markerId = skin ? markerType + '_' + skin : markerType;
  var defId = markerList[markerId];
  // if the marker is not in cache, add it to markerList
  if (! defId) {
    if (markerType) {
      var tmarker = new dvt.Path(context, dvt.CSSStyle.afterSkinAlta(skin) ? dvt.MarkerDef.HUMAN2_CMDS : dvt.MarkerDef.HUMAN_CMDS, 'dvtHuman');
      // cache the dimensions in the shape object
      dvt.DisplayableUtils.getDimForced(context, tmarker);
      markerList[markerId] = tmarker;
    }
  }
  return markerList[markerId];
};


/**
 * @this {dvt.MarkerUtils}
 * For internal use only
 */
dvt.MarkerUtils.clearCached = function(context) {
  var stageId = context.getStage().getId();
  this._cache[stageId] = undefined;
};


// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * Utility functions for polygons.
 * @class
 */
dvt.PolygonUtils = {};

dvt.Obj.createSubclass(dvt.PolygonUtils, dvt.Obj);


/**
 * Returns the bounding box of the supplied polygon coords.
 * @param {Array} aPts an array of consecutive x,y coordinate pairs.
 * @return {dvt.Rectangle} the bounding box of the supplied polygon.
 */
dvt.PolygonUtils.getDimensions = function(aPts)
{
  if ((! aPts) || (aPts.length === 0)) {
    return new dvt.Rectangle();
  }

  var minX = Number.MAX_VALUE;
  var maxX = Number.MIN_VALUE;
  var minY = Number.MAX_VALUE;
  var maxY = Number.MIN_VALUE;

  var len = aPts.length;
  var x, y;
  for (var i = 0; i < len; i++) {

    x = aPts[i++];
    y = aPts[i];
    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y);
  }

  return new dvt.Rectangle(minX, minY, Math.abs(maxX - minX), Math.abs(maxY - minY));
};


/**
 * Gets the points array for a regular polygon with n sides and radius r.
 * @param {number} cx Center x.
 * @param {number} cy Center y.
 * @param {number} n The number of sides.
 * @param {number} r the radius (distance from center to vertex).
 * @param {number} theta The angle of the first vertex (from top center).
 * @param {number=} direction 1 for clockwise, 0 for counter-clockwise. Default is clockwise.
 * @return {array} Points array.
 * @private
 */
dvt.PolygonUtils.getRegularPolygonPoints = function(cx, cy, n, r, theta, direction) {
  var points = [];
  var angle;
  for (var i = 0; i < n; i++) {
    angle = theta + (i / n * 2 * Math.PI) * (direction == 0 ? -1 : 1);
    points.push(cx + r * Math.sin(angle), cy - r * Math.cos(angle));
  }
  return points;
};


/**
 * Scales and returns the points array for a polygon.
 * @param {array} points
 * @param {number} sx
 * @param {number} sy
 * @return {array}
 */
dvt.PolygonUtils.scale = function(points, sx, sy) {
  var ret = [];
  for (var i = 0; i < points.length - 1; i += 2) {
    ret.push(points[i] * sx);
    ret.push(points[i + 1] * sy);
  }
  return ret;
};


/**
 * Translates and returns the points array for a polygon.
 * @param {array} points
 * @param {number} tx
 * @param {number} ty
 * @return {array}
 */
dvt.PolygonUtils.translate = function(points, tx, ty) {
  var ret = [];
  for (var i = 0; i < points.length - 1; i += 2) {
    ret.push(points[i] + tx);
    ret.push(points[i + 1] + ty);
  }
  return ret;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Utility functions for text.
 * @class
 */
dvt.TextUtils = {};

dvt.Obj.createSubclass(dvt.TextUtils, dvt.Obj);

/** @private */
dvt.TextUtils._cachedTextDimensions = {};
/** @const */
dvt.TextUtils.EMPTY_TEXT_BUFFER = 2;

/**
 * Returns the maximum dimensions for the dvt.OutputText objects in the specified array.
 * @param {array} textArray An array of dvt.OutputText objects.
 * @return {dvt.Dimension}
 */
dvt.TextUtils.getMaxTextDimensions = function(textArray) {
  var maxWidth = 0;
  var maxHeight = 0;

  for (var i = 0; i < textArray.length; i++) {
    if (textArray[i] == null)
      continue;

    var dims = textArray[i].getDimensions();
    maxWidth = Math.max(maxWidth, dims.w);
    maxHeight = Math.max(maxHeight, dims.h);
  }

  return new dvt.Dimension(maxWidth, maxHeight);
};

/**
 * Returns the text dimensions (width and height) given a textString and cssStyle. It looks up the the cache,
 * and creates a text elem only if the value is not found in the cache.
 * @param {dvt.Context} context
 * @param {string} textString
 * @param {dvt.CSSStyle} cssStyle
 * @return {dvt.Rectangle} The text dimensions. Only the w and h should be used. The x and y are meaningless.
 */
dvt.TextUtils.getTextStringDimensions = function(context, textString, cssStyle) {
  // Look for the value in the cache and return it if found. Otherwise, create an elem and measure the dimensions.
  var cachedDims = dvt.OutputText.getCachedDimensions(textString, cssStyle);
  if (cachedDims != null)
    return cachedDims;
  else {
    var text = new dvt.OutputText(context, textString);
    text.setCSSStyle(cssStyle);
    return text.getDimensions();
  }
};

/**
 * Returns the text width given a dvt.OutputText.
 * @param {dvt.OutputText} text
 * @return {number} The text height.
 */
dvt.TextUtils.getTextWidth = function(text) {
  // getDimensions is already optimized to take advantage of cache. This function exists only for API consistency.
  return text.getDimensions().w;
};

/**
 * Returns the text width given a textString and cssStyle.
 * @param {dvt.Context} context
 * @param {string} textString
 * @param {dvt.CSSStyle} cssStyle
 * @return {number} The text width.
 */
dvt.TextUtils.getTextStringWidth = function(context, textString, cssStyle) {
  return dvt.TextUtils.getTextStringDimensions(context, textString, cssStyle).w;
};

/**
 * Returns the text height given a dvt.OutputText.
 * @param {dvt.OutputText} text
 * @return {number} The text height.
 */
dvt.TextUtils.getTextHeight = function(text) {
  return dvt.TextUtils.guessTextDimensions(text).h;
};

/**
 * Returns the text height given a cssStyle.
 * @param {dvt.Context} context
 * @param {dvt.CSSStyle} cssStyle
 * @return {number} The text height.
 */
dvt.TextUtils.getTextStringHeight = function(context, cssStyle) {
  // Check whether a cached size is already available
  var cssStyleKey = (cssStyle != null) ? cssStyle.hashCodeForTextMeasurement() : '';
  var cachedDims = dvt.TextUtils._cachedTextDimensions[cssStyleKey];
  if (cachedDims == null) {
    var text = new dvt.OutputText(context);
    text.setCSSStyle(cssStyle);
    cachedDims = dvt.TextUtils._cacheRepresentativeDimensions(text, cssStyleKey);
  }

  return cachedDims.h;
};

/**
 * Conservatively estimates the width and height of the specified text object.  This function uses a cache to
 * guess the width and height of the specified text string.  This function relies on the fact that
 * all text strings with the same CSS style return the same height from getDimensions.  Users of
 * this function can avoid expensive getDimensions calls when checking to see if a text string
 * would fit in a certain size.
 * @param {dvt.OutputText} text
 * @param {number=} minChars The minimum number of characters that should be displayed before ellipsis if
 *                            truncation occurs. If this argument is skipped, the default is 1 character.
 * @return {Object} An object with fields w, h, and wMin.  w and h correspond to the conservative estimate of the
 *                  text size, while wMin corresponds to the minimum width necessary to show truncated text with the
 *                  specified minimum number of characters.
 */
dvt.TextUtils.guessTextDimensions = function(text, minChars) {
  var textString = text.getTextString();
  var cssStyle = text.getCSSStyle();
  var cssStyleKey = (cssStyle != null) ? cssStyle.hashCodeForTextMeasurement() : '';

  // Check whether a cached size is already available
  var cachedDims = dvt.TextUtils._cachedTextDimensions[cssStyleKey];

  // Compute the dimensions of a representative character and add to the cache
  if (cachedDims == null)
    cachedDims = dvt.TextUtils._cacheRepresentativeDimensions(text, cssStyleKey);

  // Use the cached size to guess at the string length
  var w = cachedDims.w * dvt.TextUtils._getTextLength(textString);

  // Esimate the minimum truncated length using fudge factor and by estimating the ellipsis as 2 characters
  minChars = (isNaN(minChars) || minChars == null) ? 1 : minChars;
  var wMin = Math.min(0.3 * w, cachedDims.w * ((0.3 * minChars) + 2));

  if ((text instanceof dvt.MultilineText) || (text instanceof dvt.BackgroundMultilineText))
    return {w: w, h: cachedDims.h * text.getLineCount(), wMin: wMin};
  return {w: w, h: cachedDims.h, wMin: wMin};
};

/**
 * Fits text in the provided space. This function uses dvt.TextUtils.guessTextDimensions before calling setMaxWidth
 * in order to avoid expensive getDimensions calls. It adds the text to the container, and removes it if the text cannot
 * fit at all in the container.
 * @param {dvt.OutputText} text
 * @param {number} maxWidth The maximum width of the text
 * @param {number} maxHeight The maximum height of the text
 * @param {dvt.Container} container The parent of the text
 * @param {number=} minChars The minimum number of characters that should be displayed before ellipsis if
 *                            truncation occurs. If this argument is skipped, the default is 1 character.
 * @return {boolean} false if the text cannot fit at all, true otherwise.
 */
dvt.TextUtils.fitText = function(text, maxWidth, maxHeight, container, minChars) {
  minChars = (isNaN(minChars) || minChars == null) ? 1 : minChars;
  var untruncatedTextString = text.getTextString();

  var guess = dvt.TextUtils._guessFit(text, maxWidth, maxHeight, container, minChars);
  if (guess == true) {
    container.addChild(text);
    return true;
  }
  else if (guess == false) {
    // Remove from parent in this case to be consistent
    var parent = text.getParent();
    if (parent)
      parent.removeChild(text);

    return false;
  }

  // At this point, truncation may be needed.  Try to truncate the text.
  container.addChild(text);

  if (text instanceof dvt.MultilineText || text instanceof dvt.BackgroundMultilineText) {
    // dvt.OutputText will manage removal from container and setting of untruncated text string
    return text.__fitText(maxWidth, maxHeight, minChars);
  }
  else if (text instanceof dvt.OutputText || text instanceof dvt.BackgroundOutputText)
    dvt.TextUtils._truncateOutputText(text, maxWidth, minChars);
  else
    text.setMaxWidth(maxWidth, minChars);

  // Check if the truncated text can fit
  if (text.getTextString() == '') {
    container.removeChild(text);
    return false;
  }
  else {
    if (text.getTextString() != untruncatedTextString)
      text.setUntruncatedTextString(untruncatedTextString);

    return true;
  }
};

/**
 * Creates and adds an 'Empty Text' message to a container
 * @param {dvt.Container} container The container to add the empty text message to
 * @param {string} textStr The emtpy text message
 * @param {dvt.Rectangle} space The available space to render the emtpy text message in
 * @param {dvt.EventManager} eventManager The event manager to associate any tooltips with for truncated text
 * @param {dvt.CSSStyle} style The CSS style to apply to the empty text
 * @return {dvt.OutputText}
 */
dvt.TextUtils.renderEmptyText = function(container, textStr, space, eventManager, style) {
  // Create and position the text
  var text = new dvt.OutputText(container.getCtx(), textStr, space.x + space.w / 2, space.y + space.h / 2);
  if (style)
    text.setCSSStyle(style);
  text.alignCenter();
  text.alignMiddle();

  // Truncate the text to fit horizontally.  Note, we do not account for vertical size, because displaying a
  // cut off "No Data" message is better than displaying none at all.
  var maxWidth = space.w - 2 * dvt.TextUtils.EMPTY_TEXT_BUFFER;
  if (dvt.TextUtils.fitText(text, maxWidth, Infinity, container, 0)) {
    // Add tooltip if truncated
    if (text.isTruncated())
      eventManager.associate(text, new dvt.SimpleObjPeer(text.getUntruncatedTextString()));

    // WAI-ARIA
    text.setAriaProperty('hidden', null);
  }
  return text;
};

/**
 * Caches the size of representative characters for the cssStyleKey using the dvt.OutputText instance.
 * @param {dvt.OutputText} text
 * @param {string} cssStyleKey The key to use for caching.
 * @return {object} An object with fields w and h.
 * @private
 */
dvt.TextUtils._cacheRepresentativeDimensions = function(text, cssStyleKey) {
  // Measure M and W, which are usually the longest characters. Also safe for CJK, which is always monospace.
  var textString = text.getTextString();
  text.setTextString(dvt.OutputText.REPRESENTATIVE_TEXT);
  var dims = text.measureDimensions();
  text.setTextString(textString);

  // Cache the dims of a single character. Conservative because real strings are not solely longest characters.
  var cachedDims = {w: 0.50 * dims.w, h: dims.h};
  dvt.TextUtils._cachedTextDimensions[cssStyleKey] = cachedDims;
  return cachedDims;
};

/**
 * Centers text vertically adjusting for browser alignment differences
 * @param {object} text The text needed to be centered. Can be either dvt.OutputText or dvt.MultilineText.
 * @param {number} centerY The y axis midpoint of the bounds.
 */
dvt.TextUtils.centerTextVertically = function(text, centerY) {
  if (dvt.Agent.isPlatformIE()) {
    text.setY(centerY);
    text.alignMiddle();
  }
  else {
    var textHeight = 0;
    if (text instanceof dvt.OutputText)
      textHeight = dvt.TextUtils.getTextHeight(text);
    else if (text instanceof dvt.MultilineText)
      textHeight = text.getDimensions().h;
    text.setY(centerY - textHeight / 2);
  }
};

/**
 * Uses estimates to quickly determine whether the text can fit in the specified area.  Returns true if the text will
 * definitely fit, false if the text will definitely not fit, and null if further calculation is needed.
 * @param {dvt.OutputText} text
 * @param {number} maxWidth The maximum width of the text
 * @param {number} maxHeight The maximum height of the text
 * @param {dvt.Container} container The parent of the text
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis
 * @return {object} false if the text won't fit, true if it will, null if further calculation needed
 * @private
 */
dvt.TextUtils._guessFit = function(text, maxWidth, maxHeight, container, minChars) {
  if (text instanceof dvt.MultilineText) {
    // Can optimize in the future if needed
    return null;
  }
  else {
    // Estimate the dims conservatively
    var estimatedDims = dvt.TextUtils.guessTextDimensions(text, minChars);

    // The "estimated" height is always accurate and estimated min width is conservative. Safe to quit if it doesn't
    // fit. Don't quit if the string is short, since the cache is less accurate.
    if (estimatedDims.h > maxHeight || (estimatedDims.wMin > maxWidth && dvt.TextUtils._getTextLength(text.getTextString()) > 3))
      return false;

    // The estimated width is conservative, ensuring that truncation is not necessary if the estimate < maxWidth.
    if (estimatedDims.w < maxWidth)
      return true;

    // No determination could be made
    return null;
  }
};


/**
 * Truncates the text instance to fit within the given width.  Sets the text string of the text to an empty string if
 * truncated text does not fit.
 * @param {dvt.OutputText} text The text instance to be truncated.
 * @param {number} maxWidth The maximum width of the text.
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis after truncation.
 * @private
 */
dvt.TextUtils._truncateOutputText = function(text, maxWidth, minChars) {
  // Initial check using accurate dimensions
  var dims = text.measureDimensions();
  if (dims.w <= maxWidth)
    return;

  // Determine avg pixels per char and make an initial guess at the truncation
  var textString = text.getTextString();
  var textLength = textString.length;
  var avgPixelsPerChar = dims.w / dvt.TextUtils._getTextLength(textString);
  var maxNumChars = Math.max(Math.floor(maxWidth / avgPixelsPerChar) - 2, minChars); // Subtract 2 for the ellipsis

  // Determine whether we can use context to measure text.
  // If so, don't need to call getDimensions() at all, and only need to setTextString() at the very end.
  var truncatedTextString = textString.substring(0, maxNumChars) + dvt.OutputText.ELLIPSIS;
  text.setTextString(truncatedTextString);
  dims = text.measureDimensions();

  // Add characters if initial guess is too short.  Keep track of the previous string and dims in case we overshoot
  var prevTextString = truncatedTextString;
  var prevDims = dims;
  while (dims.w < maxWidth) {
    if (maxNumChars >= textString.length)
      break;

    // Calculate the availWidth and use that to estimate the number of characters to increment
    var availWidth = maxWidth - dims.w;

    // estimatedIncrement: The smaller of the chars remaining and the estimate of characters than can fit
    var estimatedIncrement = Math.min(textLength - maxNumChars, Math.max(Math.floor(availWidth / avgPixelsPerChar), 1));

    // Add chars and measure again
    maxNumChars += estimatedIncrement;
    truncatedTextString = textString.substring(0, maxNumChars) + dvt.OutputText.ELLIPSIS;
    text.setTextString(truncatedTextString);
    dims = text.measureDimensions();

    // If we overshot and the increment was only 1, then restore the old string
    if (estimatedIncrement == 1 && dims.w > maxWidth) {
      text.setTextString(prevTextString);
      dims = prevDims;
      break;
    }

    // Otherwise update the previous string and dims
    prevTextString = truncatedTextString;
    prevDims = dims;
  }

  // Remove characters if initial guess is too long
  while (dims.w > maxWidth) {
    if (maxNumChars <= minChars) {
      // minChars doesn't fit, return ""
      text.setTextString('');
      break;
    }

    // Truncate 1 char at a time
    maxNumChars -= 1;
    truncatedTextString = textString.substring(0, maxNumChars) + dvt.OutputText.ELLIPSIS;
    text.setTextString(truncatedTextString);
    dims = text.measureDimensions();
  }
};


/**
 * Returns the number of characters in a text string after stripping off the zero-width characters.
 * @param {string} textString
 * @return {number} String length excluding the zero-width characters
 * @private
 */
dvt.TextUtils._getTextLength = function(textString) {
  textString = textString.replace(/[\u200A\u200B\u200C\u200D\u200E\u200F\uFEFF]/g, '');
  return textString.length;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 *   Static Shape Utility Functions
 *   @class dvt.SvgShapeUtils
 *   @constructor
 */
dvt.SvgShapeUtils = function()
{};

dvt.Obj.createSubclass(dvt.SvgShapeUtils, dvt.Obj);

/**
 * @private
 */
dvt.SvgShapeUtils._uniqueSeed = 0;  // for unique Id creation

/**
 * Adds a clipping region to the global defs element.
 * @param {dvt.ClipPath} cp The dvt.ClipPath object specifying the clipping region(s).
 * @param {dvt.Context} context The rendering context.
 * @return {boolean} True if the clipping paths was successfully or already added, else false.
 */
dvt.SvgShapeUtils.addClipPath = function(cp, context) {
  var id = cp.getId();
  if (! id) {
    return false;    // essential to have an id to reference
  }

  var elemDefs = context.getDefs();
  if (! elemDefs) {
    return false;
  }

  // Check if clipping path for this id is already defined.
  var defsChildren = elemDefs.childNodes;
  var len = defsChildren.length;
  for (var i = 0; i < len; i++) {
    var el = defsChildren[i];
    if (el.id === id)
      return true;
  }

  var elemClip = dvt.SvgShapeUtils.createElement('clipPath', id);
  context.appendDefs(elemClip);

  var regions = cp.getRegions();
  for (var i = 0; i < regions.length; i++) {
    var region = regions[i];
    if (region) {
      var elem = null;
      if (region.type === dvt.ClipPath.RECT) {
        elem = dvt.SvgShapeUtils.createElement('rect');
        dvt.ToolkitUtils.setAttrNullNS(elem, 'x', region.x);
        dvt.ToolkitUtils.setAttrNullNS(elem, 'y', region.y);
        dvt.ToolkitUtils.setAttrNullNS(elem, 'width', region.w);
        dvt.ToolkitUtils.setAttrNullNS(elem, 'height', region.h);
        if (region.rx)
          dvt.ToolkitUtils.setAttrNullNS(elem, 'rx', region.rx);
        if (region.ry)
          dvt.ToolkitUtils.setAttrNullNS(elem, 'ry', region.ry);
      }
      else if (region.type === dvt.ClipPath.PATH) {
        elem = dvt.SvgShapeUtils.createElement('path');
        dvt.ToolkitUtils.setAttrNullNS(elem, 'd', region.d);
      }
      else if (region.type === dvt.ClipPath.POLYGON) {
        elem = dvt.SvgShapeUtils.createElement('polygon');
        dvt.ToolkitUtils.setAttrNullNS(elem, 'points', region.points);
      }
      else if (region.type === dvt.ClipPath.ELLIPSE) {
        elem = dvt.SvgShapeUtils.createElement('ellipse');
        dvt.ToolkitUtils.setAttrNullNS(elem, 'cx', region.cx);
        dvt.ToolkitUtils.setAttrNullNS(elem, 'cy', region.cy);
        dvt.ToolkitUtils.setAttrNullNS(elem, 'rx', region.rx);
        dvt.ToolkitUtils.setAttrNullNS(elem, 'ry', region.ry);
      }
      else if (region.type === dvt.ClipPath.CIRCLE) {
        elem = dvt.SvgShapeUtils.createElement('circle');
        dvt.ToolkitUtils.setAttrNullNS(elem, 'cx', region.cx);
        dvt.ToolkitUtils.setAttrNullNS(elem, 'cy', region.cy);
        dvt.ToolkitUtils.setAttrNullNS(elem, 'r', region.r);
      }

      if (elem)
        dvt.ToolkitUtils.appendChildElem(elemClip, elem);
    }
  }

  return true;
};

/**
 * Adds a mask to the global defs element.
 * @param {dvt.Mask} mask The mask to add to the global defs
 * @param {dvt.Context} context The context to add the gradient defs element to
 * @return {boolean} True if the mask was successfully or already added, else false
 */
dvt.SvgShapeUtils.addMask = function(mask, context) {
  var id = mask.getId();
  if (!id) {
    return false;
  }

  var elemDefs = context.getDefs();
  if (!elemDefs) {
    return false;
  }

  // Check if mask for this id is already defined
  var defsChildren = elemDefs.childNodes;
  var len = defsChildren.length;
  for (var i = 0; i < len; i++) {
    var el = defsChildren[i];
    if (el.id === id)
      return true;
  }

  var elemMask = dvt.SvgShapeUtils.createElement('mask', id);
  context.appendDefs(elemMask);

  var gradient = mask.getGradient();
  dvt.SvgShapeUtils.addSpecialFill(gradient, context);

  var bounds = mask.getBounds();
  var rectElem = dvt.SvgShapeUtils.createElement('rect');
  dvt.ToolkitUtils.setAttrNullNS(rectElem, 'x', bounds.x);
  dvt.ToolkitUtils.setAttrNullNS(rectElem, 'y', bounds.y);
  dvt.ToolkitUtils.setAttrNullNS(rectElem, 'width', bounds.w);
  dvt.ToolkitUtils.setAttrNullNS(rectElem, 'height', bounds.h);
  dvt.ToolkitUtils.setAttrNullNS(rectElem, 'fill', dvt.ToolkitUtils.getUrlById(gradient.getId()));
  dvt.ToolkitUtils.appendChildElem(elemMask, rectElem);
  return true;
};

/**
 * Adds a gradient or linear fill to the global defs element.
 * @param {dvt.GradientFill|dvt.PatternFill} fill The fill to add to the global defs
 * @param {dvt.Context} context The context to add the gradient defs element to
 */
dvt.SvgShapeUtils.addSpecialFill = function(fill, context) {
  var id;
  if (!fill.isLocked()) {
    id = fill.getId();
    if (!id) {
      if (fill instanceof dvt.PatternFill) {
        id = dvt.SvgShapeUtils.getUniqueId('pat');// no id - create unique internal id
      }
      else {
        id = dvt.SvgShapeUtils.getUniqueId('Gr');// no id - create unique internal id
      }
      fill.setId(id);
    }
  }
  else {
    id = fill.getId();
  }
  if (!fill._defPresent) {
    var elem = fill._defElem;
    if (!elem) {
      if (fill instanceof dvt.GradientFill)
        elem = DvtSvgGradientUtils.createElem(fill, id);
      else if (fill instanceof dvt.ImageFill)
        elem = DvtSvgImageFillUtils.createElem(fill, id);
      else if (fill instanceof dvt.PatternFill)
        elem = DvtSvgPatternFillUtils.createElem(fill, id);
    }
    fill._defElem = elem;
    context.appendDefs(elem);
    fill._defPresent = true;
  }
};

/**
 * Adds a gradient stroke to the global defs element.
 * @param {dvt.GradientStroke} stroke The stroke to add to the global defs
 * @param {dvt.Context} context The context to add the gradient defs element to
 */
dvt.SvgShapeUtils.addSpecialStroke = function(stroke, context) {
  var id;
  if (!stroke.isLocked()) {
    id = stroke.getId();
    if (!id) {
      id = dvt.SvgShapeUtils.getUniqueId('Gr');// no id - create unique internal id
      stroke.setId(id);
    }
  }
  else {
    id = stroke.getId();
  }

  if (!stroke._defPresent) {
    var elem = stroke._defElem;
    if (!elem)
      elem = DvtSvgGradientUtils.createElem(stroke, id);// create SVG DOM elem
    stroke._defElem = elem;
    context.appendDefs(elem);
    stroke._defPresent = true;
  }
};

/**
 * Creates an SVG DOM element.
 * @param {String} name
 * @param {String} id  Optional ID to be applied to the created DOM element.
 * @return {Element} the DOM element
 */
dvt.SvgShapeUtils.createElement = function(name, id)
{
  var elem = document.createElementNS(dvt.ToolkitUtils.SVG_NS, name);

  if (id) {
    dvt.ToolkitUtils.setAttrNullNS(elem, 'id', id);
  }

  return elem;
};


/**
 * Creates a unique ID string
 * @param {String} sPrefix  Optional string used as a prefix for the generated ID. If
 *                          omitted, the ID generated will be prefixed with '$'.
 * @return {String}        A unique ID string
 */
dvt.SvgShapeUtils.getUniqueId = function(sPrefix)
{
  return (sPrefix ? sPrefix : '$') + dvt.SvgShapeUtils._uniqueSeed++;
};


/**
 * Converts an array of x,y coordinate pairs into an SVG style string.
 * @param {array} arPoints the array of points
 * @return {Array}  the string usable by SVG polygons and polylines
 */
dvt.SvgShapeUtils.convertPointsArray = function(arPoints) {
  var len = arPoints.length;   // convert to svg space separated list
  var s = '';

  for (var i = 0; i < len; i++) {
    if (i > 0) {
      s += ' ';
    }
    s += dvt.ToolkitUtils.roundDecimal(arPoints[i]);
  }
  return s;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 *  Abstract base class for displayable objects.
 *  @extends {dvt.Obj}
 *  @class
 *  @constructor
 */
dvt.Displayable = function() {
  // This class should never be instantiated directly
};

dvt.Obj.createSubclass(dvt.Displayable, dvt.Obj);


/**
 * Array of SVG attributes that should be transferred to the outer element.
 * @private
 */
dvt.Displayable._ATTRS_TRANSFERABLE_TO_OUTER = [/*'filter',*/'clip-path'];


/**
 * A mapping between event types and the string needed to create a new event for dispatch
 * @private
 */
dvt.Displayable._CREATE_EVENT_TYPE_MAP = {
  'click': dvt.MouseEvent.CLICK,
  'mouseover': dvt.MouseEvent.MOUSEOVER,
  'mouseout': dvt.MouseEvent.MOUSEOUT,
  'mousemove': dvt.MouseEvent.MOUSEMOVE,
  'keydown': dvt.KeyboardEvent.KEYDOWN,
  'keyup': dvt.KeyboardEvent.KEYUP,
  'keypress': dvt.KeyboardEvent.KEYPRESS
};

/**
 * A boolean to toggle whether displayable IDs are sent to the DOM or not.  false for performance reasons but can be
 * changed to true for debugging purposes.
 */
dvt.Displayable.SET_ID_ON_DOM = false;

/**
 * @param {dvt.Context} context
 * @param {string} type The type of SVG element to be created.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.Displayable.prototype.Init = function(context, type, id) {
  this._context = context;
  this._elem = dvt.SvgShapeUtils.createElement(type);
  this._elem._obj = this;//  pointer back to this object
  this.setId(id);
  // TODO  Removal of null initialization routines
  this._bVisible = true;
  this._pixelHinting = false;
  this._cursor = null;
  this._bMouseEnabled = true;
  this._alpha = 1;
  this._matrix = null;

  this._ariaProperties = {
  };

  /**
   * Property map used to cache SVG property values to avoid DOM access.
   * @private
   */
  this._properties = {};
};


/**
 * Returns the application context.
 * @return {dvt.Context}
 */
dvt.Displayable.prototype.getCtx = function() {
  return this._context;
};


/**
 * Internal DVT toolkit framework use only.
 * @protected
 * @return {dvt.Displayable}
 */
dvt.Displayable.prototype.getImpl = function() {
  // TODO  Deprecated.  Will start removing usages outside of the shapes layer once the new toolkit is merged.
  return this;
};


/**
 *  @return {dvt.Displayable}  the controlling (js) object.
 */
dvt.Displayable.prototype.getObj = function()// TODO  REMOVE
{
  // TODO  Deprecated.  Will start removing usages outside of the shapes layer once the new toolkit is merged.
  return this;
};


/**
 *  Returns the SVG DOM element representing this displayable object.
 *  @return {DOM_element}  An SVG DOM element representing this displayable object.
 */
dvt.Displayable.prototype.getElem = function() {
  return this._elem;
};


/**
 * Returns the outermost SVG DOM element of this displayable.  This should be used when
 * removing this displayable from the DOM.
 * @return {dvt.Displayable}
 */
dvt.Displayable.prototype.getOuterElem = function() {
  return this._outerElem ? this._outerElem : this.getElem();
};


/**
 * Returns the id of this displayable.
 * @return {string}
 */
dvt.Displayable.prototype.getId = function() {
  return this._id;
};

/**
 * Specifies the id of this displayable.
 * @param {string} id The id to set
 * @param {boolean} bForce True if we should always set id on DOM. Used for VoiceOver .
 */
dvt.Displayable.prototype.setId = function(id, bForce) {
  if (this._id !== id) {
    if (id && id.length === 0) {
      id = null;
    }
    this._id = id;
    if (dvt.Displayable.SET_ID_ON_DOM || bForce) {
      if (id)
        dvt.ToolkitUtils.setAttrNullNS(this.getOuterElem(), 'id', id);
      else
        dvt.ToolkitUtils.removeAttrNullNS(this.getOuterElem(), 'id');
    }
  }
};


/**
 * Returns the parent of this object.
 * @return {dvt.Displayable}
 */
dvt.Displayable.prototype.getParent = function() {
  return this._parent;
};


/**
 * Sets the parent of this object.
 * @param {dvt.Displayable} parent
 */
dvt.Displayable.prototype.setParent = function(parent) {
  this._parent = parent;
};

/**
 * Returns true if this object is a descendant of the specified object.
 * @param {dvt.Obj} obj
 * @return {boolean}
 */
dvt.Displayable.prototype.isDescendantOf = function(obj) {
  if (!obj || !this.getParent())
    return false;
  else if (this.getParent() == obj)
    return true;
  else
    return this.getParent().isDescendantOf(obj);
};

/**
 * Returns true if pixel hinting is enabled.
 * @return {boolean}
 */
dvt.Displayable.prototype.getPixelHinting = function() {
  return this._pixelHinting;
};


/**
 * Specifies whether pixel hinting is enabled.
 * @param {boolean} bHint
 */
dvt.Displayable.prototype.setPixelHinting = function(bHint) {
  this._pixelHinting = bHint;
  if (bHint)
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'shape-rendering', 'crispEdges');
  else
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'shape-rendering');
};


/**
 *  Gets the visibility of this object.
 *  @return {boolean}  True if the object is visible, else false.
 */
dvt.Displayable.prototype.getVisible = function() {
  return this._bVisible;
};


/**
 *  Enables/disables the visibility of this object.
 *  @param {boolean}  bVis  True if the object is to be visible, else false if
 *  it is to be hidden.
 */
dvt.Displayable.prototype.setVisible = function(bVis) {
  if (this._bVisible !== bVis) {
    this._bVisible = bVis;
    var elem = (this instanceof dvt.Marker) ? this._elem : this.getElem();

    // - HTML5: VISIBILITY="VISIBLE" LEFT ON ELEMENT AFTER ANIMATION
    //Since the default value for visibility is true, just remove the 'visibility' attribute.
    //This change is needed to avoid the attribute visibility="visible" left on
    //this element after animation.
    //Note: in SVG, the visibility attribute doesn't behave like Flash,
    //Ex: if a child has visibility="visible" and its container has visibility=hidden
    //the child is still visible
    if (bVis) {
      dvt.ToolkitUtils.removeAttrNullNS(elem, 'visibility');
    }
    else {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'visibility', 'hidden');
    }
  }
};


/**
 *  Sets a clipping region for this object.
 *  @param {dvt.ClipPath}  cp  the dvt.ClipPath object specifying the clipping region.
 */
dvt.Displayable.prototype.setClipPath = function(cp) {
  // Update clip path reference count on the context
  if (cp) {
    if (this.ClipPathId == cp.getId()) {
      return;
    } else {
      if (this.ClipPathId)
        this._context.decreaseGlobalDefReference(this.ClipPathId);
      this.ClipPathId = cp.getId();
      this._context.increaseGlobalDefReference(this.ClipPathId);

      // Create an outer group if there is a matrix defined, since SVG applies transforms before clip paths.
      if (!this._outerElem && this._matrix)
        this._createOuterGroupElem();

      var id = cp.getId();
      if (id) {
        // essential to have an id to reference
        var context = this.getCtx();

        if (dvt.SvgShapeUtils.addClipPath(cp, context)) {
          // add to global defs
          // Set the clip path on the outer element of the shape
          dvt.ToolkitUtils.setAttrNullNS(this.getOuterElem(), 'clip-path', dvt.ToolkitUtils.getUrlById(id));
        }
      }
    }
  }
  else if (!cp && this.ClipPathId) {
    this._context.decreaseGlobalDefReference(this.ClipPathId);
    this.ClipPathId = null;
    dvt.ToolkitUtils.removeAttrNullNS(this.getOuterElem(), 'clip-path');
    return;
  }
};

/**
 * Adds a mask to the global defs element.
 * @param {dvt.Mask} mask
 */
dvt.Displayable.prototype.setMask = function(mask) {
  // Update clip path reference count on the context
  if (mask) {
    if (this.MaskId == mask.getId()) {
      return;
    } else {
      if (this.MaskId)
        this._context.decreaseGlobalDefReference(this.MaskId);
      this.MaskId = mask.getId();
      this._context.increaseGlobalDefReference(this.MaskId);

      // Create an outer group if there is a matrix defined, since SVG applies transforms before clip paths.
      if (!this._outerElem && this._matrix)
        this._createOuterGroupElem();

      var id = mask.getId();
      if (id) {
        // essential to have an id to reference
        var context = this.getCtx();

        if (dvt.SvgShapeUtils.addMask(mask, context)) {
          // add to global defs
          // Set the clip path on the outer element of the shape
          dvt.ToolkitUtils.setAttrNullNS(this.getOuterElem(), 'mask', dvt.ToolkitUtils.getUrlById(id));
        }
      }
    }
  }
  else if (!mask && this.MaskId) {
    this._context.decreaseGlobalDefReference(this.MaskId);
    this.MaskId = null;
    dvt.ToolkitUtils.removeAttrNullNS(this.getOuterElem(), 'mask');
    return;
  }
};

/**
 * Converts the dvt.Rectangle in the local coordinate system to the target displayable's coordinate system.
 * @param {dvt.Rectangle} rect
 * @param {dvt.Displayable} targetCoordinateSpace
 * @return {dvt.Rectangle}
 */
dvt.Displayable.prototype.ConvertCoordSpaceRect = function(rect, targetCoordinateSpace) {
  if (!targetCoordinateSpace || targetCoordinateSpace === this)
    return rect;

  // First calculate relative to the stage
  var stageP1 = this.localToStage(new dvt.Point(rect.x, rect.y));
  var stageP2 = this.localToStage(new dvt.Point(rect.x + rect.w, rect.y + rect.h));

  // Then convert relative to target
  var targetP1 = targetCoordinateSpace.stageToLocal(stageP1);
  var targetP2 = targetCoordinateSpace.stageToLocal(stageP2);

  return new dvt.Rectangle(targetP1.x, targetP1.y, targetP2.x - targetP1.x, targetP2.y - targetP1.y);
};


/**
 * Returns the dimensions of the displayable by calling getBBox.
 * @return {dvt.Rectangle}
 */
dvt.Displayable.prototype.GetSvgDimensions = function() {
  try {
    var bbox = this.getElem().getBBox();
  }
  catch (e) {
    if (dvt.Agent.isEnvironmentTest())
      print('Error in dvt.Displayable.prototype.GetSvgDimensions: ' + e);

    return null;
  }
  //don't return bbox directly because we don't want calling code
  //to depend on platform-specific API, so instead turn it into
  //a dvt.Rectangle
  return new dvt.Rectangle(bbox.x, bbox.y, bbox.width, bbox.height);
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.Displayable.prototype.getDimensions = function(targetCoordinateSpace) {
  var bounds = this.GetSvgDimensions();
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};


//:
/**
 * Returns the bounds of the displayable relative to the target coordinate space, including stroke width.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.Displayable.prototype.getDimensionsWithStroke = function(targetCoordinateSpace) {
  var bounds = this.GetDimensionsWithStroke();
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};

//:
/**
 * Returns the dimensions of the displayable relative to the target space.
 * @param {dvt.Rectangle} targetCoordinateSpace
 * @return {dvt.Rectangle}
 * @protected
 */
dvt.Displayable.prototype.GetDimensionsWithStroke = function(targetCoordinateSpace) {
  //get dims for the shape elem, and change coord space if necessary
  var dims = this.GetElemDimensionsWithStroke();
  if (!targetCoordinateSpace || targetCoordinateSpace === this)
    return dims;
  else {
    // Calculate the bounds relative to the target space
    return this.ConvertCoordSpaceRect(dims, targetCoordinateSpace);
  }
};

//:
/**
 * Returns the dimensions of the displayable by calling getBBox.
 * @return {dvt.Rectangle}
 * @protected
 */
dvt.Displayable.prototype.GetElemDimensionsWithStroke = function() {
  //the method is overridden in dvt.Shape to account for the stroke
  return this.GetSvgDimensions();
};


/**
 * Returns true if any of the specified attribute names are present on the element.
 * @param {object} elem  The SVG DOM element.
 * @param {array} attrNames The array of attribute names to look for.
 * @protected
 * @return {boolean}
 */
dvt.Displayable.HasAttributes = function(elem, attrNames) {
  if (attrNames) {
    var numAttrs = attrNames.length;
    for (var i = 0; i < numAttrs; i++) {
      if (dvt.ToolkitUtils.getAttrNullNS(elem, attrNames[i]))// TODO  This should be hasAttrNullNS
        return true;
    }
  }
  return false;
};


/**
 * Transfer relevant attributes from the original SVG DOM element to the new SVG DOM element.
 * @param {object} fromElem  The SVG DOM element.
 * @param {object} toElem  The new SVG DOM element.
 * @param {array} attrNames The array of attribute names to transfer.
 * @protected
 */
dvt.Displayable.TransferAttributes = function(fromElem, toElem, attrNames) {
  if (attrNames) {
    var attrName;
    var attrValue;
    var numAttrs = attrNames.length;
    for (var i = 0; i < numAttrs; i++) {
      attrName = attrNames[i];
      attrValue = dvt.ToolkitUtils.getAttrNullNS(fromElem, attrName);
      if (attrValue) {
        dvt.ToolkitUtils.removeAttrNullNS(fromElem, attrName);
        dvt.ToolkitUtils.setAttrNullNS(toElem, attrName, attrValue);
        if (dvt.Agent.isPlatformIE()) {
          // , prev removeAttributeNS()
          dvt.ToolkitUtils.setAttrNullNS(fromElem, attrName, null);// fails for IE9 (9.0.8112.16421)
        }
      }
    }
  }
};


/**
 * Creates an outer group element to workaround issues with filters and clip paths.
 * @private
 */
dvt.Displayable.prototype._createOuterGroupElem = function() {
  if (this._outerElem)
    return;

  var outerId = this._id ? this._id + '_outer' : null;
  this._outerElem = dvt.SvgShapeUtils.createElement('g', outerId);

  // Reparent the DOM elements
  var parent = this.getParent();
  if (parent) {
    var parentElem = parent.getElem();
    parentElem.replaceChild(this._outerElem, this.getElem());
  }
  dvt.ToolkitUtils.appendChildElem(this._outerElem, this.getElem());

  // Transfer attributes from the old outermost SVG element to the new outer element
  dvt.Displayable.TransferAttributes(this.getElem(), this._outerElem, dvt.Displayable._ATTRS_TRANSFERABLE_TO_OUTER);
};


/**
 * @return {DvtCssStyle} the dvt.CSSStyle of this object.
 */
dvt.Displayable.prototype.getCSSStyle = function() {
  return this._cssStyle;
};


/**
 * Sets the dvt.CSSStyle of this object.
 * @param {DvtCssStyle} style The dvt.CSSStyle of this object.
 */
dvt.Displayable.prototype.setCSSStyle = function(style) {
  this._cssStyle = style;// TODO  Should we have this on non-text-objects?
};


/**
 * Sets the cursor on this object.
 * @param {string} cursorType
 */
dvt.Displayable.prototype.setCursor = function(cursorType) {
  this._cursor = cursorType;

  // Batik has trouble with certain cursor syntax.
  if (dvt.Agent.isEnvironmentBatik())
    return;

  // Update the DOM
  if (cursorType)
    dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'cursor', cursorType);
  else
    dvt.ToolkitUtils.removeAttrNullNS(this.getElem(), 'cursor');
};


/**
 * Gets the cursor used on this object.
 * @return {String}
 */
dvt.Displayable.prototype.getCursor = function() {
  return this._cursor;
};


/**
 * Sets whether mouse events are enabled on this object.
 * @param {boolean} bEnabled whether mouse events are enabled
 */
dvt.Displayable.prototype.setMouseEnabled = function(bEnabled) {
  this._bMouseEnabled = bEnabled;
  var val = bEnabled ? 'visiblePainted' : 'none';
  dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'pointer-events', val);
};


/**
 * Gets whether mouse events are enabled on this object.
 * @return {boolean}
 */
dvt.Displayable.prototype.isMouseEnabled = function() {
  return this._bMouseEnabled;
};


/**
 *  Returns the alpha channel value.
 *  @return {number} A value between 0 (invisible) and 1 (opaque).
 */
dvt.Displayable.prototype.getAlpha = function() {
  return this._alpha;
};


/**
 *  Sets the alpha.
 *  @param {number} alpha  A value between 0 (invisible) and 1 (opaque).
 */
dvt.Displayable.prototype.setAlpha = function(alpha) {
  //when animating alpha, small values are turned into strings like
  //"3.145e-8", which SVG incorrectly clamps to 1, so just cut off
  //small values here and make them 0
  if (alpha < 0.00001)
    alpha = 0;

  if (alpha !== this._alpha) {
    this._alpha = alpha;
    dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'opacity', this._alpha, 1);
  }
};


/**
 * Applies deferred aria role and properties to the DOM.
 */
dvt.Displayable.prototype.applyAriaProperties = function() {
  if (dvt.Agent.deferAriaCreation()) {
    // Apply Aria Role
    if (this._ariaRole)
      this._setAriaRole(this._ariaRole);

    // Apply Aria Properties
    for (var property in this._ariaProperties) {
      this._setAriaProperty(property, this._ariaProperties[property]);
    }
  }
};


/**
 * Sets the WAI-ARIA role.
 * @param {String} role The role attribute value.
 */
dvt.Displayable.prototype.setAriaRole = function(role) {
  if (!dvt.Agent.deferAriaCreation())
    this._setAriaRole(role);

  this._ariaRole = role;
};


/**
 * Sets the WAI-ARIA role.
 * @param {String} role The role attribute value.
 * @private
 */
dvt.Displayable.prototype._setAriaRole = function(role) {
  var elem = this.GetAriaElem();
  if (role)
    dvt.ToolkitUtils.setAttrNullNS(elem, 'role', role);
  else
    dvt.ToolkitUtils.removeAttrNullNS(elem, 'role');
};


/**
 * Gets the WAI-ARIA role.
 * @return {String} The role attribute value.
 */
dvt.Displayable.prototype.getAriaRole = function() {
  return this._ariaRole;
};

/**
 * Returns the DOM element to add WAI-ARIA attributes to. Allows subclasses to return the outer group element if
 * needed (see ).
 * @return {SVGElement} The SVG DOM element to add wai-aria attributes to
 * @protected
 */
dvt.Displayable.prototype.GetAriaElem = function() {
  return this.getElem();
};

/**
 * Sets the WAI-ARIA property/state.
 * @param {string} property The property/state attribute name. The prefix "aria-" should be skipped.
 * @param {string|number} value The property/state attribute value.
 */
dvt.Displayable.prototype.setAriaProperty = function(property, value) {
  if (!property)
    return;

  if (!dvt.Agent.deferAriaCreation())
    this._setAriaProperty(property, value);

  this._ariaProperties[property] = value;
};


/**
 * Sets the WAI-ARIA property/state.
 * @param {string} property The property/state attribute name. The prefix "aria-" should be skipped.
 * @param {string|number} value The property/state attribute value.
 * @private
 */
dvt.Displayable.prototype._setAriaProperty = function(property, value) {
  var elem = this.GetAriaElem();
  if (value != null && value !== '') {
    // Make replacements on the text string as needed
    if (property == 'label')
      value = dvt.StringUtils.processAriaLabel(value);

    dvt.ToolkitUtils.setAttrNullNS(elem, 'aria-' + property, value);
  }
  else
    dvt.ToolkitUtils.removeAttrNullNS(elem, 'aria-' + property);
};


/**
 * Gets the WAI-ARIA property/state.
 * @param {String} property The property/state attribute name. The prefix "aria-" should be skipped.
 * @return {String} The property/state attribute value.
 */
dvt.Displayable.prototype.getAriaProperty = function(property) {
  if (property) {
    return this._ariaProperties[property];
  } else {
    return null;
  }
};

/**
 * Convert a point from stage coords to local coords.
 * @param {dvt.Point}  point  point in stage coords
 * @return {dvt.Point}
 */
dvt.Displayable.prototype.stageToLocal = function(point) {
  var pathToStage = this.getPathToStage();
  var mat;
  var retPoint = point;
  for (var i = pathToStage.length - 1; i >= 0; i--) {
    mat = pathToStage[i].getMatrix().clone();
    mat.invert();
    retPoint = mat.transformPoint(retPoint);
  }
  return retPoint;
};


/**
 * Convert a point from local coords to stage coords.
 * @param {dvt.Point}  point  point in local coords
 * @return {dvt.Point}
 */
dvt.Displayable.prototype.localToStage = function(point) {
  var pathToStage = this.getPathToStage();
  var mat;
  var retPoint = point;
  for (var i = 0; i < pathToStage.length; i++) {
    mat = pathToStage[i].getMatrix();
    retPoint = mat.transformPoint(retPoint);
  }
  return retPoint;
};


/**
 * Get an array of objects in the tree from this displayable to the stage.
 * The returned array is ordered with this displayable first and the stage
 * last, like [this, this.getParent(), ... , stage].
 * @return {array}
 */
dvt.Displayable.prototype.getPathToStage = function()
{
  var displayable = this;
  var array = [];
  while (displayable)
  {
    array.push(displayable);
    displayable = displayable.getParent();
  }
  return array;
};


/**
 *    Destroy the displayable.  It should no longer be used or displayed
 */
dvt.Displayable.prototype.destroy = function()
{
  //: Remove all draw effects at once, because removing
  //them one by one results in the remaining ones being reapplied at each
  //iteration.  Since this object is being destroyed, it is most likely
  //disconnected from the display list.  When the draw effects are applied,
  //they may call getBBox() on the element, which can result in errors in
  //Firefox when the object is disconnected, and the view not being rendered.
  this.removeAllDrawEffects();
  if (this.ClipPathId)
    this.setClipPath(null);
};


/**
 * Creates a copy of this displayable wrapped by a new container
 * @return {dvt.Container} a copy of this displayable
 */
dvt.Displayable.prototype.createCopy = function() {
  var container = new dvt.Container(this.getCtx(), 'clonedContainer');
  var clonedSvg = this.getElem().cloneNode(true);
  dvt.ToolkitUtils.appendChildElem(container.getElem(), clonedSvg);
  this._disableEvents(clonedSvg);
  return container;
};

/**
 * Disables mouse events on the specified svg element and its children.
 * @param {object} svgElem
 * @private
 */
dvt.Displayable.prototype._disableEvents = function(svgElem) {
  var child = svgElem.firstChild;
  //loop over all children
  while (child != null) {
    if (child.setAttributeNS) {
      dvt.ToolkitUtils.setAttrNullNS(child, 'pointer-events', 'none');
      dvt.ToolkitUtils.setAttrNullNS(child, 'id', null);
    }
    this._disableEvents(child);
    child = child.nextSibling;
  }
};

/**
 * Dispatches the native event to the internal dom element
 * Note: Use with caution
 * @param {Object} event
 * @override
 */
dvt.Displayable.prototype.dispatchNativeEvent = function(event) {
};


/**
 * Helper function to access the value of a property that was set using SetProperty.
 * @param {string} name the name of the attribute.
 * @return {object}
 * @protected
 */
dvt.Displayable.prototype.GetProperty = function(name) {
  return this._properties[name];
};


/**
 * Helper function to store the value of a property. Protects against attribute name collision with subclasses by
 * storing the value on a child object.
 * @param {string} name The name of the attribute.
 * @param {string} value The value of the attribute.
 * @return {dvt.Displayable} Returns this instance to support chaining.
 * @protected
 */
dvt.Displayable.prototype.SetProperty = function(name, value) {
  if (value !== this._properties[name]) {
    this._properties[name] = value;
  }
  return this;
};


/**
 * Helper function to set the specified SVG attribute on the DOM element.  Optimizes getters by storing a copy of the
 * value using SetAttr so that DOM access isn't required. If the property value has been updated in the DOM, then
 * SvgPropertyChanged will be called to allow for additional processing if needed.
 * @param {string} name The name of the attribute.
 * @param {string} value The value of the attribute.
 * @param {string=} defaultValue The default value of the attribute, which can be provided to optimize performance.
 * @return {dvt.Displayable} Returns this instance to support chaining.
 * @protected
 */
dvt.Displayable.prototype.SetSvgProperty = function(name, value, defaultValue) {
  if (value !== this._properties[name]) {
    this._properties[name] = value;
    dvt.ToolkitUtils.setAttrNullNS(this._elem, name, value, defaultValue);
    this.SvgPropertyChanged(name);
  }
  return this;
};


/**
 * Callback that is notified whenever an SVG DOM property is changed by SetSvgProperty. Subclasses can override to
 * perform additional processing, such as updating the selection feedback, when properties are changed.
 * @param {string} name The name of the attribute.
 * @protected
 */
dvt.Displayable.prototype.SvgPropertyChanged = function(name) {
  // subclasses can override
};

/**
  * Prepares an aria-label for a data object.
  * The aria-label is composed of an application provided description and the data object's current states.
  * @param {String} shortDesc  The short description for a data object
  * @param {Array} states An array of states to populate in the aria label
  * @return {String}
  */
dvt.Displayable.generateAriaLabel = function(shortDesc, states) {
  var label = '';
  var hasStates = states && states.length > 0;
  if (shortDesc) {
    var descDelim = dvt.Bundle.getTranslatedString(dvt.Bundle.UTIL_PREFIX, 'ARIA_LABEL_DESC_DELIMITER');
    label = shortDesc;
    if (hasStates)
      label += descDelim;
  }

  if (hasStates) {
    var statesDelim = dvt.Bundle.getTranslatedString(dvt.Bundle.UTIL_PREFIX, 'ARIA_LABEL_STATE_DELIMITER');
    for (var i = 0; i < states.length; i++) {
      label = label + states[i];
      if (i != (states.length - 1))
        label += statesDelim;
    }
  }

  return label;
};
// File containing all draw effect (filter) related functions defined on dvt.Displayable.

dvt.Displayable.prototype.getNumDrawEffects = function()
{
  if (!this._drawEffects)
  {
    return 0;
  }

  return this._drawEffects.length;
};

dvt.Displayable.prototype.addDrawEffect = function(effect) 
{
  if (!this._drawEffects)
  {
    this._drawEffects = [];
  }

  //lock the effect
  effect.__lock();

  this._drawEffects.push(effect);

  this._applyDrawEffects(this._drawEffects);
};

dvt.Displayable.prototype.addDrawEffectAt = function(effect, index) 
{
  if (!this._drawEffects)
  {
    this._drawEffects = [];
  }

  //lock the effect
  effect.__lock();

  if (index >= this._drawEffects.length)
  {
    this._drawEffects.push(effect);
  }
  else
  {
    this._drawEffects.splice(index, 0, effect);
  }

  this._applyDrawEffects(this._drawEffects);
};

dvt.Displayable.prototype.removeDrawEffect = function(effect)
{
  var index = this.getDrawEffectIndex(effect);
  if (index > - 1)
  {
    this._drawEffects.splice(index, 1);
    this._applyDrawEffects(this._drawEffects);
  }
};

dvt.Displayable.prototype.removeDrawEffectAt = function(index)
{
  if (this._drawEffects)
  {
    var numEffects = this._drawEffects.length;
    if (index >= 0 && index < numEffects)
    {
      this._drawEffects.splice(index, 1);
      this._applyDrawEffects(this._drawEffects);
    }
  }
};

dvt.Displayable.prototype.removeAllDrawEffects = function() 
{
  if (this._drawEffects)
  {
    this._drawEffects = null;
    this._applyDrawEffects(this._drawEffects);
  }
};

dvt.Displayable.prototype.getDrawEffectIndex = function(effect)
{
  if (this._drawEffects)
  {
    var numEffects = this._drawEffects.length;
    for (var i = 0; i < numEffects; i++)
    {
      if (effect === this._drawEffects[i])
      {
        return i;
      }
    }
  }
  return - 1;
};

dvt.Displayable.prototype._applyDrawEffects = function() {
  var effects = this._drawEffects;

  // remove current filter
  // should be done before creating a new outerElem because the current filter lives in the current outerElem
  if (this._filter) {
    dvt.ToolkitUtils.removeAttrNullNS(this.getOuterElem(), 'filter');
    this.getCtx().removeDefs(this._filter);
    this._filter = null;
  }

  // Create an outer group if there is a matrix defined, since SVG applies transforms before filters.
  if (!this._outerElem && this._matrix)
    this._createOuterGroupElem();

  //add new filter if necessary
  if (effects && effects.length > 0) {
    //: Repaint bug in Firefox requires us to force a repaint after removing filter
    //At worst we will create n empty filters where n=# markers
    this._filter = DvtSvgFilterUtils.createFilter(effects, this);
    if (this._filter) {
      this.getCtx().appendDefs(this._filter);
      var filterId = dvt.ToolkitUtils.getAttrNullNS(this._filter, 'id');
      dvt.ToolkitUtils.setAttrNullNS(this.getOuterElem(), 'filter', dvt.ToolkitUtils.getUrlById(filterId));
    }
  }
};
// File containing all event listener related functions defined on dvt.Displayable.


/**
 * Adds an event listener.
 * @param {string} type the event type
 * @param {function} listener the function to call
 * @param {string} useCapture whether the listener operates in the capture phase
 * @param {object} obj instance of the object the listener is defined on
 */
dvt.Displayable.prototype.addEvtListener = function(type, listener, useCapture, obj) {
  // Store a reference to the listener
  var listenersArray = this._getListeners(type, useCapture, true);
  listenersArray.push(listener);
  listenersArray.push(obj);

  // Call the impl so that it can add the actual listener
  this._addListener(type, useCapture);
};


/**
 * Removes an event listener.
 * @param {string} type the event type
 * @param {function} listener the function to call
 * @param {string} useCapture whether the listener operates in the capture phase
 * @param {object} obj instance of the object the listener is defined on
 */
dvt.Displayable.prototype.removeEvtListener = function(type, listener, useCapture, obj) {
  // Remove the listener
  var listenersArray = this._getListeners(type, useCapture, false);
  if (listenersArray) {
    for (var i = 0; i < listenersArray.length; i += 2) {
      if (listenersArray[i] === listener && listenersArray[i + 1] === obj) {
        listenersArray.splice(i, 2);
        break;
      }
    }
  }

  // Call the impl so that it can remove the actual listener.
  // Note that the array itself is intentionally not removed.
  if (listenersArray && listenersArray.length <= 0)
    this._removeListener(type, useCapture);
};


/**
 * Dispatch event
 * @param {String} eventType event type
 * @param {String|dvt.KeyboardEvent} params additional parameters for the generated event that can be passes as a string or event object
 */
dvt.Displayable.prototype.dispatchDisplayableEvent = function(eventType, params) {
  var createEventType = dvt.Displayable._CREATE_EVENT_TYPE_MAP[eventType];
  var context;
  if (dvt.MouseEvent.CLICK == createEventType || dvt.MouseEvent.MOUSEOVER == createEventType || dvt.MouseEvent.MOUSEOUT == createEventType || dvt.MouseEvent.MOUSEMOVE == createEventType) {
    if (document.createEvent) {
      context = this.getCtx();
      var dim = this.getDimensions();
      var elementPosition = this.localToStage(new dvt.Point(dim.x, dim.y));
      var absoluteStagePos = context.getStageAbsolutePosition();
      var absoluteElementPosition = new dvt.Point(absoluteStagePos.x + elementPosition.x, absoluteStagePos.y + elementPosition.y);
      var event = document.createEvent('MouseEvents');
      event.initMouseEvent(createEventType, true, true, window, 1, absoluteElementPosition.x, absoluteElementPosition.y, absoluteElementPosition.x, absoluteElementPosition.y, false, false, false, false, 0, null);
      this.getElem().dispatchEvent(event);
    }
  }
  else if (dvt.KeyboardEvent.KEYDOWN == createEventType || dvt.KeyboardEvent.KEYUP == createEventType || dvt.KeyboardEvent.KEYPRESS == createEventType) {
    if (document.createEvent) {
      var keyboardEvent = document.createEvent('KeyboardEvent');
      var keycode;

      if (params instanceof dvt.KeyboardEvent) {
        keycode = params.keyCode;
        this._ctrlKeyPressed = params.ctrlKey;
        this._shiftKeyPressed = params.shiftKey;
      }
      else {
        keycode = parseInt(params);

        if (this._ctrlKeyPressed === undefined)
          this._ctrlKeyPressed = false;

        if (this._shiftKeyPressed === undefined)
          this._shiftKeyPressed = false;

        if (keycode == dvt.KeyboardEvent.CONTROL) {
          if (this._ctrlKeyPressed && createEventType == dvt.KeyboardEvent.KEYUP)
            this._ctrlKeyPressed = false;
          else if (!this._ctrlKeyPressed && createEventType == dvt.KeyboardEvent.KEYDOWN)
            this._ctrlKeyPressed = true;
        }
        else if (keycode == dvt.KeyboardEvent.SHIFT) {
          if (this._shiftKeyPressed && createEventType == dvt.KeyboardEvent.KEYUP)
            this._shiftKeyPressed = false;
          else if (!this._shiftKeyPressed && createEventType == dvt.KeyboardEvent.KEYDOWN)
            this._shiftKeyPressed = true;
        }
      }
      if (typeof (keyboardEvent.initKeyboardEvent) != 'undefined') {
        keyboardEvent.initKeyboardEvent(createEventType, true, true, window, this._ctrlKeyPressed, false, this._shiftKeyPressed, false, keycode, keycode);
      }
      else {
        keyboardEvent.initKeyEvent(createEventType, true, true, window, this._ctrlKeyPressed, false, false, this._shiftKeyPressed, keycode, keycode);
      }

      /*
        ideally, we would just create the native keyboard event and disptach it to the wrapping div, but we
        can't for two reasons
        1. when the keyboardEvent is initialized above, the initKeyboardEvent method used by Webkit doesn't initialize
           the event with the right keycode; it is always 0.  This is a known bug tracked in Chromium and at Webkit
           see http://code.google.com/p/chromium/issues/detail?id=27048 (Chromium) and
           https://bugs.webkit.org/show_bug.cgi?id=16735 (Webkit)
        2. since the native event doesn't work, I tried dispatching a dvt.KeyboardEvent to the wrapping div.
           however, this generates a DOM EventException of type UNSPECIFIED_EVENT_TYPE_ERR, even though the
           type of the dvt.KeyboardEvent was specified.

        So, instead, we will directly call the bubble listener that we attach to the wrapping div
        */

      var svgKeyboardEvent = dvt.DomEventFactory.newEvent(keyboardEvent);
      svgKeyboardEvent.keyCode = keycode;
      svgKeyboardEvent.ctrlKey = this._ctrlKeyPressed;
      svgKeyboardEvent.shiftKey = this._shiftKeyPressed;

      context = this.getCtx();
      var stage = context.getStage();
      var wrappingDiv = stage.getSVGRoot().parentNode;
      dvt.HtmlKeyboardListenerUtils._bubbleListener.call(wrappingDiv, svgKeyboardEvent);
    }
  }
};


/**
 * Adds listener to the DOM element.
 * @param {string} type
 * @param {function} listener
 * @param {boolean} useCapture
 * @protected
 */
dvt.Displayable.prototype.AddElemListener = function(type, listener, useCapture) {
  dvt.ToolkitUtils.addDomEventListener(this.getElem(), type, listener, useCapture);
  if (type == dvt.TouchEvent.TOUCHEND) {
    dvt.ToolkitUtils.addDomEventListener(this.getElem(), dvt.TouchEvent.TOUCHCANCEL, listener, useCapture);
  }
};


/**
 * Notifies all applicable event listeners of the given event.
 * @param {dvt.MouseEvent} event
 * @param {boolean} useCapture whether the listener operates in capture phase
 * @protected
 */
dvt.Displayable.prototype.FireListener = function(event, useCapture) {
  // workaround for 
  var type = event.getType ? event.getType() : event.type;
  var listenersArray = this._getListeners(type, useCapture, false);
  if (listenersArray) {
    for (var i = 0; i < listenersArray.length; i += 2) {
      var obj = listenersArray[i + 1];
      if (listenersArray[i]) {
        listenersArray[i].call(obj, event);
      }
    }
  }
};

/**
 * Notifies all applicable event listeners of the given keyboard event.
 * @param {dvt.KeyboardEvent} event
 * @param {boolean} useCapture whether the listener operates in capture phase
 */
dvt.Displayable.prototype.fireKeyboardListener = function(event, useCapture) {
  this.FireListener(event, useCapture);
};

/**
 * Returns the listeners of the given event type and capture mode.
 * @param {string} type the event type
 * @param {string} useCapture whether the listener operates in the capture phase
 * @param {boolean} createNew whether the array should be created if it doesn't exist
 * @return {array} the mutable Array of listeners
 * @private
 */
dvt.Displayable.prototype._getListeners = function(type, useCapture, createNew) {
  // First find the object where the listener arrays are stored
  if (!this._listenerObj) {
    if (createNew) {
      this._listenerObj = {
      };
    }
    else {
      return null;
    }
  }

  // Then find the array for this event type, creating if necessary
  var eventKey = type + '_' + (useCapture ? true : false);// for example: "click_true"
  var listenersArray = this._listenerObj[eventKey];
  if (!listenersArray && createNew) {
    listenersArray = [];
    this._listenerObj[eventKey] = listenersArray;
  }

  return listenersArray;
};


/**
 * Adds an event listener.
 * @param {String} type the event type
 * @param {String} useCapture whether the listener operates in the capture phase
 * @private
 */
dvt.Displayable.prototype._addListener = function(type, useCapture) {
  var listener = this._getListener(useCapture);
  // on keyboard events, add the listener to the component's wrapping div, since SVG
  // DOM elements don't support keystrokes.
  if (type == dvt.KeyboardEvent.KEYUP || type == dvt.KeyboardEvent.KEYDOWN || type == dvt.KeyboardEvent.KEYPRESS ||
      type == DvtFocusEvent.FOCUS || type == DvtFocusEvent.FOCUSIN || type == DvtFocusEvent.FOCUSOUT || type == DvtFocusEvent.BLUR) {
    var context = this.getCtx();
    var stage = context.getStage();
    var wrappingDiv = stage.getSVGRoot().parentNode;
    if (!wrappingDiv)
      return;

    // allow support for multiple displayables to receive keyboard events
    // TODO: replace this with a singular compound event manager that
    //       will dispatch keyboard events to individual event managers
    if (!wrappingDiv._obj) {
      wrappingDiv._obj = [];
    }
    if (dvt.ArrayUtils.getIndex(wrappingDiv._obj, this) == - 1) {
      wrappingDiv._obj.push(this);
    }
    listener = dvt.HtmlKeyboardListenerUtils.getListener(useCapture);
    dvt.ToolkitUtils.addDomEventListener(wrappingDiv, type, listener, useCapture);
  }
  else {
    this.AddElemListener(type, listener, useCapture);
  }
};


/**
 * Removes an event listener.
 * @param {string} type the event type
 * @param {boolean} useCapture whether the listener operates in the capture phase
 * @private
 */
dvt.Displayable.prototype._removeListener = function(type, useCapture) {
  var listener = this._getListener(useCapture);

  if (type == dvt.KeyboardEvent.KEYUP || type == dvt.KeyboardEvent.KEYDOWN || type == dvt.KeyboardEvent.KEYPRESS ||
      type == DvtFocusEvent.FOCUS || type == DvtFocusEvent.FOCUSIN || type == DvtFocusEvent.FOCUSOUT || type == DvtFocusEvent.BLUR)
  {
    // Keyboard listeners are attached to the wrapping div and tracked via an array stored using _obj.
    var wrappingDiv = this.getCtx().getStage().getSVGRoot().parentNode;
    dvt.ToolkitUtils.removeDomEventListener(wrappingDiv, type, listener, useCapture);
    var index = dvt.ArrayUtils.getIndex(wrappingDiv._obj, this);
    if (index !== -1)
      wrappingDiv._obj.splice(index, 1);
  }
  else
    dvt.ToolkitUtils.removeDomEventListener(this.getElem(), type, listener, useCapture);
};

/**
 * Returns a function that will handle events with the specified useCapture value.
 * @param {boolean} useCapture
 * @return {function}
 * @private
 */
dvt.Displayable.prototype._getListener = function(useCapture) {
  var thisRef = this;
  if (useCapture) {
    if (!this._captureClosure) {
      this._captureClosure = function(event) {
        thisRef._captureListener(event);
      };
    }
    return this._captureClosure;
  }
  else {
    if (!this._bubbleClosure) {
      this._bubbleClosure = function(event) {
        thisRef._bubbleListener(event);
      };
    }
    return this._bubbleClosure;
  }
};


/**
 * The event listener that is called by the implementation object's bubble phase listeners.
 * This function will wrap the event and delegate to the real event listeners.
 * @param {object} event the DOM event object
 * @this {object} the platform object actively processing the event object with an event listener
 * @private
 */
dvt.Displayable.prototype._bubbleListener = function(event) {
  if (dvt.Agent.isPlatformIE()) {
    // Moving an object in the dom for IE causes mouse over events to fire if the moved item is under the mouse
    // Ensure mouse over is not repeatedly called in such a case
    if (event.type == dvt.MouseEvent.MOUSEOVER) {
      if (this._bubbleHoverItem) {
        if (this._bubbleHoverItem == event.target) {
          // Prevent infinite loop
          return;
        }
        else {
          //MOUSEOVER event on a DOM element stores the element in _bubbleHoverItem and MOUSEOUT event clears _bubbleHoverItem.
          //If a MOUSEOVER event is not followed by MOUSEOUT event, _bubbleHoverItem won't be cleared.
          //During the subsequent MOUSEOVER event if the event target is different than _bubbleHoverItem,
          //that indicates the browser have missed to fire MOUSEOUT event for previous DOM element stored in _bubbleHoverItem.
          //So building a new MOUSEOUT event for _bubbleHoverItem.
          var dvtEvent = dvt.DomEventFactory.newEvent(event, this.getCtx());
          //: Set the event as MOUSEOUT event, target as _bubbleHoverItem, relatedTarget as event.target
          //This is equivalent to firing new MOUSEOUT event for _bubbleHoverItem
          dvtEvent.modifyEventForIE(dvt.MouseEvent.MOUSEOUT, this._bubbleHoverItem);
          this.FireListener(dvtEvent, false);
        }
      }
      this._bubbleHoverItem = event.target;
    }
    else if (event.type == dvt.MouseEvent.MOUSEOUT) {
      this._bubbleHoverItem = null;
    }
  }

  var dvtEvent = dvt.DomEventFactory.newEvent(event, this.getCtx());
  this.FireListener(dvtEvent, false);
};


/**
 * The event listener that is called by the implementation object's capture phase listeners.
 * This function will wrap the event and delegate to the real event listeners.
 * @param {object} event the DOM event object
 * @this {object} the platform object actively processing the event object with an event listener
 * @private
 */
dvt.Displayable.prototype._captureListener = function(event) {
  if (dvt.Agent.isPlatformIE()) {
    // Moving an object in the dom for IE causes mouse over events to fire if the moved item is under the mouse
    // Ensure mouse over is not repeatedly called in such a case
    if (event.type == dvt.MouseEvent.MOUSEOVER) {
      if (this._captureHoverItem) {
        if (this._captureHoverItem == event.target) {
          // Prevent infinite loop
          return;
        }
        else {
          //MOUSEOVER event on a DOM element stores the element in _captureHoverItem and MOUSEOUT event clears _captureHoverItem.
          //If a MOUSEOVER event is not followed by MOUSEOUT event, _captureHoverItem won't be cleared.
          //During the subsequent MOUSEOVER event if the event target is different than _captureHoverItem,
          //that indicates the browser have missed to fire MOUSEOUT event for previous DOM element stored in _captureHoverItem.
          //So building a new MOUSEOUT event for _captureHoverItem.
          var dvtEvent = dvt.DomEventFactory.newEvent(event, this.getCtx());
          //: Set the event as MOUSEOUT event, target as _captureHoverItem, relatedTarget as event.target
          //This is equivalent to firing new MOUSEOUT event for _captureHoverItem
          dvtEvent.modifyEventForIE(dvt.MouseEvent.MOUSEOUT, this._captureHoverItem);
          this.FireListener(dvtEvent, true);
        }
      }
      this._captureHoverItem = event.target;
    }
    else if (event.type == dvt.MouseEvent.MOUSEOUT) {
      this._captureHoverItem = null;
    }
  }
  var dvtEvent = dvt.DomEventFactory.newEvent(event, this.getCtx());
  this.FireListener(dvtEvent, true);
};
// File containing all paint (fill and stroke) related functions defined on dvt.Displayable.

/**
 * Returns the fill for this shape.
 * @return {dvt.Fill}
 */
dvt.Displayable.prototype.getFill = function() {
  return this.GetProperty('fill');
};

/**
 * Specifies a fill to be applied to the shape.
 * @param {dvt.Fill} fill
 */
dvt.Displayable.prototype.setFill = function(fill) {
  this._manageDefinitions(this.GetProperty('fill'), fill);

  if (!fill) {
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill', 'none');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'fill-opacity');
    this.SetProperty('fill', null);
    return;
  }
  else {
    if (this.GetProperty('fill') === fill) {
      return;
    }
  }

  this.SetProperty('fill', fill);

  if (fill instanceof dvt.GradientFill || fill instanceof dvt.ImageFill || fill instanceof dvt.PatternFill) {
    dvt.SvgShapeUtils.addSpecialFill(fill, this.getCtx());
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill', dvt.ToolkitUtils.getUrlById(fill.getId()));
  } else {
    //Basic fill
    var fillObj = dvt.ColorUtils.fixColorForPlatform(fill.getColor(), fill.getAlpha());
    if (fillObj && fillObj['color']) {
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill', fillObj['color']);
      if (fillObj['alpha'] != null)
        dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', fillObj['alpha'], 1);
    }
  }

  // Make the fill immutable now that it has been applied.
  fill.__lock();

  this.UpdateSelectionEffect();
};


/**
 *  Sets a solid fill on this shape.
 *  @param {String}  color  The hex or RGB representation of the solid fill
 *  @param {number}  alpha  The fill opacity. Defaults to 1 if none specified.
 *  If null is specified, a transparent fill is applied.
 */
dvt.Displayable.prototype.setSolidFill = function(color, alpha) {
  this.setFill(new dvt.SolidFill(color, alpha));
};

/**
 *  Sets an invisible fill on this shape.
 */
dvt.Displayable.prototype.setInvisibleFill = function() {
  this.setFill(dvt.SolidFill.invisibleFill());
};

/**
 * Returns the stroke for this shape.
 * @return {dvt.Stroke}
 */
dvt.Displayable.prototype.getStroke = function() {
  return this._stroke;
};


/**
 *  Sets the stroke properties on this shape from the supplied stroke object.
 *  If the stroke object is null, any existing stroke is removed.
 *  @param {dvt.Stroke} stroke A stroke object.
 */
dvt.Displayable.prototype.setStroke = function(stroke) {
  this._manageDefinitions(this._stroke, stroke);

  this._stroke = stroke;

  if (!stroke) {
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-opacity');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-width');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-dasharray');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-dashoffset');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-linejoin');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-linecap');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-miterlimit');
    return;
  }

  //  Stroke color/alpha
  // gradient
  if (stroke instanceof dvt.GradientStroke) {
    dvt.SvgShapeUtils.addSpecialStroke(stroke, this.getCtx());
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke', dvt.ToolkitUtils.getUrlById(stroke.getId()));
    var alpha = stroke.getAlpha();
    if (alpha != null) {
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke-opacity', alpha);
    }
  }
  else {
    var strokeObj = dvt.ColorUtils.fixColorForPlatform(stroke.getColor(), stroke.getAlpha());
    if (strokeObj && strokeObj['color']) {
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke', strokeObj['color']);
      if (strokeObj['alpha'] != null)
        dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke-opacity', strokeObj['alpha'], 1);
    }
    else {
      dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke');
      dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-opacity');
    }
  }

  //  Stroke width
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke-width', stroke.getWidth(), 1);

  if (stroke.isFixedWidth())
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'vector-effect', 'non-scaling-stroke');

  //  Stroke type/style
  var st = stroke.getType();
  if (st !== dvt.Stroke.SOLID) {
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke-dasharray', stroke.getDash());
    if (stroke.getDashOffset()) {
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke-dashoffset', stroke.getDashOffset());
    }
  }
  else {
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-dasharray');
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'stroke-dashoffset');
  }

  //  Line-joining attribute
  var attrib = stroke.getLineJoin();
  if (attrib) {
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke-linejoin', attrib);
  }

  //  Line-ending attribute
  attrib = stroke.getLineEnd();
  if (attrib) {
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke-linecap', attrib);
  }

  //  miter limit attribute
  attrib = stroke.getMiterLimit();
  if (attrib) {
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'stroke-miterlimit', attrib);
  }

  // Make the stroke immutable now that it has been applied.
  stroke.__lock();
};


/**
 *  Sets a solid stroke on this shape.
 *  @param {String}  color  The hex or RGB representation of the solid fill
 *  @param {number}  alpha  The fill opacity. Defaults to 1 if none specified.
 *  @param {number}  strokeWidth  The stroke width. Defaults to 1 if none specified.
 *  If null is specified, a transparent fill is applied.
 */
dvt.Displayable.prototype.setSolidStroke = function(color, alpha, strokeWidth) {
  this.setStroke(new dvt.SolidStroke(color, alpha, strokeWidth));
};

/**
 * Manage the gradient/filter definitions for svg by keeping a reference count and removing unreferenced defs.
 * @param {object} oldObj The old gradient or filter definition.
 * @param {object} newObj The new gradient or filter definition.
 * @private
 */
dvt.Displayable.prototype._manageDefinitions = function(oldObj, newObj) {
  // If a new obj is specified, adjust reference counts and remove def if 0 references
  if (oldObj != newObj) {
    // Decrease count on existing obj
    if (oldObj) {
      oldObj._referenceCount--;
      if (oldObj._referenceCount == 0) {
        if (oldObj._defElem) {
          this.getCtx().removeDefs(oldObj._defElem);
          oldObj._defPresent = false;
        }
      }

    }
    if (newObj) {
      if (!newObj._referenceCount)
        newObj._referenceCount = 0;
      newObj._referenceCount++;
    }
  }
};
// File containing all transformation related functions defined on dvt.Displayable.


/**
 * Sets the horizontal and vertical translation to apply to this container.
 * @param {Number} tx   The horizontal translation to apply, in pixels.
 * @param {Number} ty   The vertical translation to apply, in pixels.
 */
dvt.Displayable.prototype.setTranslate = function(tx, ty) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  if (tx != null)
    decomp[dvt.Matrix._DECOMP_TX] = tx;
  if (ty != null)
    decomp[dvt.Matrix._DECOMP_TY] = ty;
  mat._recompose(decomp);
  this.setMatrix(mat);
};


/**
 * Returns the horizontal translation applied to this container.
 * @return {Number} horizontal translation, in pixels
 */
dvt.Displayable.prototype.getTranslateX = function() {
  var matrix = this.getMatrix();
  if (matrix) {
    //get the value from the matrix because other
    //transformations may have changed it
    return matrix._decompose()[dvt.Matrix._DECOMP_TX];
  }

  return 0;
};


/**  Set the horizontal translation to apply to this container.
 *  @param {Number} tx   The horizontal translation to apply, in pixels.
 */
dvt.Displayable.prototype.setTranslateX = function(tx) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[dvt.Matrix._DECOMP_TX] = tx;
  mat._recompose(decomp);
  this.setMatrix(mat);
};


/**
 * Return the vertical translation applied to this container.
 * @return {Number} vertical translation, in pixels
 */
dvt.Displayable.prototype.getTranslateY = function() {
  var matrix = this.getMatrix();
  if (matrix) {
    //get the value from the matrix, because other
    //transformations may have changed it
    return matrix._decompose()[dvt.Matrix._DECOMP_TY];
  }

  return 0;
};


/**  Set the vertical translation to apply to this container.
 *  @param {Number} ty   The vertical translation to apply, in pixels.
 */
dvt.Displayable.prototype.setTranslateY = function(ty) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[dvt.Matrix._DECOMP_TY] = ty;
  mat._recompose(decomp);
  this.setMatrix(mat);
};


/**
 * Sets the horizontal and vertical scale to apply to this container.
 * @param {Number} sx   The horizontal scale to apply.
 * @param {Number} sy   The vertical scale to apply.
 */
dvt.Displayable.prototype.setScale = function(sx, sy) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  if (sx)
    decomp[dvt.Matrix._DECOMP_SX] = sx;
  if (sy)
    decomp[dvt.Matrix._DECOMP_SY] = sy;
  mat._recompose(decomp);
  this.setMatrix(mat);
};


/**
 * Return the horizontal scale applied to this container.
 * @return {number}  horizontal scale
 */
dvt.Displayable.prototype.getScaleX = function() {
  var matrix = this.getMatrix();
  if (matrix) {
    //get the value from the matrix, because other
    //transformations may have changed it
    return matrix._decompose()[dvt.Matrix._DECOMP_SX];
  }

  return 1;
};


/**  Set the horizontal scale to apply to this container.
 *  @param {Number} sx   The horizontal scale to apply.
 */
dvt.Displayable.prototype.setScaleX = function(sx) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[dvt.Matrix._DECOMP_SX] = sx;
  mat._recompose(decomp);
  this.setMatrix(mat);
};


/**
 * Return the vertical scale applied to this container.
 * @return {number}  vertical scale
 */
dvt.Displayable.prototype.getScaleY = function() {
  var matrix = this.getMatrix();
  if (matrix) {
    //get the value from the matrix, because other
    //transformations may have changed it
    return matrix._decompose()[dvt.Matrix._DECOMP_SY];
  }

  return 1;
};


/**  Set the vertical scale to apply to this container.
 *  @param {Number} sy   The horizontal scale to apply.
 */
dvt.Displayable.prototype.setScaleY = function(sy) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[dvt.Matrix._DECOMP_SY] = sy;
  mat._recompose(decomp);
  this.setMatrix(mat);
};


/**
 * Return the rotation applied to this container.
 * @return {number}  rotation, in radians
 */
dvt.Displayable.prototype.getRotation = function() {
  var matrix = this.getMatrix();
  if (matrix) {
    //get the value from the matrix, because other
    //transformations may have changed it
    return matrix._decompose()[dvt.Matrix._DECOMP_R];
  }

  return 0;
};


/**  Set the rotation to apply to this container.
 *  @param {Number} angleRads   The rotation to apply, in radians.
 */
dvt.Displayable.prototype.setRotation = function(angleRads) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[dvt.Matrix._DECOMP_R] = angleRads;
  mat._recompose(decomp);
  this.setMatrix(mat);
};


/**
 * Return the transformation matrix applied to this container.
 * @return {dvt.Matrix} transformation matrix
 */
dvt.Displayable.prototype.getMatrix = function() {
  if (this._matrix) {
    return this._matrix;
  }

  return new dvt.Matrix();
};


/**
 * Set the transformation matrix to apply to this container.
 * When set, the matrix becomes permanently locked so that it becomes immutable.
 * A clone must be created if any updates to the matrix need to be made.
 * The same matrix can be set on more than one displayable irregardless of locking.
 * @param {dvt.Matrix} mat   The transformation matrix to apply.
 */
dvt.Displayable.prototype.setMatrix = function(mat) {
  // treat setting identity matrix same as setting null matrix
  if (mat && mat.isIdentity())
    mat = null;

  if (this._matrix != mat) {
    this._matrix = mat;

    // Lock the new matrix if it isn't already locked, before setting it on this displayable.
    // The same matrix can be set on more than one displayable irregardless of locking.
    if (this._matrix && !this._matrix.isLocked())
      this._matrix.__lock();

    // Create an outer elem if needed
    if (!this._outerElem && dvt.Displayable.HasAttributes(this.getElem(), dvt.Displayable._ATTRS_TRANSFERABLE_TO_OUTER))
      this._createOuterGroupElem();

    this._matrix = mat;
    //apply the new matrix if it's non-null
    if (mat) {
      var sMat = 'matrix(' + dvt.ToolkitUtils.roundDecimal(mat.getA()) + ',' + dvt.ToolkitUtils.roundDecimal(mat.getC()) +
          ',' + dvt.ToolkitUtils.roundDecimal(mat.getB()) + ',' + dvt.ToolkitUtils.roundDecimal(mat.getD()) + ','
                  + dvt.ToolkitUtils.roundDecimal(mat.getTx()) + ',' + dvt.ToolkitUtils.roundDecimal(mat.getTy()) + ')';

      //set the transform attribute on the outer SVG element of this shape
      dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'transform', sMat, 'matrix(1,0,0,1,0,0)');

      //set the vector-effect attribute to prevent the stroke-width
      //from scaling with the transform
      //NOTE: this is commented out for now because it causes strange rendering
      //artifacts when scaling to a small value
      //dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'vector-effect', 'non-scaling-stroke') ;
    }
    //if clearing the existing matrix by setting a null or undefined mat,
    //then remove the existing attribute from the DOM
    else {
      var transformAttr = dvt.ToolkitUtils.getAttrNullNS(this.getElem(), 'transform');
      if (transformAttr) {
        dvt.ToolkitUtils.removeAttrNullNS(this.getElem(), 'transform');
        if (dvt.Agent.isPlatformIE()) {
          // , prev removeAttributeNS()
          dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'transform', null);// fails for IE9 (9.0.8112.16421)
        }

      }
      //NOTE: this is commented out for now because it causes strange rendering
      //artifacts when scaling to a small value
      var vectorEffectAttr;// = dvt.ToolkitUtils.getAttrNullNS(this.getElem(), 'vector-effect');
      if (vectorEffectAttr) {
        dvt.ToolkitUtils.removeAttrNullNS(this.getElem(), 'vector-effect');
      }
    }
  }
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Container for displayable objects.
 * @extends {dvt.Displayable}
 * @param {dvt.Context} context
 * @param {string=} id The optional id for the corresponding DOM element.
 * @class
 * @constructor
 */
dvt.Container = function(context, id) {
  this.Init(context, 'g', id);
};

dvt.Obj.createSubclass(dvt.Container, dvt.Displayable);


/**
 * @override
 */
dvt.Container.prototype.Init = function(context, type, id) {
  // For the SVG implementation, we need to know whether this is a standard
  // non-shape container, or a shape "container".  Since elementary objects
  // may not be nested, e.g. a rect containing another rect, an artificial
  // group must be constructed to group the parent and the children.  That
  // is they actually become grouped siblings.
  this._bShapeContainer = (this instanceof dvt.Shape);// if shape "container"
  dvt.Container.superclass.Init.call(this, context, type != null ? type : 'g', id);
  this._childGroupElem = null;// child surround group
};


/**
 * @protected
 * Array of SVG attributes that should be transferred from the shape
 * tag to the group when this shape becomes a group (when children
 * are added to it).
 */
dvt.Container.AttributesTransferableToGroup = ['transform', 'opacity', 'style', 'visibility', 'pointer-events', 'clip-path', 'cursor'];


/**
 *  Adds the specified object as a child of this container. The object is
 *  added to the end of the child list.  If the object is already a child,
 *  it will be moved to the end of the child list.
 *   @param {dvt.Displayable} obj The object to be added.
 */
dvt.Container.prototype.addChild = function(obj) {

  if (obj) {
    // Remove the object from its current parent
    var oldParent = obj.getParent();
    if (oldParent)
      oldParent.removeChild(obj);

    //initialize _arList after removing child from parent in case
    //this container was the parent, which could result in removeChild()
    //setting _arList to null if the last child was removed
    if (!this._arList) {
      this._arList = [];
    }

    // Add the object to this container
    obj.setParent(this);

    if (this._bShapeContainer) {
      //  This is a shape "container".
      //  If no previous children, will create a group DOM element for the this
      //  (parent) object and add the new child to the child group DOM element.
      //  else will add the object directly to the shape group container element.
      this.CreateChildGroupElem(false);
    }

    //   - GET RID OF DVTGOLINK AND IMPLS
    //  if there is an anchor elem <a> for this container
    //  append child to the <a> element
    //  otherwise append child directly to this container group element
    var containerElem = this.getContainerElem();
    dvt.ToolkitUtils.appendChildElem(containerElem, obj.getOuterElem());

    this._arList.push(obj);
  }
};


/**
 *  Adds the specified object as a child of this container at the specified index. Returns
 *  immediately if the index position doesn't already exist in the child list (unless the
 *  index equals the number of children).  If a currently occupied index is specified, the
 *  current child at that position and all subsequent children are moved one position
 *  higher in the list.  If the object is a child of another container, it is removed and
 *  reparented in the new container. Note that the action of this method is to remove the
 *  object from the current container (which may also be the container that it will be
 *  added to), so for an object "move" in the same container, all objects with a higher
 *  index will now move one position lower.  The object is now inserted at the supplied
 *  index.
 *  @param {dvt.Obj} obj  The object to be added (must be a descendent of {@link dvt.Obj}).
 *  @param {number} index The index at which to add this object
 */
dvt.Container.prototype.addChildAt = function(obj, index) {
  this.AddChildAt(obj, index);
};

// TODO JSDoc, exists so that shapes can call without being confused by the additional shapes for selection
dvt.Container.prototype.AddChildAt = function(obj, index) {
  if ((index >= 0) && (index <= this.getNumChildren()) && obj)// validate index
  {
    var curIndex = this._findChild(obj);// note if obj is child of this container
    if ((curIndex >= 0) && (curIndex == index))// do nothing if child of this container
      return;// and move is to current position
    var oldParent = obj.getParent();// remove object from current parent
    if (oldParent)
      oldParent.removeChild(obj);
    obj.setParent(this);// reparent

    // If obj is child of this container and the intent is to place it after the last
    // object (before the above remove was done), decrement the index.
    if (curIndex >= 0) {
      if (index == (this.getNumChildren() + 1))
        index--;
    }

    var idx = index;

    if (this._bShapeContainer) {
      //  This is a shape "container".
      //  If no previous children, will create a group DOM element for the this
      //  (parent) object and add the new child to the child group DOM element.
      //  else will add the object directly to the shape group container element.
      this.CreateChildGroupElem(false);

      //need to increment the index to account for the shape dom element,
      //which should be the first child of the childGroupElem
      idx++;
    }

    //   - GET RID OF DVTGOLINK AND IMPLS
    //  if there is an anchor elem <a> for this container
    //  append child to the <a> element
    //  otherwise append child directly to this container group element
    var containerElem = this.getContainerElem();
    var existingNode = containerElem.childNodes[idx];
    // : IE9 cannot handle a value of undefined in insertBefore.  Set to null in such a case.
    if (!existingNode)
      existingNode = null;
    containerElem.insertBefore(obj.getOuterElem(), existingNode);//@HTMLUpdateOK

    if (!this._arList) {
      this._arList = [];
    }
    this._arList.splice(index, 0, obj);
  }
};


/**
 * Returns true if the specified displayable is a direct child of this container.
 * @param {dvt.Displayable} obj The object to be searched for.
 * @return {boolean} True if object is contained by this container, else false.
 */
dvt.Container.prototype.contains = function(obj) {
  return (this._findChild(obj) >= 0);
};


/**
 * Returns index of specified child obj in the internal list, or -1 if not
 * found.
 * @type {dvt.Obj}
 * @private
 */
dvt.Container.prototype._findChild = function(obj) {
  var idx = - 1;

  if (this._arList) {
    var len = this._arList.length;
    for (var i = 0; i < len; i++) {
      // find the obj
      if (this._arList[i] === obj) {
        idx = i;
        break;
      }
    }
  }

  return idx;
};


/**
 *   Returns the child after the specified object, or null if it is the last
 *   in the list.
 *   @param {dvt.Obj} obj  The object whose successor is required.
 *   @type {dvt.Obj}
 */
dvt.Container.prototype.getChildAfter = function(obj) {
  var o = null;
  var idx = this._findChild(obj);

  if ((idx >= 0) && (++idx < this._arList.length)) {
    o = this._arList[idx];
  }

  return o;
};


/**
 *   Returns the child before the specified object, or null if the is the first
 *   in the list.
 *   @param {dvt.Obj} obj  The object whose predecessor is required.
 *   @type {dvt.Obj}
 */
dvt.Container.prototype.getChildBefore = function(obj) {
  var o = null;
  var idx = this._findChild(obj);

  if (idx > 0) {
    o = this._arList[--idx];
  }

  return o;
};


/**
 *   Returns the child at the specified zero-relative position, or null if
 *   there is no child represented by the position.
 *   @param {number} idx  The zero-relative index to the child object.
 *   @type {dvt.Obj}
 */
dvt.Container.prototype.getChildAt = function(idx) {
  var o = null;

  if (this._arList && (this._arList.length > idx) && (idx >= 0)) {
    o = this._arList[idx];
  }

  return o;
};


/**
 *   Returns the container index of the specified object, or -1 if the object
 *   is not a direct child of the container.
 *   @param {dvt.Obj} obj  The object whose container index is required.
 *   @type {number}
 */
dvt.Container.prototype.getChildIndex = function(obj) {
  return this._findChild(obj);
};


/**
 *   Returns the number of direct children of this container
 *   @type {number}
 */
dvt.Container.prototype.getNumChildren = function() {
  return (this._arList ? this._arList.length : 0);
};


/**
 *   Removes the specified child object from this container.
 *   @param {dvt.Obj} obj  The object to be removed.
 */
dvt.Container.prototype.removeChild = function(obj) {
  var idx = this._findChild(obj);// is child in container
  if (idx !== - 1) {
    this._removeObj(obj, idx);
  }
};


/**
 *   Removes the specified child object from this container.
 *   @param {dvt.Displayable} obj The object to be removed.
 */
dvt.Container.prototype.removeChildImpl = function(obj) {
  var elemObj = obj.getOuterElem();// obj's outer DOM element
  var parent = obj.getParent();// get parent object (the container or the shape group container)

  if (elemObj && parent) {
    //  - GET RID OF DVTGOLINK AND IMPLS
    var elem = this.getContainerElem();
    elem.removeChild(elemObj);
  }

  //  If no more children, can remove the added group for child containership,
  //  and reparent the containing shape directly back to its parent in the
  //  position that the added child group container occupied.
  //  - GET RID OF DVTGOLINK AND IMPLS
  // don't remove the childGroupElem because we need it to hold the anchor
  if (!this._anchorElem && this._bShapeContainer && this.getNumChildren() === 1) {
    var childGroupElem = this._childGroupElem;
    var childGroupElemParent = (childGroupElem ? childGroupElem.parentNode : null);

    if (childGroupElemParent) {
      dvt.Displayable.TransferAttributes(childGroupElem, this._elem, this.GetAttributesTransferableToGroup());
      childGroupElemParent.replaceChild(this._elem, childGroupElem);
      this._childGroupElem = null;
    }
  }
};


/**
 *   Removes the specified child object at the index specfied from this container.
 *   @param {number} idx  The index of the object to be removed.
 *   @return {dvt.Obj}  The object removed.
 */
dvt.Container.prototype.removeChildAt = function(idx) {
  var obj = this.getChildAt(idx);

  if (obj) {
    this._removeObj(obj, idx);
  }

  return obj;
};


/**
 *   Removes all child object's from this container.
 */
dvt.Container.prototype.removeChildren = function() {
  if (this._arList) {
    var ar = this._arList;

    while (this.getNumChildren() > 0) {
      this._removeObj(ar[0], 0);
    }
  }
};


/**
 *   Removes the specified object from this container.
 *   @param {dvt.Obj}  obj   The object to be removed.
 *   @param {number}  idx   The index position (zero relative) of the child
 *                          in the container's list of chhildren.
 *    @private
 */
dvt.Container.prototype._removeObj = function(obj, idx) {
  //  obj must be in the container.
  this.removeChildImpl(obj);// perform platform remove
  obj.setParent(null);

  this._arList.splice(idx, 1);// remove from list
  if (this._arList.length === 0) {
    this._arList = null;
  }
};


/**
 *    Destroy the container.  It should no longer be used or displayed
 */
dvt.Container.prototype.destroy = function() {
  dvt.Container.superclass.destroy.call(this);
  var childCount = this.getNumChildren();
  for (var i = 0; i < childCount; i++) {
    var child = this.getChildAt(i);
    child.destroy();
  }
};


/**
 * Gets the hyperlink information for this object
 */
dvt.Container.prototype.getHyperlink = function() {
  return this._linkObj;
};


/**
 * Returns an rray of SVG attributes that should be transferred from the shape
 * tag to the group when this shape becomes a group (when children are added to it).
 * @return {array}
 */
dvt.Container.prototype.GetAttributesTransferableToGroup = function() {
  return dvt.Container.AttributesTransferableToGroup;
};


/**
 * @override
 */
dvt.Container.prototype.getElem = function() {
  return (this._childGroupElem ? this._childGroupElem : this._elem);
};

/**
 * Create a group element for adding children.
 * @param {boolean} rmChildren True if all children should be removed
 * @param {boolean} forced True always create a child group element for shape container
 * @protected
 */
dvt.Container.prototype.CreateChildGroupElem = function(rmChildren, forced) {
  //  This is a shape "container".
  //  If no previous children, will create a group DOM element for the this
  //  (parent) object and add the new child to the child group DOM element.
  //  else will add the object directly to the shape group container element.
  if (!this._childGroupElem && (forced || this.getNumChildren() === 0)) {
    var childGroupId = (dvt.Displayable.SET_ID_ON_DOM && this._id) ? this._id + '_g' : null;
    this._childGroupElem = dvt.SvgShapeUtils.createElement('g', childGroupId);

    //  Remove this's DOM element from the parent, and append to child group DOM element.
    var parent = this.getParent();
    var elemParent;
    if (parent) {
      elemParent = parent.getElem();
      elemParent.replaceChild(this._childGroupElem, this._elem);
    }
    if (!rmChildren)
      dvt.ToolkitUtils.appendChildElem(this._childGroupElem, this._elem);// add shape to new group
    //transfer attributes from the old outermost SVG element to the
    //new outer group element
    dvt.Displayable.TransferAttributes(this._elem, this._childGroupElem, this.GetAttributesTransferableToGroup());

    //Note need to copy _obj reference to the new group element so that events can be propagated.
    if (this._elem._obj) {
      this._childGroupElem._obj = this._elem._obj;
    }

    // Track the number of child group elements created, so that we can move away from this pattern
    if (dvt.Agent.isEnvironmentTest())
      document.shapeContainerCount++;
  }
  else if (rmChildren) {
    this.removeChildren();
  }

};


//:
/**
 * @override
 */
dvt.Container.prototype.getDimensionsWithStroke = function() {
  //a pure container has no shape of its own, so calculate the
  //dims for all child shapes in the subtree rooted at this container
  //build an initial array of all direct children of this container
  var ar = [];
  var numChildren = this.getNumChildren();
  for (var i = 0; i < numChildren; i++) {
    ar.push(this.getChildAt(i));
  }

  //loop over the array of children until it's empty
  var totalDims = null;
  while (ar.length > 0) {
    //remove the first object from the array
    var child = ar.shift();
    //get dims in coordinate space of this container, because we're
    //processing whole subtree of children under this container
    var dims = child.GetDimensionsWithStroke(this);
    if (dims) {
      if (!totalDims) {
        totalDims = dims;
      }
      else {
        totalDims = totalDims.getUnion(dims);
      }
    }

    //add any children of current object to end of array
    numChildren = child.getNumChildren();
    for (var i = 0; i < numChildren; i++) {
      ar.push(child.getChildAt(i));
    }
  }
  return totalDims;
};

//:
dvt.Container.prototype.GetDimensionsWithStroke = function(targetCoordinateSpace) {
  //pure container doesn't have its own dimensions
  return null;
};

/*
 * move children from source to target element
 */
dvt.Container._reparentChildren = function(target, source) {
  var childNodes = source.childNodes;

  if (childNodes) {
    var node;
    var lastNode;

    for (var i = childNodes.length - 1; i >= 0; i--) {
      node = childNodes[i];
      if (lastNode) {
        target.insertBefore(node, lastNode);//@HTMLUpdateOK
      }
      else {
        dvt.ToolkitUtils.appendChildElem(target, node);
      }
      lastNode = node;
    }
  }
};


/**
 * Returns the anchor element if exists.
 */
dvt.Container.prototype.getContainerElem = function() {
  return this._anchorElem ? this._anchorElem : this.getElem();
};


/**
 * Dispatches the native event to the internal dom element
 * Note: Use with caution
 * @param {Object} event
 */
dvt.Container.prototype.dispatchNativeEvent = function(event) {
  var nativeEvent = event.getNativeEvent();
  var target = null;

  if (this._bShapeContainer)
    target = this._childGroupElem;
  else if (this._anchorElem)
    target = this._anchorElem;
  else
    target = this._elem;

  if (target.dispatchEvent)
    target.dispatchEvent(nativeEvent);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Top level container for all displayables contained within the SVG document.  This class should not be extended.
 * @extends {dvt.Container}
 * @param {dvt.Context} context
 * @param {SVGElement} svgRoot The containing SVG document.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @class
 * @constructor
 */
var DvtStage = function(context, svgRoot, id) {
  // Note: Initialization code in constructor to prevent subclassing.
  this.Init(context, 'g', id);

  this._SVGRoot = svgRoot;// containing SVG DOM element

  //to disable ability to select text, 
  this.disableSelection(this._elem);

  //set cursor to default to avoid text cursors on text objects
  this.setCursor('default');
};

dvt.Obj.createSubclass(DvtStage, dvt.Container);


/**
 * @override
 */
DvtStage.prototype.addChild = function(obj) {
  // Note: This function exists to ensure that applications can add children to the stage.  Do not remove.
  DvtStage.superclass.addChild.call(this, obj);
};


/**
 * Appends the specified element to the defs element for this stage.
 * @param {object} elem
 */
DvtStage.prototype.appendDefs = function(elem) {
  dvt.ToolkitUtils.appendChildElem(this._elemDefs, elem);
};


/**
 * Returns the defs element for this stage.
 * @return {object}
 */
DvtStage.prototype.getDefs = function() {
  return this._elemDefs;
};


/**
 * Returns the root SVG document.
 * @return {object}
 */
DvtStage.prototype.getSVGRoot = function() {
  return this._SVGRoot;
};

// TODO  CLEANUP
DvtStage.prototype.disableSelection = function(target) {
  target.onselectstart = function() {
    return false;
  };
  target.onselect = function() {
    return false;
  };
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 *  Abstract base class for shape displayables.
 *  @extends {dvt.Container}
 *  @class
 *  @constructor
 */
dvt.Shape = function() {
  // This class should never be instantiated directly
};

//  Allow shapes to become 'containers' themselves.  Note: this does not
//  provide a true parent/child relationship since this not available in SVG. TODO  reconsider this decision
dvt.Obj.createSubclass(dvt.Shape, dvt.Container);


/**
 * @override
 */
dvt.Shape.prototype.Init = function(context, type, id) {
  dvt.Shape.superclass.Init.call(this, context, type, id);

  // TODO : For all properties that default to null or false, remove from constructor
  this._bSelectable = false;
  this.IsSelected = false;
  this.InnerShape = null;
  this.HoverInnerStroke = null;
  this.HoverOuterStroke = null;
  this.SelectedInnerStroke = null;
  this.SelectedOuterStroke = null;
  this.SelectedHoverInnerStroke = null;
  this.SelectedHoverOuterStroke = null;
  this.OriginalStroke = null;
  this._isOriginalStrokeSet = false;
  this.IsShowingHoverEffect = false;
};

/**  Changes the shape to an outline shape format.  Used for legends
 *  markers that represent a hidden state for the associated series risers.
 *  @param {String} fc Border color for hollow shape in format of #aarrggbb
 *  @param {number} strokeWidth Stroke width used for shapes that were transofrmed (optional)
 */
dvt.Shape.prototype.setHollow = function(fc, strokeWidth) {
  if (!this._bHollow) {
    // Save original fill and stroke to restore
    this._origFill = this.GetProperty('fill');
    this._origStroke = this.getStroke();
    // Set hollow shape fill and stroke based on shape fill
    var hollowFill = dvt.SolidFill.invisibleFill();
    var hollowStroke;
    if (fc) {
      hollowStroke = new dvt.SolidStroke(dvt.ColorUtils.getRGB(fc), dvt.ColorUtils.getAlpha(fc), strokeWidth);
    }
    else {
      hollowStroke = new dvt.SolidStroke(this.GetProperty('fill').getColor(), this.GetProperty('fill').getAlpha(), strokeWidth);
    }
    this.setFill(hollowFill);
    this.setStroke(hollowStroke);
    this._bHollow = true;
  }
  else {
    this.setFill(this._origFill);
    this.setStroke(this._origStroke);
    this._bHollow = false;
  }
};


/**  Returns whether a shape is hollow.
 *  @return {boolean} True if the shape is hollow
 */
dvt.Shape.prototype.isHollow = function() {
  return this._bHollow;
};


/**
 *    Destroy the shape.  It should no longer be used or displayed
 */
dvt.Shape.prototype.destroy = function() {
  dvt.Shape.superclass.destroy.call(this);
  this.setFill(null);
  this.setStroke(null);
};

//:
/**
 * @override
 */
dvt.Shape.prototype.getDimensionsWithStroke = function() {
  //get the dims for this shape by itself
  var dims = this.GetElemDimensionsWithStroke();
  //get the dims for any children of this container
  var containerDims = dvt.Shape.superclass.getDimensionsWithStroke.call(this);
  //create union of shape and container dims
  if (dims && containerDims) {
    dims = dims.getUnion(containerDims);
  }
  else if (containerDims) {
    dims = containerDims;
  }

  return dims;
};

//:
dvt.Shape.prototype.GetDimensionsWithStroke = function(targetCoordinateSpace) {
  //get the dims for this shape by itself
  var dims = this.GetElemDimensionsWithStroke();
  if (!targetCoordinateSpace || targetCoordinateSpace === this)
    return dims;
  else {
    // Calculate the bounds relative to the target space
    return this.ConvertCoordSpaceRect(dims, targetCoordinateSpace);
  }
};

//:
dvt.Shape.prototype.GetElemDimensionsWithStroke = function() {
  //get the dims for this shape by itself
  var dims = dvt.Shape.superclass.GetElemDimensionsWithStroke.call(this);
  //assume that stroke touches every edge of bounding box, so push out
  //every edge by half the stroke width
  var stroke = this.getStroke();
  if (dims && stroke) {
    var sw = stroke.getWidth();
    if (sw) {
      var halfSw = .5 * sw;
      dims.x -= halfSw;
      dims.y -= halfSw;
      dims.w += sw;
      dims.h += sw;
    }
  }
  return dims;
};


/**
 * Updates the geometries of the dvt.Shape used for the selection effects.
 * @protected
 */
dvt.Shape.prototype.UpdateSelectionEffect = function() {
  if (this.isSelected() || this.isHoverEffectShown()) {
    var stroke;
    if (this.InnerShape) {
      stroke = this.InnerShape.getStroke();
      this.removeChild(this.InnerShape);
    }
    this.InnerShape = this.copyShape();
    this.InnerShape.setMouseEnabled(false);
    this.InnerShape.setFill(this.getFill());
    if (stroke)
      this.InnerShape.setStroke(stroke);
    this.InnerShape.setMouseEnabled(false);
    this.InnerShape.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
    this.AddChildAt(this.InnerShape, 0);
  }
};


/**
 * Sets the hover inner and outer strokes for this shape.
 * If there is only one stroke color for this effect, only innerStroke needs to be set.
 * @param {dvt.Stroke} innerStroke The inner stroke color for this effect
 * @param {dvt.Stroke} outerStroke The outer stroke color for this effect
 * @return {dvt.Shape} To be used for chaining
 */
dvt.Shape.prototype.setHoverStroke = function(innerStroke, outerStroke) {
  this.HoverInnerStroke = innerStroke;
  this.HoverOuterStroke = outerStroke;
  return this;
};


/**
 * Sets the selected inner and outer strokes for this shape.
 * If there is only one stroke color for this effect, only innerStroke needs to be set.
 * @param {dvt.Stroke} innerStroke The inner stroke color for this effect
 * @param {dvt.Stroke} outerStroke The outer stroke color for this effect
 * @return {dvt.Shape} To be used for chaining
 */
dvt.Shape.prototype.setSelectedStroke = function(innerStroke, outerStroke) {
  this.SelectedInnerStroke = innerStroke;
  this.SelectedOuterStroke = outerStroke;
  return this;
};


/**
 * Sets the selected hover inner and outer stroke for this shape.
 * If there is only one stroke color for this effect, only innerStroke needs to be set.
 * If none are given, default will be to use the selected outer and hover inner strokes.
 * @param {dvt.Stroke} innerStroke The inner stroke color for this effect
 * @param {dvt.Stroke} outerStroke The outer stroke color for this effect
 * @return {dvt.Shape} To be used for chaining
 */
dvt.Shape.prototype.setSelectedHoverStroke = function(innerStroke, outerStroke) {
  this.SelectedHoverInnerStroke = innerStroke;
  this.SelectedHoverOuterStroke = outerStroke;
  return this;
};


/**
 * Implemented for DvtSelectable
 */
dvt.Shape.prototype.setSelectable = function(bSelectable) {
  this._bSelectable = bSelectable;
  if (this._bSelectable)
    this.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
  else
    this.setCursor(null);
};


/**
 * Implemented for DvtSelectable
 */
dvt.Shape.prototype.isSelectable = function() {
  return this._bSelectable;
};


/**
 * Implemented for DvtSelectable
 */
dvt.Shape.prototype.isSelected = function() {
  return this.IsSelected;
};


/**
 * Implemented for DvtSelectable
 * @override
 */
dvt.Shape.prototype.setSelected = function(selected) {
  if (this.IsSelected == selected)
    return;

  if (!this._isOriginalStrokeSet) {
    this._isOriginalStrokeSet = true;
    this.OriginalStroke = this.getStroke();
  }

  this.IsSelected = selected;

  if (this.isSelected()) {
    // on selection, set the outer border treatment on the dvt.Shape and the inner border treatment
    // on its copy which is placed in front of it with the same fill
    this.UpdateSelectionEffect();

    if (this.isHoverEffectShown()) {
      this.CreateSelectedHoverStrokes();
      this.InnerShape.setStroke(this.SelectedHoverInnerStroke);
      this.setStroke(this.SelectedHoverOuterStroke);
    }
    else {
      this.InnerShape.setStroke(this.SelectedInnerStroke);
      this.setStroke(this.SelectedOuterStroke);
    }
  }
  else {
    this.removeChild(this.InnerShape);
    this.setStroke(this.OriginalStroke);
  }
};


/**
 * Implemented for DvtSelectable
 * @override
 */
dvt.Shape.prototype.showHoverEffect = function() {
  if (this.IsShowingHoverEffect)
    return;

  this.IsShowingHoverEffect = true;

  if (!this._isOriginalStrokeSet) {
    this._isOriginalStrokeSet = true;
    this.OriginalStroke = this.getStroke();
  }

  this.UpdateSelectionEffect();

  if (this.isSelected()) {
    this.CreateSelectedHoverStrokes();
    this.InnerShape.setStroke(this.SelectedHoverInnerStroke);
    this.setStroke(this.SelectedHoverOuterStroke);
  }
  else {
    this.InnerShape.setStroke(this.HoverInnerStroke);
    this.setStroke(this.HoverOuterStroke);
  }
};


/**
 * Initializes the selected hover strokes
 * @protected
 */
dvt.Shape.prototype.CreateSelectedHoverStrokes = function() {
  if (!this.SelectedHoverInnerStroke)
    this.SelectedHoverInnerStroke = this.HoverInnerStroke.clone();
  if (!this.SelectedHoverOuterStroke) {
    this.SelectedHoverOuterStroke = this.SelectedOuterStroke.clone();
    this.SelectedHoverOuterStroke.setWidth(this.SelectedOuterStroke.getWidth() + (this.HoverInnerStroke.getWidth() - this.SelectedInnerStroke.getWidth()));
  }
};


/**
 * Implemented for DvtSelectable
 */
dvt.Shape.prototype.hideHoverEffect = function() {
  if (!this.IsShowingHoverEffect)
    return;

  this.IsShowingHoverEffect = false;
  if (this.isSelected()) {
    this.InnerShape.setStroke(this.SelectedInnerStroke);
    this.setStroke(this.SelectedOuterStroke);
  }
  else {
    this.removeChild(this.InnerShape);
    this.setStroke(this.OriginalStroke);
  }
};


/**
 * Determine if the selection hover effect is shown.
 * @type {boolean}
 */
dvt.Shape.prototype.isHoverEffectShown = function() {
  return this.IsShowingHoverEffect;
};


/**
 * Override dvt.Container's addChildAt to account for the selection shape
 * @override
 */
dvt.Shape.prototype.addChildAt = function(obj, idx) {
  dvt.Shape.superclass.addChildAt.call(this, obj, idx + this._getInnerShapeCount());
};


/**
 * Override dvt.Container's getChildAt to account for the selection shape
 * @override
 */
dvt.Shape.prototype.getChildAt = function(obj, idx) {
  return dvt.Shape.superclass.getChildAt.call(this, obj, idx + this._getInnerShapeCount());
};


/**
 * Override dvt.Container's getChildIndex to account for the selection shape
 * @override
 */
dvt.Shape.prototype.getChildIndex = function(obj) {
  var idx = dvt.Shape.superclass.getChildIndex.call(this, obj);
  return (this.isSelected() || this.isHoverEffectShown()) ? idx + 1 : idx;
};


/**
 * Override dvt.Container's removeChildAt to account for the selection shape
 * @override
 */
dvt.Shape.prototype.removeChildAt = function(idx) {
  dvt.Shape.superclass.removeChildAt.call(this, idx + this._getInnerShapeCount());
};


/**
 * @override
 */
dvt.Shape.prototype.getDimensions = function(targetCoordinateSpace) {
  // Optimized implementation that allows container geometry to be taken into account to avoid costly DOM calls
  if (this.getDimensionsSelf && (this.getNumChildren() - this._getInnerShapeCount() == 0))
    return this.getDimensionsSelf(targetCoordinateSpace);
  else
    return dvt.Shape.superclass.getDimensions.call(this, targetCoordinateSpace);
};


/**
 * Returns the number of inner shapes that are part of the child list.  This value should be used as an offset to find
 * the true child count.
 * @private
 */
dvt.Shape.prototype._getInnerShapeCount = function() {
  // TODO CLEANUP:  Technically we should override getNumChildren, but I'm nervous about changing this behavior.
  //               We'll end up fine once shapes can no longer be child containers.
  return (this.isSelected() || this.isHoverEffectShown()) ? 1 : 0;
};


/**
 * @override
 */
dvt.Shape.prototype.SvgPropertyChanged = function(name) {
  this.UpdateSelectionEffect();
};


/**
 * Makes and returns a copy of the shape with the same geometries. The original shape's fill, stroke, and id will not
 * be copied over.
 * @return {dvt.Shape} A copy of this shape with the same constructor arguments.
 */
dvt.Shape.prototype.copyShape = function() {
  // subclasses should implement
  return null;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Abstract base class for circular displayable that is drawn around a point.
 * @extends {dvt.Shape}
 * @class
 * @constructor
 */
var DvtCircularShape = function() {
  // This class should never be instantiated directly
};

dvt.Obj.createSubclass(DvtCircularShape, dvt.Shape);


/**
 * @param {dvt.Context} context
 * @param {string} type The type of SVG element to be created.
 * @param {number} cx The x coordinate of the center of the shape.
 * @param {number} cy The y coordinate of the center of the shape.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
DvtCircularShape.prototype.Init = function(context, type, cx, cy, id) {
  DvtCircularShape.superclass.Init.call(this, context, type, id);
  this.setCx(cx).setCy(cy);
};


/**
 * Returns the x coordinate of the center of the shape.
 * @return {number}
 */
DvtCircularShape.prototype.getCx = function() {
  return this.GetProperty('cx');
};


/**
 * Specifies the x coordinate of the center of the shape.
 * @param {number} cx
 * @return {DvtCircularShape}
 */
DvtCircularShape.prototype.setCx = function(cx) {
  return this.SetSvgProperty('cx', cx, 0);
};


/**
 * Returns the y coordinate of the center of the shape.
 * @return {number}
 */
DvtCircularShape.prototype.getCy = function() {
  return this.GetProperty('cy');
};


/**
 * Specifies the y coordinate of the center of the shape.
 * @param {number} cy
 * @return {DvtCircularShape}
 */
DvtCircularShape.prototype.setCy = function(cy) {
  return this.SetSvgProperty('cy', cy, 0);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Abstract base class for polygon displayable that is defined by an array of points.
 * @extends {dvt.Shape}
 * @class
 * @constructor
 */
var DvtPolygonalShape = function() {
  // This class should never be instantiated directly
};

dvt.Obj.createSubclass(DvtPolygonalShape, dvt.Shape);


/**
 * @param {dvt.Context} context
 * @param {string} type The type of SVG element to be created.
 * @param {array} arPoints The array of coordinates for this polygon, in the form [x1,y1,x2,y2...].
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
DvtPolygonalShape.prototype.Init = function(context, type, arPoints, id) {
  DvtPolygonalShape.superclass.Init.call(this, context, type, id);

  if (arPoints)
    this.setPoints(arPoints);
};


/**
 * Returns the array of coordinates for this shape, in the form [x1,y1,x2,y2...].
 * @return {array}
 */
DvtPolygonalShape.prototype.getPoints = function() {
  return this.GetProperty('arPoints');
};


/**
 * Specifies the array of coordinates for this shape, in the form [x1,y1,x2,y2...].
 * @param {array} arPoints
 * @return {DvtPolygonalShape}
 */
DvtPolygonalShape.prototype.setPoints = function(arPoints) {
  this.SetProperty('arPoints', arPoints);
  return this.SetSvgProperty('points', dvt.SvgShapeUtils.convertPointsArray(arPoints));
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtPolygonalShape.prototype.getDimensionsSelf = function(targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = dvt.PolygonUtils.getDimensions(this.getPoints());
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Arc displayable.
 * @param {dvt.Context} context
 * @param {number} cx The x coordinate of the center of the arc.
 * @param {number} cy The y coordinate of the center of the arc.
 * @param {number} rx The horizontal radius of the arc.
 * @param {number} ry The vertical radius of the arc.
 * @param {number} startAngle The starting angle in degrees (following the normal anti-clockwise is positive convention).
 * @param {number} angleExtent The angle extent in degrees (following the normal anti-clockwise is positive convention).
 * @param {String=} closureType An optional closure type for the arc. Closure types are {@link dvt.Arc#OPEN} (the default),
 *                              {@link dvt.Arc#CHORD} and {@link dvt.Arc#PIE}. TODO  cleanup types
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {dvt.Shape}
 * @class
 * @constructor
 */
dvt.Arc = function(context, cx, cy, rx, ry, startAngle, angleExtent, closureType, id)
{
  this.Init(context, cx, cy, rx, ry, startAngle, angleExtent, closureType, id);
};

dvt.Obj.createSubclass(dvt.Arc, dvt.Shape);

// TODO  we should find out if this shape is needed at all.  If so, major cleanup needed
// TODO  this class is setting a bunch of non-path properties on paths
// TODO  the usage of createArc is inconsistent
// TODO  add linkages to self on return


/**
 * Closure type - arc is not closed.
 * @type {String}
 */
dvt.Arc.OPEN = 'OPEN';


/**
 * Closure type - arc is closed to create a segment.
 * @type {String}
 */
dvt.Arc.CHORD = 'CHORD';


/**
 * Closure type - arc is closed to create a sector.
 * @type {String}
 */
dvt.Arc.PIE = 'PIE';


/**
 * @param {dvt.Context} context
 * @param {number} cx The x coordinate of the center of the arc.
 * @param {number} cy The y coordinate of the center of the arc.
 * @param {number} rx The horizontal radius of the arc.
 * @param {number} ry The vertical radius of the arc.
 * @param {number} startAngle The starting angle in degrees (following the normal anti-clockwise is positive convention).
 * @param {number} angleExtent The angle extent in degrees (following the normal anti-clockwise is positive convention).
 * @param {String=} closureType An optional closure type for the arc. Closure types are {@link dvt.Arc#OPEN} (the default),
 *                              {@link dvt.Arc#CHORD} and {@link dvt.Arc#PIE}. TODO  cleanup types
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.Arc.prototype.Init = function(context, cx, cy, rx, ry, startAngle, angleExtent, closureType, id) {
  dvt.Arc.superclass.Init.call(this, context, 'path', id);

  this._sa = 0;// TODO  cleanup
  this._ae = 0;

  ry = ((ry === null || isNaN(ry)) ? rx : ry);

  this._bInInit = true;// performance - avoid multiple createArc()'s
  this.setCx(cx);
  this.setCy(cy);
  this.setRx(rx);
  this.setRy(ry);
  this.setAngleStart(startAngle);
  this.setAngleExtent(angleExtent);
  this.setClosure(closureType ? closureType : dvt.Arc.OPEN);
  this._bInInit = false;// finally allow createArc to work.
  this._createArc();
};


/** @private */
dvt.Arc.prototype._addClosure = function(p) {
  if (this._ct === dvt.Arc.CHORD) {
    p += ' z';
  }
  else if (this._ct === dvt.Arc.PIE) {
    p += ' L ' + this._cx + ',' + this._cy + ' z';
  }
  else if (this._ct === dvt.Arc.OPEN) {
    this.setFill(null);
  }

  return p;
};


/**
 * @private
 */
dvt.Arc.prototype._createArc = function() {
  if (this._bInInit) {
    // don't need to do this until end of Init()
    return;
  }

  var sa = (this._sa * dvt.Math.RADS_PER_DEGREE);
  var ae = (this._ae * dvt.Math.RADS_PER_DEGREE);

  var x1 = this._cx + (this._rx * Math.cos(sa));// get arc
  var y1 = this._cy - (this._ry * Math.sin(sa));// end points
  var x2 = this._cx + (this._rx * Math.cos(sa + ae));
  var y2 = this._cy - (this._ry * Math.sin(sa + ae));

  var nLargeArc = (Math.abs(this._ae) > 180) ? '1' : '0';
  var nSweepFlag = (this._ae > 0) ? '0' : '1';// 0 == svg +ve angle
  var path = 'M ' + dvt.ToolkitUtils.roundDecimal(x1) + ' ' + dvt.ToolkitUtils.roundDecimal(y1) + ' A ' +
      dvt.ToolkitUtils.roundDecimal(this._rx) + ',' + dvt.ToolkitUtils.roundDecimal(this._ry) + ' ' + '0' + ' ' +
              nLargeArc + ',' + nSweepFlag + ' ' + dvt.ToolkitUtils.roundDecimal(x2) + ',' + dvt.ToolkitUtils.roundDecimal(y2);
  path = this._addClosure(path);

  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'd', path);
  if (this._stroke !== null) {
    this.setStroke(this._stroke);
  }
};


/**
 * Returns the angle subtended by the arc.
 * @return {number}  The angle subtended by the arc (following the normal anti-clockwise
 * is positive convention).
 */
dvt.Arc.prototype.getAngleExtent = function() {
  return this._ae;
};


/**
 * Returns the angle subtended by the arc.
 * @return {number}  The angle subtended by the arc.
 * is positive convention).
 */
dvt.Arc.prototype.setAngleExtent = function(ae) {
  ae = ((ae === null || isNaN(ae)) ? 0 : ae);
  if (this._ae !== ae) {

    //  From https://developer.mozilla.org/en/SVG/Tutorial/Paths
    //  "Complete circles and ellipses are actually the one object paths have trouble drawing.
    //  Because the start and end points for any path going around a circle are the same, there
    //  are an infinite number of circles that could be chosen, and the actual path is undefined.
    //  It's possible to approximate them by making the start and end points of your path slightly askew"
    if (ae === 360) {
      // 
      ae = 359.99;// cannnot use any precision higher than this!
    }

    this._ae = ae;
    this._createArc();
    this.UpdateSelectionEffect();
  }
};


/**
 * Returns the start angle for an arc.
 * @return {number}  The starting angle (following the normal anti-clockwise
 * is positive convention).
 */
dvt.Arc.prototype.getAngleStart = function() {
  return this._sa;
};


/**
 * Sets the start angle of the arc.
 * @param {number}  The starting angle (following the normal anti-clockwise
 * is positive convention).
 */
dvt.Arc.prototype.setAngleStart = function(sa) {
  sa = ((sa === null || isNaN(sa)) ? 0 : sa);
  if (this._sa !== sa) {
    this._sa = sa;
    this._createArc();
    this.UpdateSelectionEffect();
  }
};


/**
 *    Returns the closure type of the arc.
 *    @type {String}
 *    @return The closure type,  such as {@link dvt.Arc#OPEN}
 */
dvt.Arc.prototype.getClosure = function() {
  return this._ct;
};


/**
 * Sets the closure type of the arc.
 * @param {String} ct   The closure type,  such as {@link dvt.Arc#OPEN}
 */
dvt.Arc.prototype.setClosure = function(ct) {
  if (ct !== this._ct) {
    this._ct = ct;
    this._createArc();
    this.UpdateSelectionEffect();
  }
};


/**
 * Returns the x coordinate of the center.
 * @type {number}
 */
dvt.Arc.prototype.getCx = function() {
  return this._cx;
};


/**
 * Sets the x coordinate of the center.
 * @param {number} cx  The center x position.
 */
dvt.Arc.prototype.setCx = function(cx) {  // TODO  not a valid SVG attribute
  if (cx !== this._cx) {
    this._cx = cx;
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'cx', cx);
    this.UpdateSelectionEffect();
  }
};


/**
 * Returns the y coordinate of the center.
 * @type {number}
 */
dvt.Arc.prototype.getCy = function() {
  return this._cy;
};


/**
 * Sets the y coordinate of the center.
 * @param {number} cy  The center y position.
 *
 */
dvt.Arc.prototype.setCy = function(cy) {  // TODO  not a valid SVG attribute
  if (cy !== this._cy) {
    this._cy = cy;
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'cy', cy);
    this.UpdateSelectionEffect();
  }
};


/**
 * Returns the horizontal radius of the ellipse.
 * @type {number}
 */
dvt.Arc.prototype.getRx = function() {
  return this._rx;
};


/**
 * Sets the horizontal radii of the ellipse.
 * @param {number} rx  The horizontal radius of the ellipse.
 */
dvt.Arc.prototype.setRx = function(rx) {  // TODO  not a valid SVG attribute
  if (rx !== this._rx) {
    this._rx = rx;
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'rx', this._rx);
    this._createArc();
    this.UpdateSelectionEffect();
  }
};


/**
 * Returns the vertical radius of the ellipse.
 * @type {number}
 */
dvt.Arc.prototype.getRy = function() {
  return this._ry;
};


/**
 * Sets the vertical radius of the ellipse.
 * @param {number} ry  The vertical radius of the ellipse.
 */
dvt.Arc.prototype.setRy = function(ry) {  // TODO  not a valid SVG attribute
  if (ry !== this._ry) {
    this._ry = ry;
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'ry', this._ry);
    this._createArc();
    this.UpdateSelectionEffect();
  }
};


/**
 * Defines the position and extent of the arc.
 * @param {number} sa  The starting angle in degrees (following the normal
 * anti-clockwise is positive convention).
 * @param {number} ae  The angle extent in degrees (following the normal
 * anti-clockwise is positive convention).
 */
dvt.Arc.prototype.setArc = function(sa, ae) { // TODO  check usages
  this.setAngleStart(sa);
  this.setAngleExtentStart(ae);
};


/**
 * Sets both the horizontal and vertical radii of the ellipse/circle.
 * @param {number} rx  The horizontal radius of the ellipse.
 * @param {number} ry  The vertical radius of the ellipse.
 */
dvt.Arc.prototype.setRadius = function(rx, ry) { // TODO  check usages
  this.setRx(rx);
  this.setRy(ry);
};


/**
 * @override
 */
dvt.Arc.prototype.copyShape = function() {
  return new dvt.Arc(this.getCtx(), this.getCx(), this.getCy(), this.getRx(), this.getRy(), this.getAngleStart(), this.getAngleExtent(), this.getClosure());
};

/**
 * @override
 */
dvt.Arc.prototype.GetAriaElem = function() {
  if (dvt.Agent.isTouchDevice())
    this.CreateChildGroupElem(false, true);
  return dvt.Arc.superclass.GetAriaElem.call(this);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Circle displayable.
 * @param {dvt.Context} context
 * @param {number} cx The x coordinate of the center of the circle.
 * @param {number} cy The y coordinate of the center of the circle.
 * @param {number} r The radius of the circle.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {DvtCircularShape}
 * @class
 * @constructor
 */
dvt.Circle = function(context, cx, cy, r, id) {
  this.Init(context, cx, cy, r, id);
};

dvt.Obj.createSubclass(dvt.Circle, DvtCircularShape);


/**
 * @param {dvt.Context} context
 * @param {number} cx The x coordinate of the center of the circle.
 * @param {number} cy The y coordinate of the center of the circle.
 * @param {number} r The radius of the circle.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.Circle.prototype.Init = function(context, cx, cy, r, id) {
  dvt.Circle.superclass.Init.call(this, context, 'circle', cx, cy, id);
  this.setRadius(r);
};


/**
 * Returns the radius of the circle.
 * @return {number}
 */
dvt.Circle.prototype.getRadius = function() {
  return this.GetProperty('r');
};


/**
 * Specifies the radius of the circle.
 * @param {number} r
 * @return {dvt.Circle}
 */
dvt.Circle.prototype.setRadius = function(r) {
  return this.SetSvgProperty('r', r);
};


/**
 * @override
 */
dvt.Circle.prototype.copyShape = function() {
  return new dvt.Circle(this.getCtx(), this.getCx(), this.getCy(), this.getRadius());
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.Circle.prototype.getDimensionsSelf = function(targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new dvt.Rectangle(this.getCx() - this.getRadius(), this.getCy() - this.getRadius(), this.getRadius() * 2, this.getRadius() * 2);
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Image displayable.
 * @param {dvt.Context} context
 * @param {string} src The url for the image
 * @param {number} x The top left x-coordinate of the image
 * @param {number} y The top left y-coordinate of the image
 * @param {number} w The image width
 * @param {number} h The image height
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {dvt.Shape}
 * @class
 * @constructor
 */
dvt.Image = function(context, src, x, y, w, h, id) {
  this.Init(context, src, x, y, w, h, id);
};

dvt.Obj.createSubclass(dvt.Image, dvt.Shape);// TODO  this should extend displayable

dvt.Image.XLINK_NS = 'http://www.w3.org/1999/xlink';


/**
 * Helper method called by the constructor for initializing this object
 * @param {string} src The url for the image
 * @param {number} x The top left x-coordinate of the image
 * @param {number} y The top left y-coordinate of the image
 * @param {number} w The image width
 * @param {number} h The image height
 * @param {string} id The identifier for the image
 * @private
 */
dvt.Image.prototype.Init = function(context, src, x, y, w, h, id) {
  dvt.Image.superclass.Init.call(this, context, 'image', id);
  // IE doesn't allow interactivity unless there's a fill
  if (dvt.Agent.isPlatformIE()) {
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill', '#FFFFFF');
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', '0');
  }
  this.setImage(src, x, y, w, h);

  // By default, hide images from VoiceOver
  this.setAriaProperty('hidden', 'true');
};


/**
 * Returns the x coordinate of the image.
 * @return {number}
 */
dvt.Image.prototype.getX = function() {
  return this.GetProperty('x');
};


/**
 * Specifies the x coordinate of the image.
 * @param {number} x
 * @return {dvt.Image}
 */
dvt.Image.prototype.setX = function(x) {
  return this.SetSvgProperty('x', x);
};


/**
 * Returns the y coordinate of the image.
 * @return {number}
 */
dvt.Image.prototype.getY = function() {
  return this.GetProperty('y');
};


/**
 * Specifies the y coordinate of the image.
 * @param {number} y
 * @return {dvt.Image}
 */
dvt.Image.prototype.setY = function(y) {
  return this.SetSvgProperty('y', y);
};


/**
 * Returns the width of the image.
 * @return {number}
 */
dvt.Image.prototype.getWidth = function() {
  return this.GetProperty('width');
};


/**
 * Specifies the width of the image.
 * @param {number} w The width of the image.
 * @return {dvt.Image}
 */
dvt.Image.prototype.setWidth = function(w) {
  return this.SetSvgProperty('width', w);
};


/**
 * Returns the height of the image.
 * @return {number}
 */
dvt.Image.prototype.getHeight = function() {
  return this.GetProperty('height');
};


/**
 * Specifies the height of the image.
 * @param {number} h The height of the image.
 * @return {dvt.Image}
 */
dvt.Image.prototype.setHeight = function(h) {
  return this.SetSvgProperty('height', h);
};


/**
 * Returns the src of the image.
 * @return (String) the src of the image.
 */
dvt.Image.prototype.getSrc = function() {
  return this._src;
};


/**
 * Sets the src of the image.
 * @param {String} src  The src of the image.
 * @return {dvt.Image} self dvt.Image object
 */
dvt.Image.prototype.setSrc = function(src) {
  if (src !== this._src) {
    var uri = src;
    this._src = src;
    if (dvt.Agent.isEnvironmentBatik()) {
      var imageInfo = dvt.JavaImageLoader.getImageInfo(src);
      if (imageInfo) {
        uri = imageInfo.uri;
      }
    }

    dvt.ToolkitUtils.setAttrNS(this._elem, dvt.Image.XLINK_NS, 'xlink:href', uri);
  }

  // Return self for linking setters
  return this;
};

dvt.Image.prototype.getPos = function() { // TODO  CLEANUP
  return new dvt.Point(this._x, this._y);
};

dvt.Image.prototype.setPos = function(x, y) { // TODO  CLEANUP
  this.setX(x).setY(y);
};


/**
 *     Sets the position and size and src of the image
 *     Maybe specified as individual values or using a dvt.Image object.
 *
 *   e.g. Image = factory.newImage('pic'png', 10, 10, 50, 100);  or
 *
 *        Image = factory.newImage(myImage);   where myImage = new dvt.Image('pic.png', 10, 10, 50, 100);
 */
dvt.Image.prototype.setImage = function(src, x, y, w, h) { // TODO  CLEANUP
  if (x instanceof dvt.Image) {
    this.setSrc(src.src);
    this.setPos(src.x, src.y);
    this.setWidth(src.w);
    this.setHeight(src.h);
  }
  else {
    this.setSrc(src);
    this.setPos(x, y);
    this.setWidth(w);
    this.setHeight(h);
  }

  //TODO: set preserveAspectRatio="none" for now
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'preserveAspectRatio', 'none');
};


/**
 * @override
 */
dvt.Image.prototype.getDimensions = function(targetCoordinateSpace) {
  // Optimized implementation that allows container geometry to be taken into account to avoid costly DOM calls
  if (this.getDimensionsSelf && (this.getNumChildren() - this._getInnerShapeCount() == 0))
    return this.getDimensionsSelf(targetCoordinateSpace);
  else {
    var bbox = this.getElem().getBBox();
    if (bbox.width && bbox.height)
      bbox = new dvt.Rectangle(bbox.x, bbox.y, bbox.width, bbox.height);
    else
      bbox = new dvt.Rectangle(bbox.x, bbox.y, this.getWidth(), this.getHeight());

    return this.ConvertCoordSpaceRect(bbox, targetCoordinateSpace);
  }
};


/**
 * Convenience method for setting the width and height of the image.
 * @param {object} dims An object with width and height properties.
 */
dvt.Image.prototype.__setDimensions = function(dims) {
  this.setWidth(dims.width);
  this.setHeight(dims.height);
};


/**
 * @override
 */
dvt.Image.prototype.UpdateSelectionEffect = function() {
  // noop: Does not participate in selection effects
};


/**
 * @override
 */
dvt.Image.prototype.copyShape = function() {
  return new dvt.Image(this.getCtx(), this.getSrc(), this.getX(), this.getY(), this.getWidth(), this.getHeight());
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.Image.prototype.getDimensionsSelf = function(targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new dvt.Rectangle(this.getX(), this.getY(), this.getWidth(), this.getHeight());
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};

/**
 * @override
 */
dvt.Image.prototype.setAriaProperty = function(property, value) {
  dvt.Image.superclass.setAriaProperty.call(this, property, value);
  if (property != 'hidden')
    dvt.Image.superclass.setAriaProperty.call(this, 'hidden', null);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Line displayable.
 * @param {dvt.Context} context
 * @param {number} x1 The x coordinate of the first point.
 * @param {number} y1 The y coordinate of the first point.
 * @param {number} x2 The x coordinate of the second point.
 * @param {number} y2 The y coordinate of the second point.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {dvt.Shape}
 * @class
 * @constructor
 */
dvt.Line = function(context, x1, y1, x2, y2, id) {
  this.Init(context, x1, y1, x2, y2, id);
};

dvt.Obj.createSubclass(dvt.Line, dvt.Shape);


/**
 * @param {dvt.Context} context
 * @param {number} x1 The x coordinate of the first point.
 * @param {number} y1 The y coordinate of the first point.
 * @param {number} x2 The x coordinate of the second point.
 * @param {number} y2 The y coordinate of the second point.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.Line.prototype.Init = function(context, x1, y1, x2, y2, id) {
  dvt.Line.superclass.Init.call(this, context, 'line', id);

  this.setX1(x1).setY1(y1).setX2(x2).setY2(y2);
  this._bHollow = false; // TODO  CLEANUP: The whole bHollow thing is pretty strange.
};


/**
 * Returns the x coordinate of the first point.
 * @return {number}
 */
dvt.Line.prototype.getX1 = function() {
  return this.GetProperty('x1');
};


/**
 * Specifies the x coordinate of the first point.
 * @param {number} x1
 * @return {dvt.Line}
 */
dvt.Line.prototype.setX1 = function(x1) {
  return this.SetSvgProperty('x1', x1, 0);
};


/**
 * Returns the y coordinate of the first point.
 * @return {number}
 */
dvt.Line.prototype.getY1 = function() {
  return this.GetProperty('y1');
};


/**
 * Specifies the y coordinate of the first point.
 * @param {number} y1
 * @return {dvt.Line}
 */
dvt.Line.prototype.setY1 = function(y1) {
  return this.SetSvgProperty('y1', y1, 0);
};


/**
 * Returns the x coordinate of the second point.
 * @return {number}
 */
dvt.Line.prototype.getX2 = function() {
  return this.GetProperty('x2');
};


/**
 * Specifies the x coordinate of the second point.
 * @param {number} x2
 * @return {dvt.Line}
 */
dvt.Line.prototype.setX2 = function(x2) {
  return this.SetSvgProperty('x2', x2, 0);
};


/**
 * Returns the y coordinate of the second point.
 * @return {number}
 */
dvt.Line.prototype.getY2 = function() {
  return this.GetProperty('y2');
};


/**
 * Specifies the y coordinate of the second point.
 * @param {number} y2
 * @return {dvt.Line}
 */
dvt.Line.prototype.setY2 = function(y2) {
  return this.SetSvgProperty('y2', y2, 0);
};


/**
 * Changes the shape to an outline shape format.  Used for legend that represent a hidden state.
 * @override
 */
dvt.Line.prototype.setHollow = function() {
  var parentElem = this._elem.parentNode;

  if (!this._bHollow) {
    this._origElem = this._elem;
    var hollowMarker;
    var width = this.getX2() - this.getX1();// Legend lines are always horizontal, so take width as height
    var height = width;
    var startY = this.getY1() - width / 2;
    var stroke = this.getStroke();

    hollowMarker = dvt.SvgShapeUtils.createElement('rect');
    dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'x', this.getX1());
    dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'y', startY);
    dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'width', this.getX2() - this.getX1());
    dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'height', height);
    var color = stroke.getColor();
    if (color) {
      var alpha = stroke.getAlpha();
      // Workaround for Safari where versions < 5.1 draw rgba values as black
      if (dvt.Agent.isBrowserSafari() && color.indexOf('rgba') !== - 1) {
        dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'stroke', dvt.ColorUtils.getRGB(color));
        // Use alpa in rgba value as a multiplier to the alpha set on the object as this is what svg does.
        if (alpha != null)
          dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'stroke-opacity', dvt.ColorUtils.getAlpha(color) * alpha);
        else
          dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'stroke-opacity', dvt.ColorUtils.getAlpha(color));
      }
      else {
        dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'stroke', color);
        if (alpha != null)
          dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'stroke-opacity', alpha);
      }
    }
    dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'fill', '#ffffff');
    dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'fill-opacity', '0.001');// need this or hit detection fails on center
    dvt.ToolkitUtils.setAttrNullNS(hollowMarker, 'shape-rendering', 'crispEdges');
    hollowMarker._obj = this;// replace the elem's _obj backpointer
    parentElem.replaceChild(hollowMarker, this._elem);
    this._elem = hollowMarker;
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'opacity', this._alpha);
    this._bHollow = true;
  }
  else if (this._origElem) {
    parentElem.replaceChild(this._origElem, this._elem);
    dvt.ToolkitUtils.setAttrNullNS(this._origElem, 'opacity', this._alpha);
    this._elem = this._origElem;
    this._origElem = null;
    this._bHollow = false;
  }
};


/**
 * @override
 */
dvt.Line.prototype.getDimensions = function(targetCoordinateSpace) {
  // TODO  CLEANUP: It seems like this can just call getDimensionsSelf
  var bounds = dvt.Line.superclass.getDimensions.call(this, targetCoordinateSpace);
  // : Vertical/horizontal lines in svg are ignored when group containers wrap them
  if (this._childGroupElem && this._elem) {
    var groupBox = this._childGroupElem.getBBox();
    // Empty bounding box is an indication of only vertical/horizontal lines present in this group
    // In this case, use the original line itself to get the bounds as an approximation
    if (groupBox.x == 0 && groupBox.y == 0 && groupBox.width == 0 && groupBox.height == 0) {
      var lineBounds = this._elem.getBBox();
      bounds = new dvt.Rectangle(lineBounds.x, lineBounds.y, lineBounds.width, lineBounds.height);
    }
  }
  return bounds;
};


/**
 * @override
 */
dvt.Line.prototype.copyShape = function() {
  return new dvt.Line(this.getCtx(), this.getX1(), this.getY1(), this.getX2(), this.getY2());
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.Line.prototype.getDimensionsSelf = function(targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var x = Math.min(this.getX1(), this.getX2());
  var y = Math.min(this.getY1(), this.getY2());
  var w = Math.abs(this.getX1() - this.getX2());
  var h = Math.abs(this.getY1() - this.getY2());

  var bounds = new dvt.Rectangle(x, y, w, h);
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  *  A marker object for lines, scatter and bubble charts and legend areas.
  *  @param {dvt.Context} context
  *  @param {Object} type An string representing the type of the marker (see {@link dvt.Marker}),
  *                       a string URI for the shape path for a custom svg marker,
  *                       or an array of image URIs for each of the 4 marker states (active, hover, selected, hoverSelected).
  *  @param {number} x  The x position of the top left corner of the marker.
  *  @param {number} y  The y position of the top left corner of the marker.
  *  @param {number} w  The width of the marker.
  *  @param {number} h  The height of the marker.
  *  @param {number} sx  Optional The horizontal scale factor of the marker.
  *  @param {number} sy  Optional The vertical scale factor of the marker.
  *  @param {String} id  Optional ID for the shape (see {@link  dvt.Displayable#setId}).
  *  @param {boolean} maintainAspect Optional Indicates whether aspect ratio should be maintained (false is not specified)
  *  @class dvt.Marker A marker object for lines, scatter and bubble charts and legend areas.
  *  @extends {dvt.Shape}
  *  @constructor
  */
dvt.Marker = function(context, type, skin, x, y, w, h, id, sx, sy, maintainAspect) {
  this.Init(context, type, skin, x, y, w, h, id, sx, sy, maintainAspect);
};

dvt.Obj.createSubclass(dvt.Marker, dvt.Shape);


// TODO : This class is a mess after collapsing the toolkit, but that reflects its state before the collapse.  We
// should refactor the code for creating a marker shape into a separate, simple marker class.
/**
 * No marker shape defined.
 */
dvt.Marker.NONE = 'none';


/**
 * A circular marker.
 */
dvt.Marker.CIRCLE = 'circle';


/**
 * A square marker.
 */
dvt.Marker.SQUARE = 'square';


/**
 * A diamond shaped marker.
 */
dvt.Marker.DIAMOND = 'diamond';


/**
 * A triangular shaped marker with a vertex at the top.
 */
dvt.Marker.TRIANGLE_UP = 'triangleUp';


/**
 * A triangular shaped marker with a vertex at the bottom.
 */
dvt.Marker.TRIANGLE_DOWN = 'triangleDown';


/**
 * A plus-shaped marker.
 */
dvt.Marker.PLUS = 'plus';


/**
 * A human figure shaped marker.
 */
dvt.Marker.HUMAN = 'human';


/**
 * A rectangular marker with rounded corners.
 */
dvt.Marker.ROUNDED_RECTANGLE = 'roundedRect';


/**
 * A custom svg shaped marker.
 */
dvt.Marker.CUSTOM = 'custom';


/**
 * An image marker.
 */
dvt.Marker.IMAGE = 'image';


/**
 * @protected
 */
dvt.Marker.SELECTION_STROKE_COLOR = '#000000';


/**
 * @protected
 */
dvt.Marker.SELECTION_STROKE_ALPHA = 1;

// Array indicies if an array of image URIs are passed in type parameter
dvt.Marker.IMAGE_SOURCE = 0;
dvt.Marker.IMAGE_SOURCE_SELECTED = 1;
dvt.Marker.IMAGE_SOURCE_HOVER = 2;
dvt.Marker.IMAGE_SOURCE_HOVER_SELECTED = 3;

// The reference coords and sizes that the shapes will be initialized to.
dvt.Marker._REFERENCE_X = 0;
dvt.Marker._REFERENCE_Y = 0;
dvt.Marker._REFERENCE_W = 10;
dvt.Marker._REFERENCE_H = 10;

dvt.Marker.MARKER_CIRCLE_ELEM_NAME = 'circle';
dvt.Marker.MARKER_ELLIPSE_ELEM_NAME = 'ellipse';
dvt.Marker.MARKER_LINE_ELEM_NAME = 'line';
dvt.Marker.MARKER_PATH_ELEM_NAME = 'path';
dvt.Marker.MARKER_POLYGON_ELEM_NAME = 'polygon';
dvt.Marker.MARKER_POLYLINE_ELEM_NAME = 'polyline';
dvt.Marker.MARKER_RECT_ELEM_NAME = 'rect';


/**
 *  Object initializer.
 *  @protected
 */
dvt.Marker.prototype.Init = function(context, type, skin, x, y, w, h, id, sx, sy, maintainAspect) {
  //: save initial parameters in case we want to create
  //a copy of this marker
  this._skin = skin;
  this._xx = x;
  this._yy = y;
  this._ww = w;
  this._hh = h;
  this._sx = sx ? sx : 1;
  this._sy = sy ? sy : 1;
  this._maintainAspect = maintainAspect;
  this._initType = type;

  var etype;
  var markerDef;

  if (type instanceof Array) {
    this._setMarkerImageStates(type);
    type = dvt.Marker.IMAGE;
  }
  else {
    if (!dvt.Marker.isBuiltInShape(type)) {
      markerDef = dvt.MarkerUtils.getCustomMarkerInfo(context, type);
      if (markerDef) {
        // Custom marker is always dvt.Path or dvt.Container containing a collection of DvtPaths
        etype = (markerDef instanceof dvt.Path ? 'path' : 'g');
        if (!w || !h) {
          var dim = dvt.DisplayableUtils.getDimForced(context, markerDef);
          w = w ? w : dim.w;
          h = h ? h : dim.h;
          this._ww = w;
          this._hh = h;
        }
        type = dvt.Marker.CUSTOM;
      }
      else {
        // no markerDef found, default to rect
        type = dvt.Marker.SQUARE;
      }
    }
    else {
      type = dvt.Marker.convertShapeString(type);
    }
  }

  // Create the impl shape
  var elemType;
  if (etype) {
    elemType = etype;
  }
  else {
    elemType = (type === dvt.Marker.CIRCLE ? 'ellipse' : (type === dvt.Marker.SQUARE ? 'rect' : (type === dvt.Marker.ROUNDED_RECTANGLE ? 'rect' : (type === dvt.Marker.TRIANGLE_UP ? 'polygon' : (type === dvt.Marker.TRIANGLE_DOWN ? 'polygon' : (type === dvt.Marker.DIAMOND ? 'polygon' : (type === dvt.Marker.PLUS ? 'polygon' : (type === dvt.Marker.HUMAN ? 'path' : (type === dvt.Marker.IMAGE ? 'image' : 'rect')))))))));
  }
  dvt.Marker.superclass.Init.call(this, context, elemType, id);

  // Store the type
  this._type = type;

  //default scale of the marker used to force it to the reference size
  this._defaultScale = 1;

  if (type === dvt.Marker.HUMAN) {
    markerDef = dvt.MarkerUtils.getBuiltinMarkerInfo(context, 'human', this.getSkin());
  }

  // Update the width and height with the scale factors
  var ww = this.getScaledWidth();
  var hh = this.getScaledHeight();
  this._size = Math.max(ww, hh);

  // Position and size the marker
  this.setBounds(x, y, ww, hh, markerDef);

  // Store other params
  this._dataColor = '#000000';

  //properties related to selection
  this._savedStroke = null;
  this._savedFill = null;
  this._bSavedStroke = false;
  this._bSavedFill = false;
  this._selStrokeWidth = null;
  this._selStrokeColor = null;
  this._selStrokeAlpha = null;
};


/**
 *  Returns the greater of the width and height measurement.
 *  @return {number} the size of the marker.
 */
dvt.Marker.prototype.getSize = function() {
  return this._size;
};


/**
 *  Returns the type of the marker that was passed into the constructor.
 *  The type can be a string indicating a built-in marker type, an array of image paths,
 *  or a single path for custom svg marker.
 *  @return {Object} the type of the marker
 */
dvt.Marker.prototype.getInitType = function() {
  return this._initType;
};


/**
 * Sets the position and size of the marker.
 * @param {number} x The top left x-coordinate of the marker's bounding rectangle.
 * @param {number} y The top left y-coordinate of the marker's bounding rectangle.
 * @param {number} w The width of the marker's bounding rectangle.
 * @param {number} h The height of the marker's bounding rectangle.
 * @param {dvt.MarkerDef} markerDef
 */
dvt.Marker.prototype.setBounds = function(x, y, w, h, markerDef) {
  // Initialize the shape to the reference coords
  if (!this._shapeInitialized)
    this.InitShape(this._type, markerDef, x, y, w, h);
};


/**
 * Initializes the shape to the specified coordinates.
 * @param {string} type The marker type
 * @param {dvt.MarkerDef} markerDef The marker definition used for custom markers generated on the server
 * @param {number} x The top left x-coordinate of the marker's bounding rectangle.
 * @param {number} y The top left y-coordinate of the marker's bounding rectangle.
 * @param {number} w The width of the marker's bounding rectangle.
 * @param {number} h The height of the marker's bounding rectangle.
 * @private
 */
dvt.Marker.prototype.InitShape = function(type, markerDef, x, y, w, h) {
  // Only need to do this once
  this._shapeInitialized = true;

  // Save info for underlay positioning
  this._x = x;
  this._y = y;
  this._w = w;
  this._h = h;

  var multiPathRoot;
  if (type === dvt.Marker.CUSTOM || type === dvt.Marker.HUMAN) {
    // Calculate the scale factor to get to the right size
    var dim = dvt.DisplayableUtils.getDimForced(this.getCtx(), markerDef);
    var maxDim = Math.max(dim.w, dim.h);

    var sx = 1;
    var sy = 1;

    // Calculate the transform to get to the right position
    if (type === dvt.Marker.CUSTOM) {
      sx = w / (this.getMaintainAspect() ? maxDim : dim.w);
      sy = h / (this.getMaintainAspect() ? maxDim : dim.h);
      var dx = x + (- dim.x * sx) + (w - (dim.w * sx)) / 2;
      var dy = y + (- dim.y * sy) + (h - (dim.h * sy)) / 2;
      multiPathRoot = this._setCustomMarker(markerDef, dx, dy, sx, sy);
    }
    else if (type === dvt.Marker.HUMAN) {
      sx = w / maxDim;
      sy = h / maxDim;
      var dx = x + (- dim.x * sx) + (w - (dim.w * sx)) / 2;
      var dy = y + (- dim.y * sy) + (h - (dim.h * sy)) / 2;
      var humanCmds = dvt.CSSStyle.afterSkinAlta(this.getSkin()) ? dvt.MarkerDef.HUMAN2_CMDS : dvt.MarkerDef.HUMAN_CMDS;
      this._setCmds(dvt.PathUtils.transformPath(humanCmds, dx, dy, sx, sy));
    }
    var scale = (dim.h === maxDim) ? (h / maxDim) : (w / maxDim);
    //save the default scale used to force the marker to the reference size
    //because we may need it later for inversely scaling the selection stroke
    this._defaultScale = scale;
  }
  else if (type === dvt.Marker.IMAGE) {
    var src = this.GetMarkerImage(dvt.Marker.IMAGE_SOURCE);
    this._setX(x);
    this._setY(y);
    this._setWidth(w);
    this._setHeight(h);
    this.setSource(src);
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'preserveAspectRatio', 'none');
    // IE doesn't allow interactivity unless there's a fill
    if (dvt.Agent.isPlatformIE()) {
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill', '#FFFFFF');
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', '0');
    }
  }
  else if (type === dvt.Marker.SQUARE) {
    this._setX(x);
    this._setY(y);
    this._setWidth(w);
    this._setHeight(h);
  }
  else if (type === dvt.Marker.ROUNDED_RECTANGLE) {
    this._setX(x);
    this._setY(y);
    this._setWidth(w);
    this._setHeight(h);
    var rx = 6;
    var ry = 6;
    if (w / 4 < rx || h / 4 < ry) {
      rx = Math.min(w, h) / 4;
      ry = rx;
    }
    this._setRX(rx);
    this._setRY(ry);
  }
  else if (type === dvt.Marker.CIRCLE) {
    this._setCx(x + w / 2);
    this._setCy(y + h / 2);
    this._setRX(w / 2);
    this._setRY(h / 2);
  }
  else {
    var ar = [];
    var halfWidth = w / 2;
    var halfHeight = h / 2;

    if (type === dvt.Marker.TRIANGLE_UP) {
      ar.push(x);
      ar.push(y + h);
      ar.push(x + w);
      ar.push(y + h);
      ar.push(x + halfWidth);
      ar.push(y);
      this._setPolygon(ar);
    }
    else if (type === dvt.Marker.TRIANGLE_DOWN) {
      ar.push(x);
      ar.push(y);
      ar.push(x + w);
      ar.push(y);
      ar.push(x + halfWidth);
      ar.push(y + h);
      this._setPolygon(ar);
    }
    else if (type === dvt.Marker.DIAMOND) {
      ar.push(x + halfWidth);
      ar.push(y);
      ar.push(x + w);
      ar.push(y + halfHeight);
      ar.push(x + halfWidth);
      ar.push(y + h);
      ar.push(x);
      ar.push(y + halfHeight);
      this._setPolygon(ar);
    }
    else if (type === dvt.Marker.PLUS) {
      var wThird = w / 3;
      var wTwoThird = 2 * wThird;
      var hThird = h / 3;
      var hTwoThird = 2 * hThird;

      ar.push(x + wThird);
      ar.push(y);
      ar.push(x + wTwoThird);
      ar.push(y);
      ar.push(x + wTwoThird);
      ar.push(y + hThird);
      ar.push(x + w);
      ar.push(y + hThird);
      ar.push(x + w);
      ar.push(y + hTwoThird);
      ar.push(x + wTwoThird);
      ar.push(y + hTwoThird);
      ar.push(x + wTwoThird);
      ar.push(y + h);
      ar.push(x + wThird);
      ar.push(y + h);
      ar.push(x + wThird);
      ar.push(y + hTwoThird);
      ar.push(x);
      ar.push(y + hTwoThird);
      ar.push(x);
      ar.push(y + hThird);
      ar.push(x + wThird);
      ar.push(y + hThird);
      ar.push(x + wThird);
      ar.push(y);
      this._setPolygon(ar);
    }
  }
};


/**
 *  Returns the default scale of the marker used to force it to the
 *  reference size.
 *  @type {number}
 */
dvt.Marker.prototype.getDefaultScale = function() {
  return this._defaultScale;
};


/**
 *  Returns the skin of the marker.
 *  @return {String} the skin name
 */
dvt.Marker.prototype.getSkin = function() {
  return this._skin;
};


/**
 *  Returns the x-coord of the marker.
 *  @return {number} the x-coord of the marker
 */
dvt.Marker.prototype.getX = function() {
  return this._xx;
};


/**
 *  Returns the y-coord of the marker.
 *  @return {number} the y-coord of the marker
 */
dvt.Marker.prototype.getY = function() {
  return this._yy;
};


/**
 *  Returns the width of the marker, before any scale is applied.
 *  @return {number} the width of the marker
 */
dvt.Marker.prototype.getWidth = function() {
  return this._ww;
};


/**
 *  Returns the height of the marker, before any scale is applied.
 *  @return {number} the height of the marker
 */
dvt.Marker.prototype.getHeight = function() {
  return this._hh;
};


/**
 *  Returns the width of the marker, after any scale is applied.
 *  @return {number} the scaled width of the marker
 */
dvt.Marker.prototype.getScaledWidth = function() {
  return this._sx ? this._ww * this._sx : this._ww;
};


/**
 *  Returns the height of the marker, after any scale is applied.
 *  @return {number} the scaled height of the marker
 */
dvt.Marker.prototype.getScaledHeight = function() {
  return this._sy ? this._hh * this._sy : this._hh;
};


/**
 *  Returns the type of the marker (such as {@link dvt.Marker#CIRCLE}.
 *  @type {number}
 */
dvt.Marker.prototype.getType = function() {
  return this._type;
};


/**
 *  Returns the horizontal scale of the marker.
 *  @return {number} the horizontal scale of the marker
 */
dvt.Marker.prototype.getSx = function() {
  return this._sx;
};


/**
 *  Returns the vertical scale of the marker.
 *  @return {number} the vertical scale of the marker
 */
dvt.Marker.prototype.getSy = function() {
  return this._sy;
};


/**
 *  Returns whether aspect ratio should be maintained.
 *  @return {boolean} whether aspect ratio should be maintained
 */
dvt.Marker.prototype.getMaintainAspect = function() {
  return this._maintainAspect == true;
};


/**
 * @protected
 */
dvt.Marker.prototype.SetStrokeWidth = function(sw) {
  var stroke = this.getStroke();
  if (stroke) {
    stroke = stroke.clone();
    stroke.setWidth(sw);
    this.setStroke(stroke);
  }
};


/**
 * @protected
 */
dvt.Marker.prototype.GetStrokeWidth = function() {
  var stroke = this.getStroke();
  if (stroke) {
    return stroke.getWidth();
  }
  return 0;
};


/**
 * @override
 */
dvt.Marker.prototype.showHoverEffect = function() {
  if (this.getType() === dvt.Marker.IMAGE) {
    this.IsShowingHoverEffect = true;
    if (this.isSelected())
      this.setSource(this.GetMarkerImage(dvt.Marker.IMAGE_SOURCE_HOVER_SELECTED));
    else
      this.setSource(this.GetMarkerImage(dvt.Marker.IMAGE_SOURCE_HOVER));
  }
  else
    dvt.Marker.superclass.showHoverEffect.call(this);
};


/**
 * @override
 */
dvt.Marker.prototype.hideHoverEffect = function() {
  if (this.getType() === dvt.Marker.IMAGE) {
    this.IsShowingHoverEffect = false;
    if (this.isSelected())
      this.setSource(this.GetMarkerImage(dvt.Marker.IMAGE_SOURCE_SELECTED));
    else
      this.setSource(this.GetMarkerImage(dvt.Marker.IMAGE_SOURCE));
  }
  else
    dvt.Marker.superclass.hideHoverEffect.call(this);
};


/**
 * @override
 */
dvt.Marker.prototype.setSelected = function(selected) {
  if (this.IsSelected == selected)
    return;

  if (this.getType() === dvt.Marker.IMAGE) {
    this.IsSelected = selected;
    if (selected) {
      if (this.isHoverEffectShown())
        this.setSource(this.GetMarkerImage(dvt.Marker.IMAGE_SOURCE_HOVER_SELECTED));
      else
        this.setSource(this.GetMarkerImage(dvt.Marker.IMAGE_SOURCE_SELECTED));
    }
    else {
      this.setSource(this.GetMarkerImage(dvt.Marker.IMAGE_SOURCE));
    }
  }
  else
    dvt.Marker.superclass.setSelected.call(this, selected);
};


/**
 * Specifies the color of the data item and its selection feedback, if different from the default.
 * @param {string} dataColor The CSS color string of the primary color of the data item.
 * @param {boolean} bSkipStroke True if the hover and selected stroke creation should be skipped.
 */
dvt.Marker.prototype.setDataColor = function(dataColor, bSkipStroke) {
  this._dataColor = dataColor;
  if (!bSkipStroke) {
    var hoverColor = dvt.ColorUtils.adjustHSL(dataColor, 0, 0, 0.15);
    var sis = new dvt.SolidStroke('#FFFFFF', 1, 1.5);
    this.setHoverStroke(new dvt.SolidStroke(hoverColor, 1, 2));
    this.setSelectedStroke(sis, new dvt.SolidStroke('#5A5A5A', 1, 4.5));
    this.setSelectedHoverStroke(sis, new dvt.SolidStroke(hoverColor, 1, 4.5));
    this.HoverInnerStroke.setFixedWidth(true);
    this.SelectedInnerStroke.setFixedWidth(true);
    this.SelectedOuterStroke.setFixedWidth(true);
    this.SelectedHoverInnerStroke.setFixedWidth(true);
    this.SelectedHoverOuterStroke.setFixedWidth(true);
  }
};


/**
 * Get the data color used as a base for selection colors.
 *
 * @type {string}
 */
dvt.Marker.prototype.getDataColor = function() {
  return this._dataColor;
};


/**
 * Changes the shape to an outline shape format.  Used for legend
 * markers that represent a hidden state for the associated series risers.
 * @param {String} color Border color for hollow shape in format of #aarrggbb
 * @override
 */
dvt.Marker.prototype.setHollow = function(color) {
  //scale the stroke width inversely proportional to the marker scale
  //so that the stroke width appears to be the same for all markers
  var scaleX = this.getScaleX();
  var scaleY = this.getScaleY();
  var scale = Math.min(scaleX, scaleY);
  var strokeWidth = this.GetStrokeWidth();
  strokeWidth = (strokeWidth ? strokeWidth : 1) / scale;

  //save the stroke width so that we can reset it if needed
  dvt.Marker.superclass.setHollow.call(this, color, strokeWidth);
};


/**  Adds reference for legend text to marker
 *  @param {DvtText} text Legend text
 */
dvt.Marker.prototype.setText = function(text) {
  this._markerText = text;
};


/**  Adds reference for legend text to marker
 *  @param {number} alpha Opacity of object
 *  @override
 */
dvt.Marker.prototype.setAlpha = function(alpha) {
  dvt.Marker.superclass.setAlpha.call(this, alpha);
  if (this._markerText)
    this._markerText.setAlpha(alpha);
  this.UpdateSelectionEffect();
};


/**
 * @private
 */
dvt.Marker.prototype._setCx = function(cx) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'cx', cx);
};


/**
 * @private
 */
dvt.Marker.prototype._setCy = function(cy) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'cy', cy);
};


/**
 * @private
 */
dvt.Marker.prototype._setX = function(x) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'x', x);
};


/**
 * @private
 */
dvt.Marker.prototype._setY = function(y) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'y', y);
};


/**
 * @private
 */
dvt.Marker.prototype._setWidth = function(w) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'width', w);
};


/**
 * @private
 */
dvt.Marker.prototype._setHeight = function(h) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'height', h);
};


/**
 * @private
 */
dvt.Marker.prototype._setRadius = function(r) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'r', r);
};


/**
 *   @private
 */
dvt.Marker.prototype._setPolygon = function(ar) {
  var sPoints = dvt.SvgShapeUtils.convertPointsArray(ar);
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'points', sPoints);
};


/**
 *   @private
 */
dvt.Marker.prototype._setCmds = function(cmds) {
  if (cmds !== this._cmds) {
    this._cmds = cmds;
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'd', cmds);
  }
};

dvt.Marker.prototype.UpdateMarkerImage = function(imgSrc) {
  this.setSource(imgSrc);
};


/**
 * Updates the marker image source based on the current selection state
 * @param {string} src The image uri to set for the current marker state
 */
dvt.Marker.prototype.setSource = function(src) {
  if (dvt.Agent.isEnvironmentBatik()) {
    var imageInfo = dvt.JavaImageLoader.getImageInfo(src);
    if (imageInfo)
      src = imageInfo.uri;
  }
  dvt.ToolkitUtils.setAttrNS(this._elem, dvt.Image.XLINK_NS, 'xlink:href', src);
};


/**
 * Converts the specified shape string to its constant value.
 * @param {string} shape The shape string.
 * @return {number} The corresponding constant value.
 */
dvt.Marker.convertShapeString = function(shape) {
  if (shape == dvt.Marker.CIRCLE || shape == 'c')
    return dvt.Marker.CIRCLE;
  else if (shape == dvt.Marker.SQUARE || shape == 's')
    return dvt.Marker.SQUARE;
  else if (shape == dvt.Marker.DIAMOND || shape == 'd')
    return dvt.Marker.DIAMOND;
  else if (shape == dvt.Marker.TRIANGLE_UP || shape == 'tu' || shape == 't')
    return dvt.Marker.TRIANGLE_UP;
  else if (shape == dvt.Marker.TRIANGLE_DOWN || shape == 'td')
    return dvt.Marker.TRIANGLE_DOWN;
  else if (shape == dvt.Marker.PLUS || shape == 'p')
    return dvt.Marker.PLUS;
  else if (shape == dvt.Marker.HUMAN || shape == 'h')
    return dvt.Marker.HUMAN;
  else if (shape == dvt.Marker.ROUNDED_RECTANGLE || shape == 'rr')
    return dvt.Marker.ROUNDED_RECTANGLE;
  else
    return dvt.Marker.NONE;
};


/**
 * @override
 */
dvt.Marker.prototype.GetAttributesTransferableToGroup = function() {
  var attrNames = dvt.Container.AttributesTransferableToGroup.slice(0);
  // Check to see if matrix set since we don't transfer the 'transform' attr, bc it affects the clip path for custom markers.
  if (!this.getMatrix()) {
    var transformIndex = dvt.ArrayUtils.getIndex(attrNames, 'transform');
    attrNames.splice(transformIndex, 1);
  }
  var visibilityIndex = dvt.ArrayUtils.getIndex(attrNames, 'visibility');
  attrNames.splice(visibilityIndex, 1);
  return attrNames;
};


/**
 * Sets whether mouse events are enabled on this object.
 * @param {boolean} whether mouse events are enabled
 */
dvt.Marker.prototype.setMouseEnabled = function(bEnabled) {
  dvt.Marker.superclass.setMouseEnabled.call(this, bEnabled);
  if (this._childGroupElem) {
    var val;
    if (bEnabled) {
      val = 'visiblePainted';
    }
    else {
      val = 'none';
    }
    dvt.ToolkitUtils.setAttrNullNS(this._childGroupElem, 'pointer-events', val);
  }
};

dvt.Marker.prototype._setCustomMarker = function(markerDef, x, y, sx, sy) {
  if (this._isMultiPaths()) {
    var root = this._cloneMultiPaths(markerDef, x, y, sx, sy);
    this.addChild(root);

    // return container of multi paths
    return root;
  }
  else {
    this._setSingleShape(markerDef, x, y, sx, sy);
    return null;
  }
};

dvt.Marker.prototype._setSingleShape = function(markerDef, x, y, sx, sy) {
  var type = markerDef.getElem().nodeName;

  if (type == dvt.Marker.MARKER_PATH_ELEM_NAME) {
    this._setCmds(dvt.PathUtils.transformPath(markerDef.getCmds(), x, y, sx, sy));
  }
  /*
  else if (type == dvt.Marker.MARKER_CIRCLE_ELEM_NAME ||
           type == dvt.Marker.MARKER_ELLIPSE_ELEM_NAME) {
    this._setCx(markerDef.getCx());
    this._setCy(markerDef.getCy());
    this._setRadius(markerDef.getRadius());
  }

  else if (type == dvt.Marker.MARKER_LINE_ELEM_NAME) {
    this._setX1(defImpl.getX1());
    this._setX2(defImpl.getX2());
    this._setY1(defImpl.getY1());
    this._setY2(defImpl.getY2());
  }
  else if (type == dvt.Marker.MARKER_POLYGON_ELEM_NAME) {
    this._setPoints(defImpl._sPoints);
  }
  else if (type == dvt.Marker.MARKER_POLYLINE_ELEM_NAME) {
    this._setPoints(defImpl._sPoints);
  }
  else if (type == dvt.Marker.MARKER_RECT_TYPE_ELEM_NAME) {
    this._setX(markerDef.getX());
    this._setY(markerDef.getY());
    this._setWidth(markerDef.getWidth());
    this._setHeight(markerDef.getHeight());
  }
  */

  var fill = markerDef.getFill();
  if (fill) {
    this.setFill(fill);
  }
  var alpha = markerDef.getAlpha();
  if (alpha) {
    this.setAlpha(alpha);
  }
  var stroke = markerDef.getStroke();
  if (stroke) {
    var scaledStroke = stroke.clone();
    scaledStroke.setWidth(Math.min(sx, sy) * scaledStroke.getWidth());
    this.setStroke(scaledStroke);
  }
};


/**
 *   @private
 */
dvt.Marker.prototype._setPoints = function(points) {
  if (points !== this._points) {
    this._points = points;
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'points', points);
  }
};


/**
 * @private
 */
dvt.Marker.prototype._setX1 = function(x1) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'x1', x1);
};


/**
 * @private
 */
dvt.Marker.prototype._setY1 = function(y1) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'y1', y1);
};


/**
 * @private
 */
dvt.Marker.prototype._setX2 = function(x2) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'x2', x2);
};


/**
 * @private
 */
dvt.Marker.prototype._setY2 = function(y2) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'y2', y2);
};


/**
 * @private
 */
dvt.Marker.prototype._setRX = function(rx) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'rx', rx);
};


/**
 * @private
 */
dvt.Marker.prototype._setRY = function(ry) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'ry', ry);
};


/**
 * @private
 */
dvt.Marker.prototype._cloneMultiPaths = function(markerDef, x, y, sx, sy) {
  var context = this.getCtx();
  var root = new dvt.Container(context, markerDef.getId() + '_x');

  var childCnt = markerDef.getNumChildren();
  var childDef;
  var child;
  for (var i = 0; i < childCnt; i++) {
    childDef = markerDef.getChildAt(i);
    child = new dvt.Path(context, dvt.PathUtils.transformPath(childDef.getCmds(), x, y, sx, sy), childDef.getId());

    if (childDef.getFill()) {
      child.setFill(childDef.getFill());
    }
    if (childDef.getAlpha()) {
      child.setAlpha(childDef.getAlpha());
    }
    if (childDef.getStroke()) {
      var scaledStroke = childDef.getStroke().clone();
      scaledStroke.setWidth(Math.min(sx, sy) * scaledStroke.getWidth());
      child.setStroke(scaledStroke);
    }
    root.addChild(child);
  }

  return root;
};


/**
 * @override
 */
dvt.Marker.prototype.addChild = function(obj) {
  // if this marker has multi paths, don't add an additonal childGroupElem
  if (this._isMultiPaths()) {
    dvt.ToolkitUtils.appendChildElem(this.getElem(), obj.getOuterElem());
  }
  else {
    dvt.Marker.superclass.addChild.call(this, obj);
  }
};

dvt.Marker.prototype._isMultiPaths = function() {
  return (this.getElem().nodeName == 'g' && this.getType() != dvt.Marker.IMAGE);
};


/**
 * @override
 */
dvt.Marker.prototype.getDimensions = function() {
  // Added in order to prevent getDimensions returning null or a 0 width and height while waiting for an image load
  if (this._type == dvt.Marker.IMAGE) {
    var w = this.getScaledWidth();
    var h = this.getScaledHeight();
    return new dvt.Rectangle(this._x, this._y, w, h);
  }
  else {
    return dvt.Marker.superclass.getDimensions.call(this);
  }
};


/**
 * @override
 */
dvt.Marker.prototype.GetElemDimensionsWithStroke = function() {
  if (this._type == dvt.Marker.IMAGE)
    return this.getDimensions();// images don't have borders
  else
    return dvt.Marker.superclass.GetElemDimensionsWithStroke.call(this);
};


/**
 *  Enables/disables the visibility of marker and text if reference exists.
 *  @param {Boolean}  bVis  True if the object is to be visible, else false if
 *  it is to be hidden.
 *  @override
 */
dvt.Marker.prototype.setVisible = function(bVis) {
  dvt.Marker.superclass.setVisible.call(this, bVis);
  if (this._markerText)
    this._markerText.setVisible(bVis);
};

dvt.Marker.prototype._setMarkerImageStates = function(imageURIs) {
  // at a minimum an image URI will be provided for the active marker state
  var sourceImage = imageURIs[0];
  this._imageStates = [sourceImage];
  this._imageStates.push(imageURIs[1] ? imageURIs[1] : sourceImage);// sourceSelected
  this._imageStates.push(imageURIs[2] ? imageURIs[2] : sourceImage);// sourceHover
  this._imageStates.push(imageURIs[3] ? imageURIs[3] : this._imageStates[1]);// sourceHoverSelected
};

dvt.Marker.prototype.GetMarkerImage = function(state) {
  if (this._imageStates)
    return this._imageStates[state];
  return null;
};


/**
 * Determines if the specified marker shape is a built-in shape.
 * @param {string} shape The shape. For custom markers this would be the shape path.
 * @return {boolean} True if shape is built-in.
 */
dvt.Marker.isBuiltInShape = function(shape) {
  var shp = dvt.Marker.convertShapeString(shape);
  if (shp == dvt.Marker.CIRCLE || shp == dvt.Marker.SQUARE || shp == dvt.Marker.DIAMOND || shp == dvt.Marker.TRIANGLE_UP || shp == dvt.Marker.TRIANGLE_DOWN || shp == dvt.Marker.PLUS || shp == dvt.Marker.HUMAN || shp == dvt.Marker.ROUNDED_RECTANGLE) {
    return true;
  }
  else {
    return false;
  }
};


/**
 * @override
 */
dvt.Marker.prototype.copyShape = function() {
  return new dvt.Marker(this.getCtx(), this.getInitType(), this.getSkin(), this.getX(), this.getY(), this.getWidth(), this.getHeight(), null, this.getSx(), this.getSy(), this.getMaintainAspect());
};


/**
 * @override
 */
dvt.Marker.prototype.getDimensions = function(targetCoordinateSpace) {
  // Transforms on markers are not transferred to the outer group element so we must return dimensions of child
  // element which has the matrix
  if (this.InnerShape && this.InnerShape.getParent())
    return this.InnerShape.getDimensions(targetCoordinateSpace);
  else
    return dvt.Marker.superclass.getDimensions.call(this, targetCoordinateSpace);
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.Marker.prototype.getDimensionsSelf = function(targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new dvt.Rectangle(this.getX(), this.getY(), this.getScaledWidth(), this.getScaledHeight());
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};
// Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 *  @param {dvt.Context} context
 *  @param {String} shape Marker shape
 *  @param {String} skin The skin being used
 *  @param {number} cx  The x position of the center of the marker.
 *  @param {number} cy  The y position of the center of the marker.
 *  @param {number} width  The width of the marker.
 *  @param {number} height  The height of the marker.
 *  @param {string=} borderRadius Optional border radius value. Example values '5px', '50% 50% 0 0', '5px / 10px', '50% 50% 25% 25% / 25% 25% 50% 50%'
 *  @param {boolean=} bMaintainAspectRatio Optional boolean true if keeping aspect ratio.  True by default
 *  and only applies to built-in non-human shapes
 *  @param {String=} id  Optional ID for the shape.
 *
 *  @extends {dvt.Shape}
 *  @constructor
 */
dvt.SimpleMarker = function(context, shape, skin, cx, cy, width, height, borderRadius, bMaintainAspectRatio, id) {
  this.Init(context, shape, skin, cx, cy, width, height, borderRadius, bMaintainAspectRatio, id);
};

dvt.Obj.createSubclass(dvt.SimpleMarker, dvt.Shape);


// MARKER SHAPES
/**
 * A circular marker.
 */
dvt.SimpleMarker.CIRCLE = 'circle';

/**
 * An elliptical marker.
 */
dvt.SimpleMarker.ELLIPSE = 'ellipse';

/**
 * A square marker.
 */
dvt.SimpleMarker.SQUARE = 'square';

/**
 * A square marker with rounded corners.
 * @private
 */
dvt.SimpleMarker._ROUNDED_SQUARE = 'roundedSquare';

/**
 * A rectangular marker.
 */
dvt.SimpleMarker.RECTANGLE = 'rectangle';

/**
 * A rectangular marker with rounded corners.
 * @private
 */
dvt.SimpleMarker._ROUNDED_RECT = 'roundedRect';

/**
 * A diamond shaped marker.
 */
dvt.SimpleMarker.DIAMOND = 'diamond';

/**
 * A triangular shaped marker with a vertex at the top.
 */
dvt.SimpleMarker.TRIANGLE_UP = 'triangleUp';

/**
 * A triangular shaped marker with a vertex at the bottom.
 */
dvt.SimpleMarker.TRIANGLE_DOWN = 'triangleDown';

/**
 * A plus-shaped marker.
 */
dvt.SimpleMarker.PLUS = 'plus';

/**
 * A human figure shaped marker.
 */
dvt.SimpleMarker.HUMAN = 'human';

/**
 * A star figure shaped marker.
 */
dvt.SimpleMarker.STAR = 'star';

/**
 * Circle SVG element
 * @private
 */
dvt.SimpleMarker._CIRCLE_ELEM = 'circle';

/**
 * Ellipse SVG element
 * @private
 */
dvt.SimpleMarker._ELLIPSE_ELEM = 'ellipse';

/**
 * Rect SVG element
 * @private
 */
dvt.SimpleMarker._RECT_ELEM = 'rect';

/**
 * Path SVG element
 * @private
 */
dvt.SimpleMarker._PATH_ELEM = 'path';

/**
 * Polygon SVG element
 * @private
 */
dvt.SimpleMarker._POLYGON_ELEM = 'polygon';

/**
 * Mapping from shape to element type
 * @private
 */
dvt.SimpleMarker._SHAPE_ELEM_MAP = {};
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.CIRCLE] = dvt.SimpleMarker._CIRCLE_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.ELLIPSE] = dvt.SimpleMarker._ELLIPSE_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.SQUARE] = dvt.SimpleMarker._RECT_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker._ROUNDED_SQUARE] = dvt.SimpleMarker._PATH_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.RECTANGLE] = dvt.SimpleMarker._RECT_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker._ROUNDED_RECT] = dvt.SimpleMarker._PATH_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.DIAMOND] = dvt.SimpleMarker._POLYGON_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.TRIANGLE_UP] = dvt.SimpleMarker._POLYGON_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.TRIANGLE_DOWN] = dvt.SimpleMarker._POLYGON_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.PLUS] = dvt.SimpleMarker._POLYGON_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.HUMAN] = dvt.SimpleMarker._PATH_ELEM;
dvt.SimpleMarker._SHAPE_ELEM_MAP[dvt.SimpleMarker.STAR] = dvt.SimpleMarker._POLYGON_ELEM;

/**
 * Default border radius for rounded rect
 */
dvt.SimpleMarker.DEFAULT_BORDER_RADIUS = '6';


/**
 * Object initializer.
 * @param {dvt.Context} context
 * @param {String} shape Marker shape or path commands for a custom shape
 * @param {String} skin The skin being used
 * @param {number} cx  The x position of the center of the marker.
 * @param {number} cy  The y position of the center of the marker.
 * @param {number} width  The width of the marker.
 * @param {number} height  The height of the marker.
 * @param {string=} borderRadius Optional border radius value. Example values '5px', '50% 50% 0 0', '5px / 10px', '50% 50% 25% 25% / 25% 25% 50% 50%'
 * @param {boolean=} bMaintainAspectRatio Optional boolean true if keeping aspect ratio. True by default
 * and only applies to built-in non-human shapes
 * @param {String=} id  Optional ID for the shape.
 * @protected
 */
dvt.SimpleMarker.prototype.Init = function(context, shape, skin, cx, cy, width, height, borderRadius, bMaintainAspectRatio, id) {

  this._bMaintainAspectRatio = true;
  if (bMaintainAspectRatio === false) {
    this._bMaintainAspectRatio = false;
    if (shape == dvt.SimpleMarker.CIRCLE) {
      shape = dvt.SimpleMarker.ELLIPSE;
    }
  }

  if (borderRadius && borderRadius != '0') {
    this._borderRadius = borderRadius;
    if (shape === dvt.SimpleMarker.SQUARE)
      shape = dvt.SimpleMarker._ROUNDED_SQUARE;
    if (shape === dvt.SimpleMarker.RECTANGLE)
      shape = dvt.SimpleMarker._ROUNDED_RECT;
  }

  this._skin = skin;
  this._shape = shape ? shape : dvt.SimpleMarker.RECTANGLE;
  this._dataColor = '#000000';
  var type = shape ? dvt.SimpleMarker._SHAPE_ELEM_MAP[shape] : dvt.SimpleMarker._RECT_ELEM;


  if (type == null) {
    this._isCustomShape = true;
    this._path = new dvt.Path(context, shape);
    type = dvt.SimpleMarker._PATH_ELEM;
  }

  dvt.SimpleMarker.superclass.Init.call(this, context, type, id);

  if (this._shape == dvt.SimpleMarker._ROUNDED_SQUARE || this._shape == dvt.SimpleMarker._ROUNDED_RECT)
    this._path = this._getBorderRadiusPath(context, cx, cy, width, height, borderRadius);

  if (this._shape == dvt.SimpleMarker.HUMAN)
    this._path = dvt.MarkerUtils.getBuiltinMarkerInfo(context, dvt.SimpleMarker.HUMAN, this._skin);

  this._propertyChange = {};
  this.setCenter(cx, cy, true).setSize(width, height);
};

/**
 * Sets the dimensions (cx, cy, width, height) of the marker with a dvt.Rectangle.
 * x, y values of dvt.Rectangle correspond to the marker's center.
 * @param {dvt.Rectangle} rect
 *
 * @return {dvt.SimpleMarker}
 */
dvt.SimpleMarker.prototype.setCenterDimensions = function(rect) {
  return this.setCenter(rect.x, rect.y, true).setSize(rect.w, rect.h);
};

/**
 * Gets the dimensions (cx, cy, width, height) of the marker as a dvt.Rectangle.
 * x, y values of dvt.Rectangle correspond to the marker's center.
 *
 * @return {dvt.Rectangle}
 */
dvt.SimpleMarker.prototype.getCenterDimensions = function() {
  return new dvt.Rectangle(this._cx, this._cy, this._width, this._height);
};

/**
 * Sets the size of the marker.
 * @param {number} width The width of the marker.
 * @param {number} height The height of the marker.
 * @param {boolean} bDefer Defer SetSvgProperty
 *
 * @return {dvt.SimpleMarker}
 */
dvt.SimpleMarker.prototype.setSize = function(width, height, bDefer) {
  return this.setWidth(width, true).setHeight(height, bDefer);
};

/**
 * Sets the center coordinates of the marker.
 * @param {number} cx  The x position of the center of the marker.
 * @param {number} cy  The y position of the center of the marker.
 * @param {boolean} bDefer Defer SetSvgProperty
 *
 * @return {dvt.SimpleMarker}
 */
dvt.SimpleMarker.prototype.setCenter = function(cx, cy, bDefer) {
  return this.setCx(cx, true).setCy(cy, bDefer);
};

/**
 * Updates relevant SVG properties of the marker
 * @return {dvt.SimpleMarker}
 * @private
 */
dvt.SimpleMarker.prototype._updateSvgProperties = function() {
  if (this._propertyChange.width || this._propertyChange.height) {
    var s = Math.min(this._width, this._height);
    this._propertyChange.s = (this._s != s);
    this._s = s;
  }

  if (this._shape == dvt.SimpleMarker.SQUARE) {
    var width = this.getMaintainAspectRatio() ? this._s : this._width;
    var height = this.getMaintainAspectRatio() ? this._s : this._height;
    if (this._propertyChange.cx || this._propertyChange.s)
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'x', this._cx - width / 2, 0);
    if (this._propertyChange.cy || this._propertyChange.s)
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'y', this._cy - height / 2, 0);
    if (this.getMaintainAspectRatio() ? this._propertyChange.s :
        (this._propertyChange.width || this._propertyChange.height)) {
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'width', width, 0);
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'height', height, 0);
    }
  }

  else if (this._shape == dvt.SimpleMarker.RECTANGLE) {
    if (this._propertyChange.cx || this._propertyChange.width)
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'x', this._cx - this._width / 2, 0);
    if (this._propertyChange.cy || this._propertyChange.height)
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'y', this._cy - this._height / 2, 0);
    if (this._propertyChange.width)
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'width', this._width, 0);
    if (this._propertyChange.height)
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'height', this._height, 0);
  }

  else if (this._shape == dvt.SimpleMarker.CIRCLE ||
      this._shape == dvt.SimpleMarker.ELLIPSE) {
    if (this._propertyChange.cx)
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'cx', this._cx, 0);
    if (this._propertyChange.cy)
      dvt.ToolkitUtils.setAttrNullNS(this._elem, 'cy', this._cy, 0);

    if (this._shape == dvt.SimpleMarker.CIRCLE) {
      if (this._propertyChange.s)
        dvt.ToolkitUtils.setAttrNullNS(this._elem, 'r', this._s / 2, 0);
    }
    else {
      if (this._propertyChange.width)
        dvt.ToolkitUtils.setAttrNullNS(this._elem, 'rx', this._width / 2, 0);
      if (this._propertyChange.height)
        dvt.ToolkitUtils.setAttrNullNS(this._elem, 'ry', this._height / 2, 0);
    }
  }

  else if (this._isPolygon()) {
    if (this._propertyChange.s || this._propertyChange.cx || this._propertyChange.cy)
      this._setPolygon(this._getPolygonArray());
  }

  else if (this._isPath()) {
    if (this._propertyChange.width || this._propertyChange.height || this._propertyChange.cx || this._propertyChange.cy)
      this._setCmds(this._getCmds());
  }

  this.UpdateSelectionEffect();
  this._propertyChange = {};
  return this;
};


/**
 * Returns the x coordinate of the center of the marker.
 * @return {number}
 */
dvt.SimpleMarker.prototype.getCx = function() {
  return this._cx;
};

/**
 * Specifies the x coordinate of the center of the marker.
 * @param {number} cx
 * @param {boolean} bDefer Defer updating the svg properties
 * @return {dvt.SimpleMarker}
 */
dvt.SimpleMarker.prototype.setCx = function(cx, bDefer) {
  this._propertyChange.cx = (this._cx != cx);
  this._cx = cx;
  return (bDefer ? this : this._updateSvgProperties());
};

/**
 * Returns the y coordinate of the center of the marker.
 * @return {number}
 */
dvt.SimpleMarker.prototype.getCy = function() {
  return this._cy;
};

/**
 * Specifies the y coordinate of the center of the marker.
 * @param {number} cy
 * @param {boolean} bDefer Defer updating the svg properties
 * @return {dvt.SimpleMarker}
 */
dvt.SimpleMarker.prototype.setCy = function(cy, bDefer) {
  this._propertyChange.cy = (this._cy != cy);
  this._cy = cy;
  return (bDefer ? this : this._updateSvgProperties());

};

/**
 *  Returns the size of the marker.
 *  @return {number}
 */
dvt.SimpleMarker.prototype.getSize = function() {
  // Note: This currently returns the smaller of the width and height, while the marker field returns the greater of the
  // two. This needs to be reconciled.
  return this._s;
};

/**
 * Returns the width of the marker.
 * @return {number}
 */
dvt.SimpleMarker.prototype.getWidth = function() {
  return this._width;
};

/**
 * Specifies the width of the marker.
 * @param {number} width
 * @param {boolean} bDefer Defer updating the svg properties
 * @return {dvt.SimpleMarker}
 */
dvt.SimpleMarker.prototype.setWidth = function(width, bDefer) {
  this._propertyChange.width = (this._width != width);
  this._width = width;
  return (bDefer ? this : this._updateSvgProperties());
};

/**
 * Returns the height of the marker.
 * @return {number}
 */
dvt.SimpleMarker.prototype.getHeight = function() {
  return this._height;
};

/**
 * Specifies the height of the marker.
 * @param {number} height
 * @param {boolean} bDefer Defer updating the svg properties
 * @return {dvt.SimpleMarker}
 */
dvt.SimpleMarker.prototype.setHeight = function(height, bDefer) {
  this._propertyChange.height = (this._height != height);
  this._height = height;
  return (bDefer ? this : this._updateSvgProperties());
};

/**
 * Returns polygon array for given dimensions.
 *
 * @return {array} array of polygon coordinates
 * @private
 */
dvt.SimpleMarker.prototype._getPolygonArray = function() {
  var ar = [];

  var cx = this._cx;
  var cy = this._cy;

  var halfx = this.getMaintainAspectRatio() ? this._s / 2 : this._width / 2;
  var halfy = this.getMaintainAspectRatio() ? this._s / 2 : this._height / 2;
  var sixthx = this.getMaintainAspectRatio() ? this._s / 6 : this._width / 6;
  var sixthy = this.getMaintainAspectRatio() ? this._s / 6 : this._height / 6;

  if (this._shape == dvt.SimpleMarker.TRIANGLE_UP) {
    ar = [
      cx - halfx,
      cy + halfy,
      cx,
      cy - halfy,
      cx + halfx,
      cy + halfy
    ];
  }
  else if (this._shape == dvt.SimpleMarker.TRIANGLE_DOWN) {
    ar = [
      cx - halfx,
      cy - halfy,
      cx,
      cy + halfy,
      cx + halfx,
      cy - halfy
    ];
  }
  else if (this._shape == dvt.SimpleMarker.DIAMOND) {
    ar = [
      cx - halfx,
      cy,
      cx,
      cy - halfy,
      cx + halfx,
      cy,
      cx,
      cy + halfy
    ];
  }
  else if (this._shape == dvt.SimpleMarker.PLUS) {
    ar = [
      cx - halfx,
      cy - sixthy,
      cx - sixthx,
      cy - sixthy,
      cx - sixthx,
      cy - halfy,
      cx + sixthx,
      cy - halfy,
      cx + sixthx,
      cy - sixthy,
      cx + halfx,
      cy - sixthy,
      cx + halfx,
      cy + sixthy,
      cx + sixthx,
      cy + sixthy,
      cx + sixthx,
      cy + halfy,
      cx - sixthx,
      cy + halfy,
      cx - sixthx,
      cy + sixthy,
      cx - halfx,
      cy + sixthy
    ];
  }
  else if (this._shape == dvt.SimpleMarker.STAR) {
    ar = dvt.MarkerDef.SHAPE_STAR_CMDS;

    // Scale and translate from center of (0,0)
    ar = dvt.PolygonUtils.scale(ar, this.getMaintainAspectRatio() ? this._s / 100 : this._width / 100,
        this.getMaintainAspectRatio() ? this._s / 100 : this._height / 100);
    ar = dvt.PolygonUtils.translate(ar, cx, cy);
  }
  return ar;
};

/**
 * Sets the polygon shape of the marker
 * @param {array} ar
 * @private
 */
dvt.SimpleMarker.prototype._setPolygon = function(ar) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'points', dvt.SvgShapeUtils.convertPointsArray(ar));
};

/**
 * Calculates and returns path commands for given dimensions
 *
 * @return {string} commands
 * @private
 */
dvt.SimpleMarker.prototype._getCmds = function() {
  var dim = dvt.DisplayableUtils.getDimForced(this.getCtx(), this._path);

  var max = Math.max(dim.w, dim.h);
  var maintain = this.getMaintainAspectRatio();
  if (this._shape == dvt.SimpleMarker._ROUNDED_RECT)
    maintain = false;
  var scalex = maintain ? this._s / max : this._width / dim.w;
  var scaley = maintain ? this._s / max : this._height / dim.h;

  var dx = this._cx - (dim.x * scalex) - (dim.w * scalex) / 2;
  var dy = this._cy - (dim.y * scaley) - (dim.h * scaley) / 2;

  return dvt.PathUtils.transformPath(this._path.getCmds(), dx, dy, scalex, scaley);
};

/**
 * Sets the path of the marker
 * @param {string} cmds
 * @private
 */
dvt.SimpleMarker.prototype._setCmds = function(cmds) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'd', cmds);
};

/**
 * Gets the type of the marker
 * @return {string}
 */
dvt.SimpleMarker.prototype.getType = function() {
  return this._shape;
};

/**
 * @private
 * @return {boolean}
 */
dvt.SimpleMarker.prototype._isPolygon = function() {
  return dvt.SimpleMarker._SHAPE_ELEM_MAP[this._shape] == dvt.SimpleMarker._POLYGON_ELEM;
};

/**
 * @private
 * @return {boolean}
 */
dvt.SimpleMarker.prototype._isPath = function() {
  return dvt.SimpleMarker._SHAPE_ELEM_MAP[this._shape] == dvt.SimpleMarker._PATH_ELEM || this._isCustomShape;
};


/**
 * @param {number} sw Stroke width
 * @protected
 */
dvt.SimpleMarker.prototype.SetStrokeWidth = function(sw) {
  var stroke = this.getStroke();
  if (stroke) {
    stroke = stroke.clone();
    stroke.setWidth(sw);
    this.setStroke(stroke);
  }
};

/**
 * @protected
 * @return {number} Stroke width
 */
dvt.SimpleMarker.prototype.GetStrokeWidth = function() {
  var stroke = this.getStroke();
  if (stroke) {
    return stroke.getWidth();
  }
  return 0;
};

/**
 * @private
 * Gets the path of the marker when a border radius is specified.  Only applies for rectangle and square shapes.
 *
 * @param {dvt.Context} context
 * @param {number} cx  The x position of the center of the marker.
 * @param {number} cy  The y position of the center of the marker.
 * @param {number} width  The width of the marker.
 * @param {number} height  The height of the marker.
 * @param {string=} borderRadius Optional border radius value. Example values '5px', '50% 50% 0 0', '5px / 10px', '50% 50% 25% 25% / 25% 25% 50% 50%'
 *
 * @return {dvt.Path} marker path with border radius.
 */
dvt.SimpleMarker.prototype._getBorderRadiusPath = function(context, cx, cy, width, height, borderRadius) {
  if (this._shape == dvt.SimpleMarker._ROUNDED_SQUARE ||
      this._shape == dvt.SimpleMarker._ROUNDED_RECT) {

    var s = Math.min(width, height);
    var w = this._shape == dvt.SimpleMarker._ROUNDED_SQUARE ? s : width;
    var h = this._shape == dvt.SimpleMarker._ROUNDED_SQUARE ? s : height;
    var x = cx - w / 2;
    var y = cy - h / 2;
    var cmds = dvt.PathUtils.rectangleWithBorderRadius(
        x,
        y,
        w,
        h,
        borderRadius,
        s,
        '0');
    return new dvt.Path(context, cmds);
  }
  return null;
};

/**
 * Gets the border radius value of the marker.
 *
 * @return {string} border radius value. Example values '5px', '50% 50% 0 0', '5px / 10px', '50% 50% 25% 25% / 25% 25% 50% 50%'
 * @private
 */
dvt.SimpleMarker.prototype._getBorderRadius = function() {
  return this._borderRadius;
};

/**
 * Specifies the color of the data item and its selection feedback, if different from the default.
 * @param {string} dataColor The CSS color string of the primary color of the data item.
 * @param {boolean} bSkipStroke True if the hover and selected stroke creation should be skipped.
 */
dvt.SimpleMarker.prototype.setDataColor = function(dataColor, bSkipStroke) {
  this._dataColor = dataColor;
  if (!bSkipStroke) {
    var hoverColor = dvt.SelectionEffectUtils.getHoverBorderColor(dataColor);
    var innerColor = '#FFFFFF';
    var outerColor = '#5A5A5A';

    this.setHoverStroke(new dvt.SolidStroke(innerColor, 1, 1), new dvt.SolidStroke(hoverColor, 1, 3.5));
    this.setSelectedStroke(new dvt.SolidStroke(innerColor, 1, 1.5), new dvt.SolidStroke(outerColor, 1, 4.5));
    this.setSelectedHoverStroke(new dvt.SolidStroke(innerColor, 1, 1.5), new dvt.SolidStroke(hoverColor, 1, 4.5));

    this.HoverInnerStroke.setFixedWidth(true);
    this.HoverOuterStroke.setFixedWidth(true);
    this.SelectedInnerStroke.setFixedWidth(true);
    this.SelectedOuterStroke.setFixedWidth(true);
    this.SelectedHoverInnerStroke.setFixedWidth(true);
    this.SelectedHoverOuterStroke.setFixedWidth(true);
  }
};


/**
 * Get the data color used as a base for selection colors.
 * @return {string} data color
 */
dvt.SimpleMarker.prototype.getDataColor = function() {
  return this._dataColor;
};


/**
 * Changes the shape to an outline shape format.  Used for legend
 * markers that represent a hidden state for the associated series risers.
 * @param {String} color Border color for hollow shape in format of #aarrggbb
 * @override
 */
dvt.SimpleMarker.prototype.setHollow = function(color) {
  //scale the stroke width inversely proportional to the marker scale
  //so that the stroke width appears to be the same for all markers
  //  var scaleX = this.getScaleX();
  //  var scaleY = this.getScaleY();
  //  var scale = Math.min(scaleX, scaleY);
  var strokeWidth = this.GetStrokeWidth();
  strokeWidth = (strokeWidth ? strokeWidth : 1); // / scale;

  //save the stroke width so that we can reset it if needed
  dvt.SimpleMarker.superclass.setHollow.call(this, color, strokeWidth);
};


/**
 * Adds reference for legend text to marker
 * @param {DvtText} text Legend text
 */
dvt.SimpleMarker.prototype.setText = function(text) {
  this._markerText = text;
};


/**
 * Adds reference for legend text to marker
 * @param {number} alpha Opacity of object
 * @override
 */
dvt.SimpleMarker.prototype.setAlpha = function(alpha) {
  dvt.SimpleMarker.superclass.setAlpha.call(this, alpha);
  if (this._markerText)
    this._markerText.setAlpha(alpha);
  this.UpdateSelectionEffect();
};

/**
 * @return {dvt.SimpleMarker} copy of the marker
 * @override
 */
dvt.SimpleMarker.prototype.copyShape = function() {
  return new dvt.SimpleMarker(this.getCtx(), this._shape, this._skin, this.getCx(), this.getCy(), this.getWidth(), this.getHeight(), this._getBorderRadius(), this.getMaintainAspectRatio());
};

/**
 * @override
 */
dvt.SimpleMarker.prototype.getDimensions = function(targetCoordinateSpace) {
  var x = this.getCx() - this.getWidth() / 2;
  var y = this.getCy() - this.getHeight() / 2;
  var bounds = new dvt.Rectangle(x, y, this.getWidth(), this.getHeight());
  // Calculate the bounds relative to the target space
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};

/**
 * @param {boolean} bMaintainAspectRatio True if keeping aspect ratio
 */
dvt.SimpleMarker.prototype.setMaintainAspectRatio = function(bMaintainAspectRatio) {
  this._bMaintainAspectRatio = bMaintainAspectRatio;
};

/**
 * @return {boolean} true if keeping aspect ratio
 */
dvt.SimpleMarker.prototype.getMaintainAspectRatio = function() {
  return this._bMaintainAspectRatio;
};

// Copyright (c) 2014, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * @param {dvt.Context} context
 * @param {number} cx  The x position of the center of the marker.
 * @param {number} cy  The y position of the center of the marker.
 * @param {number} width  The width of the marker.
 * @param {number} height  The height of the marker.
 * @param {string=} borderRadius Optional border radius of the marker. Example values '5px', '50% 50% 0 0', '5px / 10px', '50% 50% 25% 25% / 25% 25% 50% 50%'
 * @param {string=} source Optional image URI for the default state.
 * @param {string=} sourceSelected Optional image URI for the selected state. 'source' used if not passed.
 * @param {string=} sourceHover Optional image URI for the hover state. 'source' used if not passed.
 * @param {string=} sourceHoverSelected Optional image URI for the hover selected state. 'source' used if not passed.
 * @param {string=} id Optional ID for the shape.
 *
 * @extends {dvt.Shape}
 * @constructor
 */
dvt.ImageMarker = function(context, cx, cy, width, height, borderRadius, source, sourceSelected, sourceHover, sourceHoverSelected, id) {
  this.Init(context, cx, cy, width, height, borderRadius, source, sourceSelected, sourceHover, sourceHoverSelected, id);
};

dvt.Obj.createSubclass(dvt.ImageMarker, dvt.Shape);
/**
 * Object initializer.
 * @param {dvt.Context} context
 * @param {number} cx  The x position of the center of the marker.
 * @param {number} cy  The y position of the center of the marker.
 * @param {number} width  The width of the marker.
 * @param {number} height  The height of the marker.
 * @param {string=} borderRadius Optional the border radius of the marker. Example values '5px', '50% 50% 0 0', '5px / 10px', '50% 50% 25% 25% / 25% 25% 50% 50%'
 * @param {string=} source Optional image URI for the default state.
 * @param {string=} sourceSelected Optional image URI for the selected state. 'source' used if not passed.
 * @param {string=} sourceHover Optional image URI for the hover state. 'source' used if not passed.
 * @param {string=} sourceHoverSelected Optional image URI for the hover selected state. 'source' used if not passed.
 * @param {string=} id Optional ID for the shape.
 * @protected
 */
dvt.ImageMarker.prototype.Init = function(context, cx, cy, width, height, borderRadius, source, sourceSelected, sourceHover, sourceHoverSelected, id) {

  dvt.ImageMarker.superclass.Init.call(this, context, 'image', id);

  this._setMarkerImageStates(source, sourceSelected, sourceHover, sourceHoverSelected);
  var image = this._getImage();
  this._setSource(image);

  this._propertyChange = {};
  this.setCenter(cx, cy, true).setSize(width, height);
  this._updateBorder(borderRadius);

  // IE doesn't allow interactivity unless there's a fill
  if (dvt.Agent.isPlatformIE()) {
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill', '#FFFFFF');
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', '0');
  }
};

/**
 * @param {string} preserveAspectRatio String to pass into the preserveAspectRatio attribute for this marker
 */
dvt.ImageMarker.prototype.setPreserveAspectRatio = function(preserveAspectRatio) {
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'preserveAspectRatio', preserveAspectRatio, 'xMidYMid');
};

/**
 * Sets the dimensions (cx, cy, width, height) of the marker with a dvt.Rectangle.
 * x, y values of dvt.Rectangle correspond to the marker's center.
 * @param {dvt.Rectangle} rect
 *
 * @return {dvt.ImageMarker}
 */
dvt.ImageMarker.prototype.setCenterDimensions = function(rect) {
  return this.setCenter(rect.x, rect.y, true).setSize(rect.w, rect.h);
};

/**
 * Gets the dimensions (cx, cy, width, height) of the marker as a dvt.Rectangle.
 * x, y values of dvt.Rectangle correspond to the marker's center.
 *
 * @return {dvt.Rectangle}
 */
dvt.ImageMarker.prototype.getCenterDimensions = function() {
  return new dvt.Rectangle(this._cx, this._cy, this._width, this._height);
};

/**
 * Sets the size of the marker.
 * @param {number} width The width of the marker.
 * @param {number} height The height of the marker.
 * @param {boolean} bDefer Defer SetSvgProperty
 *
 * @return {dvt.ImageMarker}
 */
dvt.ImageMarker.prototype.setSize = function(width, height, bDefer) {
  return this.setWidth(width, true).setHeight(height, bDefer);
};

/**
 * Returns the size of the marker.
 *
 * @return {number} The bigger dimension of the width and height
 */
dvt.ImageMarker.prototype.getSize = function() {
  return Math.max(this.getWidth(), this.getHeight());
};

/**
 * Sets the center coordinates of the marker.
 * @param {number} cx  The x position of the center of the marker.
 * @param {number} cy  The y position of the center of the marker.
 * @param {boolean} bDefer Defer SetSvgProperty
 *
 * @return {dvt.ImageMarker}
 */
dvt.ImageMarker.prototype.setCenter = function(cx, cy, bDefer) {
  return this.setCx(cx, true).setCy(cy, bDefer);
};

/**
 * Updates SVG properties of the marker
 * @return {dvt.ImageMarker}
 * @private
 */
dvt.ImageMarker.prototype._updateSvgProperties = function() {
  if (this._propertyChange.cx || this._propertyChange.width)
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'x', this._cx - this._width / 2, 0);

  if (this._propertyChange.cy || this._propertyChange.height)
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'y', this._cy - this._height / 2, 0);

  if (this._propertyChange.width)
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'width', this._width, 0);

  if (this._propertyChange.height)
    dvt.ToolkitUtils.setAttrNullNS(this._elem, 'height', this._height, 0);

  // redraws border radius clipPath and _borderPath element
  this._updateBorder(this._borderRadius);
  this.UpdateSelectionEffect();
  this._propertyChange = {};
  return this;
};

/**
 * Returns the x coordinate of the center of the marker.
 * @return {number}
 */
dvt.ImageMarker.prototype.getCx = function() {
  return this._cx;
};

/**
 * Specifies the x coordinate of the center of the marker.
 * @param {number} cx
 * @param {boolean} bDefer Defer SetSvgProperty
 * @return {dvt.ImageMarker}
 */
dvt.ImageMarker.prototype.setCx = function(cx, bDefer) {
  this._propertyChange.cx = (this._cx != cx);
  this._cx = cx;
  return (bDefer ? this : this._updateSvgProperties());
};

/**
 * Returns the y coordinate of the center of the marker.
 * @return {number}
 */
dvt.ImageMarker.prototype.getCy = function() {
  return this._cy;
};

/**
 * Specifies the y coordinate of the center of the marker.
 * @param {number} cy
 * @param {boolean} bDefer Defer SetSvgProperty
 * @return {dvt.ImageMarker}
 */
dvt.ImageMarker.prototype.setCy = function(cy, bDefer) {
  this._propertyChange.cy = (this._cy != cy);
  this._cy = cy;
  return (bDefer ? this : this._updateSvgProperties());

};

/**
 * Returns the width of the marker.
 * @return {number}
 */
dvt.ImageMarker.prototype.getWidth = function() {
  return this._width;
};

/**
 * Specifies the width of the marker.
 * @param {number} width
 * @param {boolean} bDefer Defer SetSvgProperty
 * @return {dvt.ImageMarker}
 */
dvt.ImageMarker.prototype.setWidth = function(width, bDefer) {
  this._propertyChange.width = (this._width != width);
  this._width = width;
  return (bDefer ? this : this._updateSvgProperties());

};

/**
 * Returns the height of the marker.
 * @return {number}
 */
dvt.ImageMarker.prototype.getHeight = function() {
  return this._height;
};

/**
 * Specifies the height of the marker.
 * @param {number} height
 * @param {boolean} bDefer Defer SetSvgProperty
 * @return {dvt.ImageMarker}
 */
dvt.ImageMarker.prototype.setHeight = function(height, bDefer) {
  this._propertyChange.height = (this._height != height);
  this._height = height;
  return (bDefer ? this : this._updateSvgProperties());

};

/**
 * Set the image source
 * @param {String} src Image URI to be set as the source.
 * @private
 */
dvt.ImageMarker.prototype._setSource = function(src) {
  if (dvt.Agent.isEnvironmentBatik()) {
    var imageInfo = dvt.JavaImageLoader.getImageInfo(src);
    if (imageInfo)
      src = imageInfo.uri;
  }
  dvt.ToolkitUtils.setAttrNS(this._elem, dvt.Image.XLINK_NS, 'xlink:href', src);
};

/**
 * Set the image state array
 * @param {String} source Image URI for the default state.
 * @param {String} sourceSelected Image URI for the selected state.
 * @param {String} sourceHover Image URI for the hover state.
 * @param {String} sourceHoverSelected Image URI for the hover selected state.
 * @private
 */
dvt.ImageMarker.prototype._setMarkerImageStates = function(source, sourceSelected, sourceHover, sourceHoverSelected) {
  // at a minimum an image URI will be provided for the active marker state
  var sourceImage = source;
  this._imageStates = [sourceImage];
  this._imageStates.push(sourceSelected ? sourceSelected : sourceImage);
  this._imageStates.push(sourceHover ? sourceHover : sourceImage);
  this._imageStates.push(sourceHoverSelected ? sourceHoverSelected : this._imageStates[1]);
};

/**
 * Get default image state URI
 * @return {string}
 * @private
 */
dvt.ImageMarker.prototype._getImage = function() {
  return this._imageStates[0];
};

/**
 * Get selected image state URI
 * @return {string}
 * @private
 */
dvt.ImageMarker.prototype._getImageSelected = function() {
  return this._imageStates[1];
};

/**
 * Get hover image state URI
 * @return {string}
 * @private
 */
dvt.ImageMarker.prototype._getImageHover = function() {
  return this._imageStates[2];
};

/**
 * Get hover selected image state URI
 * @return {string}
 * @private
 */
dvt.ImageMarker.prototype._getImageHoverSelected = function() {
  return this._imageStates[3];
};

/**
 * @override
 */
dvt.ImageMarker.prototype.showHoverEffect = function() {
  this.IsShowingHoverEffect = true;
  if (this.isSelected())
    this._setSource(this._getImageHoverSelected());
  else
    this._setSource(this._getImageHover());
};

/**
 * @override
 */
dvt.ImageMarker.prototype.hideHoverEffect = function() {
  this.IsShowingHoverEffect = false;
  if (this.isSelected())
    this._setSource(this._getImageSelected());
  else
    this._setSource(this._getImage());
};

/**
 * @override
 */
dvt.ImageMarker.prototype.setSelected = function(selected) {
  if (this.IsSelected == selected)
    return;

  this.IsSelected = selected;
  if (selected) {
    if (this.isHoverEffectShown())
      this._setSource(this._getImageHoverSelected());
    else
      this._setSource(this._getImageSelected());
  }
  else {
    this._setSource(this._getImage());
  }
};

/**
 * Updates/sets the border radius clip path and border path element of the marker.
 *
 * @param {string} borderRadius Border radius value. Example values '5px', '50% 50% 0 0', '5px / 10px', '50% 50% 25% 25% / 25% 25% 50% 50%'
 * @private
 */
dvt.ImageMarker.prototype._updateBorder = function(borderRadius) {
  if (borderRadius || this._borderPath) {
    // Set clip path with new commands
    if (borderRadius && borderRadius != '0') {
      var clipCmds = dvt.PathUtils.rectangleWithBorderRadius(
          this._cx - this._width / 2,
          this._cy - this._height / 2,
          this._width,
          this._height,
          borderRadius,
          Math.min(this._width, this._height),
          '0');
      var clipPath = new dvt.ClipPath();
      clipPath.addPath(clipCmds);
      this.setClipPath(clipPath);
    }

    // Update border path with new commands
    if (this._borderPath) {
      var borderCmds = dvt.PathUtils.rectangleWithBorderRadius(
          this._cx - this._width / 2 + this._borderWidth / 2,
          this._cy - this._height / 2 + this._borderWidth / 2,
          this._width - this._borderWidth,
          this._height - this._borderWidth,
          borderRadius,
          Math.min(this._width, this._height),
          '0');
      this._borderPath.setCmds(borderCmds);
    }
  }
  this._borderRadius = borderRadius;
};

/**
 * Gets the border radius value of the image marker.
 *
 * @return {string} border radius value. Example values '5px', '50% 50% 0 0', '5px / 10px', '50% 50% 25% 25% / 25% 25% 50% 50%'
 * @private
 */
dvt.ImageMarker.prototype._getBorderRadius = function() {
  return this._borderRadius;
};

/**
 * @override
 */
dvt.ImageMarker.prototype.setStroke = function(stroke) {
  if (!stroke || stroke.getWidth() <= 0) {
    this._borderWidth = 0;
    // Clear old border path if no new stroke.
    if (this._borderPath) {
      this.removeChild(this._borderPath);
      this._borderPath = null;
    }
    return;
  }

  var width = stroke.getWidth();
  if (!this._borderPath || width != this._borderWidth) {
    // Calculate border path commands
    var cmds = dvt.PathUtils.rectangleWithBorderRadius(
        this._cx - this._width / 2 + width / 2,
        this._cy - this._height / 2 + width / 2,
        this._width - width,
        this._height - width,
        this._borderRadius,
        Math.min(this._width, this._height),
        '0');

    // Create and add _borderPath element
    if (this._borderPath)
      this._borderPath.setCmds(cmds);
    else {
      this._borderPath = new dvt.Path(this.getCtx(), cmds);
      this._borderPath.setInvisibleFill();
      this.addChild(this._borderPath);
    }
  }
  this._borderWidth = width;
  this._borderPath.setStroke(stroke);
};

/**
 * @return {dvt.ImageMarker} copy of the marker
 * @override
 */
dvt.ImageMarker.prototype.copyShape = function() {
  return new dvt.ImageMarker(this.getCtx(), this.getCx(), this.getCy(), this.getWidth(), this.getHeight(), this._getBorderRadius(), this._getImage(), this._getImageSelected(), this._getImageHover(), this._getImageHoverSelected(), null);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Ellipse displayable.
 * @param {dvt.Context} context
 * @param {number} cx The x coordinate of the center of the circle.
 * @param {number} cy The y coordinate of the center of the circle.
 * @param {number} rx The horizontal radius of the circle.
 * @param {number} ry The vertical radius of the circle.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {DvtCircularShape}
 * @class
 * @constructor
 */
dvt.Oval = function(context, cx, cy, rx, ry, id) {
  this.Init(context, cx, cy, rx, ry, id);
};

dvt.Obj.createSubclass(dvt.Oval, DvtCircularShape);


/**
 * @param {dvt.Context} context
 * @param {number} cx The x coordinate of the center of the circle.
 * @param {number} cy The y coordinate of the center of the circle.
 * @param {number} rx The horizontal radius of the circle.
 * @param {number} ry The vertical radius of the circle.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.Oval.prototype.Init = function(context, cx, cy, rx, ry, id) {
  dvt.Oval.superclass.Init.call(this, context, 'ellipse', cx, cy, id);
  this.setRx(rx).setRy(ry);
};


/**
 * Returns the horizontal radius of the ellipse.
 * @return {number}
 */
dvt.Oval.prototype.getRx = function() {
  return this.GetProperty('rx');
};


/**
 * Specifies the horizontal radius of the ellipse.
 * @param {number} rx
 * @return {dvt.Oval}
 */
dvt.Oval.prototype.setRx = function(rx) {
  return this.SetSvgProperty('rx', rx);
};


/**
 * Returns the vertical radius of the ellipse.
 * @return {number}
 */
dvt.Oval.prototype.getRy = function() {
  return this.GetProperty('ry');
};


/**
 * Specifies the vertical radius of the ellipse.
 * @param {number} ry
 * @return {dvt.Oval}
 */
dvt.Oval.prototype.setRy = function(ry) {
  return this.SetSvgProperty('ry', ry);
};


/**
 * @override
 */
dvt.Oval.prototype.copyShape = function() {
  return new dvt.Oval(this.getCtx(), this.getCx(), this.getCy(), this.getRx(), this.getRy());
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.Oval.prototype.getDimensionsSelf = function(targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new dvt.Rectangle(this.getCx() - this.getRx(), this.getCy() - this.getRy(), this.getRx() * 2, this.getRy() * 2);
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Path displayable.
 * @param {dvt.Context} context
 * @param {object} cmds The string of SVG path commands or an array of SVG path commands, whose entries contain the
 *                      commands followed by coordinates.
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {dvt.Shape}
 * @class
 * @constructor
 */
dvt.Path = function(context, cmds, id) {
  this.Init(context, cmds, id);
};

dvt.Obj.createSubclass(dvt.Path, dvt.Shape);


/**
 * @param {dvt.Context} context
 * @param {object} cmds The string of SVG path commands or an array of SVG path commands, whose entries contain the
 *                      commands followed by coordinates.
 * @param {string=} id The optional id for the corresponding DOM element.
 */
dvt.Path.prototype.Init = function(context, cmds, id) {
  dvt.Path.superclass.Init.call(this, context, 'path', id);

  if (dvt.ArrayUtils.isArray(cmds))
    this.setCmds(dvt.PathUtils.getPathString(cmds));
  else
    this.setCmds(cmds);
};


/**
 * Returns the string of SVG path commands.
 * @param {string} cmds
 */
dvt.Path.prototype.getCmds = function() {
  return this.GetProperty('d');
};


/**
 * Specifies the string of SVG path commands.
 * @param {String} cmds
 * @return {dvt.Path}
 */
dvt.Path.prototype.setCmds = function(cmds) {
  if (cmds)
    this.SetSvgProperty('d', cmds);

  // Clear the cached array commands, which will be populated when needed.
  this.SetProperty('arCmds', null);

  // Return self for linking setters
  return this;
};


/**
 * Returns the array of SVG path commands, whose entries contain the commands followed by coordinates.
 * @return {array}
 */
dvt.Path.prototype.getCommands = function() {
  // TODO  rename to get/setCommandsArray

  // If cached copy exists, use it.
  var arCmds = this.GetProperty('arCmds');
  if (!arCmds) {
    // Otherwise, convert, cache and return.
    arCmds = this.GetProperty('d') ? dvt.PathUtils.createPathArray(this.GetProperty('d')) : null;
    this.SetProperty('arCmds', arCmds);
  }
  return arCmds;
};


/**
 * Specifies the array of SVG path commands, whose entries contain the commands followed by coordinates.
 * @param {array} arCmds
 * @return {dvt.Path}
 */
dvt.Path.prototype.setCommands = function(arCmds) {
  // Convert to string and set
  var cmds = arCmds ? dvt.PathUtils.getPathString(arCmds) : null;
  this.setCmds(cmds);

  // Cache the array
  this.SetProperty('arCmds', arCmds);

  // Return self for linking setters
  return this;
};


/**
 * @override
 */
dvt.Path.prototype.copyShape = function() {
  return new dvt.Path(this.getCtx(), this.getCmds());
};

/**
 * @override
 */
dvt.Path.prototype.GetAriaElem = function() {
  if (dvt.Agent.isTouchDevice())
    this.CreateChildGroupElem(false, true);
  return dvt.Path.superclass.GetAriaElem.call(this);
};

// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Polygon displayable.
 * @param {dvt.Context} context
 * @param {array} arPoints The array of coordinates for this polygon, in the form [x1,y1,x2,y2...].
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {DvtPolygonalShape}
 * @class
 * @constructor
 */
dvt.Polygon = function(context, arPoints, id) {
  this.Init(context, arPoints, id);
};

dvt.Obj.createSubclass(dvt.Polygon, DvtPolygonalShape);


/**
 * @param {dvt.Context} context
 * @param {array} arPoints The array of coordinates for this polygon, in the form [x1,y1,x2,y2...].
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.Polygon.prototype.Init = function(context, arPoints, id) {
  dvt.Polygon.superclass.Init.call(this, context, 'polygon', arPoints, id);
};


/**
 * @override
 */
dvt.Polygon.prototype.copyShape = function()
{
  return new dvt.Polygon(this.getCtx(), this.getPoints());
};

/**
 * @override
 */
dvt.Polygon.prototype.GetAriaElem = function() {
  if (dvt.Agent.isTouchDevice())
    this.CreateChildGroupElem(false, true);
  return dvt.Polygon.superclass.GetAriaElem.call(this);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Polyline displayable.
 * @param {dvt.Context} context
 * @param {array} arPoints The array of coordinates for this polyline, in the form [x1,y1,x2,y2...].
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {DvtPolygonalShape}
 * @class
 * @constructor
 */
dvt.Polyline = function(context, arPoints, id) {
  this.Init(context, arPoints, id);
};

dvt.Obj.createSubclass(dvt.Polyline, DvtPolygonalShape);


/**
 * @param {dvt.Context} context
 * @param {array} arPoints The array of coordinates for this polyline, in the form [x1,y1,x2,y2...].
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.Polyline.prototype.Init = function(context, arPoints, id) {
  dvt.Polyline.superclass.Init.call(this, context, 'polyline', arPoints, id);
  dvt.ToolkitUtils.setAttrNullNS(this._elem, 'fill', 'none');
};


/**
 * @override
 */
dvt.Polyline.prototype.copyShape = function()
{
  return new dvt.Polyline(this.getCtx(), this.getPoints());
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Rectangle displayable.
 * @param {dvt.Context} context
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {string=} id The optional id for the corresponding DOM element.
 * @extends {dvt.Shape}
 * @class
 * @constructor
 */
dvt.Rect = function(context, x, y, w, h, id) {
  this.Init(context, x, y, w, h, id);
};

dvt.Obj.createSubclass(dvt.Rect, dvt.Shape);

dvt.Rect._cssAttrs = ['background-color', 'border-color', 'border-width'];


/**
 * @param {dvt.Context} context
 * @param {number} x
 * @param {number} Y
 * @param {number} w
 * @param {number} h
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.Rect.prototype.Init = function(context, x, y, w, h, id) {
  dvt.Rect.superclass.Init.call(this, context, 'rect', id);
  this.setX(x).setY(y).setWidth(w).setHeight(h);
};


/**
 * Returns the x coordinate of the rectangle.
 * @return {number}
 */
dvt.Rect.prototype.getX = function() {
  return this.GetProperty('x');
};


/**
 * Specifies the x coordinate of the rectangle.
 * @param {number} x
 * @return {dvt.Rect}
 */
dvt.Rect.prototype.setX = function(x) {
  return this.SetSvgProperty('x', x, 0);
};


/**
 * Returns the y coordinate of the rectangle.
 * @return {number}
 */
dvt.Rect.prototype.getY = function() {
  return this.GetProperty('y');
};


/**
 * Specifies the y coordinate of the rectangle.
 * @param {number} y
 * @return {dvt.Rect}
 */
dvt.Rect.prototype.setY = function(y) {
  return this.SetSvgProperty('y', y, 0);
};


/**
 * Returns the width of the rectangle.
 * @return {number}
 */
dvt.Rect.prototype.getWidth = function() {
  return this.GetProperty('width');
};


/**
 * Specifies the width of the rectangle.
 * @param {number} w
 * @return {dvt.Rect}
 */
dvt.Rect.prototype.setWidth = function(w) {
  // : Ensure property is defined in the DOM so that Batik doesn't crash.
  return this.SetSvgProperty('width', w != null ? w : 0);
};


/**
 * Returns the height of the rectangle.
 * @return {number}
 */
dvt.Rect.prototype.getHeight = function() {
  return this.GetProperty('height');
};


/**
 * Specifies the height of the rectangle.
 * @param {number} h
 * @return {dvt.Rect}
 */
dvt.Rect.prototype.setHeight = function(h) {
  // : Ensure property is defined in the DOM so that Batik doesn't crash.
  return this.SetSvgProperty('height', h != null ? h : 0);
};


/**
 * Returns the horizontal radius of the rounded corners, if any.
 * @return {number}
 */
dvt.Rect.prototype.getRx = function() {
  return this.GetProperty('rx');
};


/**
 * Specifies the horizontal radius of the rounded corners, if any.
 * @param {number} rx
 * @return {dvt.Rect}
 */
dvt.Rect.prototype.setRx = function(rx) {
  return this.SetSvgProperty('rx', rx);
};


/**
 * Returns the vertical radius of the rounded corners, if any.
 * @return {number}
 */
dvt.Rect.prototype.getRy = function() {
  return this.GetProperty('ry');
};


/**
 * Specifies the vertical radius of the rounded corners, if any.
 * @param {number} ry
 * @return {dvt.Rect}
 */
dvt.Rect.prototype.setRy = function(ry) {
  return this.SetSvgProperty('ry', ry);
};


/**
 * Sets the dvt.CSSStyle of this object.
 * @param {dvt.CSSStyle} style The dvt.CSSStyle of this object.
 */
dvt.Rect.prototype.setCSSStyle = function(style) {
  dvt.Rect.superclass.setCSSStyle.call(this, style);

  // TODO  CLEANUP: This code seems to apply to all shapes.  It's unclear why we only support it here.
  var elem = this._elem;
  if (style) {
    var val = style.getStyle('background-color');
    if (val) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'fill', val);
    }
    val = style.getStyle('border-color');
    if (val) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke', val);
    }
    val = style.getStyle('border-width');
    if (val) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-width', val);
    }

    // - border-radius css property not supported when used inside <dvt:node>
    val = style.getStyle('border-radius');
    if (val) {
      var radArr = dvt.StringUtils.trim(val).split(' ');
      if (radArr.length > 0 && radArr[0]) {
        this.setRx(radArr[0]);
      }
      if (radArr.length > 1 && radArr[1]) {
        this.setRy(radArr[1]);
      }
    }
  }
  else {
    dvt.ToolkitUtils.removeAttrNullNS(this._elem, 'style');
  }
};


/**
  *  Sets the top left position of the rectangle.
  *  @param {number} x  The <code>x</code> coordinate of the top left coordinate of the rectangle.
  *  @param {number} y  The <code>y</code> coordinate of the top left coordinate of the rectangle.
  */
dvt.Rect.prototype.setPos = function(x,y)
{
  this.setX(x).setY(y); // TODO  CLEANUP/NECESSARY?
};


/**
  *  Sets the corner radius value(s) to create rounded corners.
  *  @param {number} rx  The horizontal (x) radius.
  *  @param {number} ry  Optional: The vertical (y) radius. if omitted the rx
  *                      value is used.
  */
dvt.Rect.prototype.setCornerRadius = function(rx, ry)
{
  this.setRx(rx).setRy(ry); // TODO  CLEANUP/NECESSARY?
};


/**
  *  Sets the position and size of the rectangle.
  *  May be specified as individual values or using a dvt.Rectangle object.
  *  <p>
  *  Example<br><br><code>
  *  rect.setRect(10, 10, 50, 100) ; &nbsp;  or<br>
  *  <br>
  *  rect.setRect(myRect) ; &nbsp; &nbsp;  where myRect = new dvt.Rectangle(10, 10, 50, 100);<br>
  *
  *  @param {number} x  The x position of the top left corner of the rectangle.
  *  @param {number} y  The y position of the top left corner of the rectangle.
  *  @param {number} w  The width of the rectangle.
  *  @param {number} h  The height of the rectangle.
  */
dvt.Rect.prototype.setRect = function(x,y,w,h)
{
  // TODO  CLEANUP/NECESSARY?
  if (x instanceof dvt.Rectangle) {
    this.setX(x.x).setY(x.y).setWidth(x.w).setHeight(x.h);
  }
  else {
    this.setX(x).setY(y).setWidth(w).setHeight(h);
  }
};


/**
 * @override
 */
dvt.Rect.prototype.copyShape = function()
{
  var copy = new dvt.Rect(this.getCtx(), this.getX(), this.getY(), this.getWidth(), this.getHeight());
  copy.setRx(this.getRx()).setRy(this.getRy());
  return copy;
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.Rect.prototype.getDimensionsSelf = function(targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new dvt.Rectangle(this.getX(), this.getY(), this.getWidth(), this.getHeight());
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Creates an instance of dvt.OutputText.
 * @extends {dvt.Shape}
 * @class dvt.OutputText
 * @constructor
 * @param {dvt.Context} context
 * @param {string} textStr
 * @param {number} x
 * @param {number} y
 * @param {string} id
 */
dvt.OutputText = function(context, textStr, x, y, id) {
  this.Init(context, textStr, x, y, id);
};

dvt.Obj.createSubclass(dvt.OutputText, dvt.Shape);

/** @const */
dvt.OutputText.ELLIPSIS = '\u2026';
/** @const */
dvt.OutputText.REPRESENTATIVE_TEXT = 'MW';
/** @const */
dvt.OutputText.BIDI_ZERO_WIDTH = '\u200B';

// Horizontal Alignments
/** @const */
dvt.OutputText.H_ALIGN_LEFT = 'left';
/** @const */
dvt.OutputText.H_ALIGN_CENTER = 'center';
/** @const */
dvt.OutputText.H_ALIGN_RIGHT = 'right';

// Vertical Alignments
/** @const */
dvt.OutputText.V_ALIGN_TOP = 'top';
/** @const */
dvt.OutputText.V_ALIGN_MIDDLE = 'middle';
/** @const */
dvt.OutputText.V_ALIGN_BOTTOM = 'bottom';
/** @const */
dvt.OutputText.V_ALIGN_AUTO = 'auto';


/**
 * @param {dvt.Context} context
 * @param {string} textStr the text string
 * @param {number} x
 * @param {number} y
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.OutputText.prototype.Init = function(context, textStr, x, y, id) {
  dvt.OutputText.superclass.Init.call(this, context, 'text', id);

  // Attribute for IE alignment. This stores the component x position of the text.
  // In IE, only align start works properly for mixed LTR and RTL text, so we have to use align start and adjust
  // the x position in the DOM according to the alignment.
  this._x = (x != null) ? x : 0;

  // - NODE RENDERED INCORRECTLY IN IE9+
  this._baseline = null;

  // Initialize the alignment attrs.  Our impl defaults to start and baseline, so set the alignment if the defaults
  // don't match the impl defaults.
  this.alignLeft();
  this.alignTop();

  this.setTextString(textStr);
  this.setX(x);
  this.setY(y);

  // TODO : Remove this workaround and the incorrect none default in DvtSvgShape.
  // Workaround to remove some strange defaulting for the fill, which is set to none in DvtSvgShape.Init.
  dvt.ToolkitUtils.removeAttrNullNS(this.getElem(), 'fill');

  // Fix for 14297988: BIDI and mixed text in IE
  if (dvt.Agent.isRightToLeft(context) && dvt.Agent.isPlatformIE()) {
    dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'unicode-bidi', 'embed');
  }

  // By default, hide text from VoiceOver
  this.setAriaProperty('hidden', 'true');
};


/**
 * Returns the text string for this text object.
 * @return {string} the text string
 */
dvt.OutputText.prototype.getTextString = function() {
  return this._textString;
};


/**
 * Specifies the text string for this text object.
 * @param {string} textString the text string
 * @return {dvt.OutputText}
 */
dvt.OutputText.prototype.setTextString = function(textString) {
  // Trim because leading/trailing spaces are ignored by the browser, but they complicate text measurement.
  textString = (textString != null) ? dvt.StringUtils.trim(String(textString)) : '';

  // Add zero-width char to force correct alignment in RTL for IE.
  if (dvt.OutputText.needsTextAnchorAdjustment() && dvt.Agent.isPlatformIE() && textString.charAt(0) != dvt.OutputText.BIDI_ZERO_WIDTH)
    textString = dvt.OutputText.BIDI_ZERO_WIDTH + textString;

  this._textString = textString;

  // Update the text node if it is already created
  var textNode = this.getElem().firstChild;
  if (textNode !== null) {
    textNode.nodeValue = textString;//@HtmlUpdateOK
  }
  else {
    // Otherwise create it
    textNode = document.createTextNode(textString);
    dvt.ToolkitUtils.appendChildElem(this.getElem(), textNode);
  }

  if (dvt.Agent.isPlatformIE())
    this.setX(this._x); // readjust x position. IE text-anchor attribute is buggy.

  return this;
};


/**
 * Returns true if this text instance has been truncated.  When truncated, the getUntruncatedTextString function can be
 * used to find the full text String.
 * @return {boolean}
 */
dvt.OutputText.prototype.isTruncated = function() {
  return this.getUntruncatedTextString() != null;
};


/**
 * Returns the untruncated text string for this text object.  Returns null if the text string has not been truncated.
 * @return {string} the untruncated text string
 */
dvt.OutputText.prototype.getUntruncatedTextString = function() {
  return this._untruncatedTextString;
};


/**
 * Specifies the untruncated text string for this text object. This should only be set if the dvt.OutputText was
 * truncated by dvt.TextUtils.
 * @param {string} textString the untruncated text string
 */
dvt.OutputText.prototype.setUntruncatedTextString = function(textString) {
  if (textString != this.getTextString())
    this._untruncatedTextString = textString;
};


/**
 * Returns the x position for this text object.
 * @return {number} The x position.
 */
dvt.OutputText.prototype.getX = function() {
  var x;
  if (dvt.Agent.isPlatformIE())
    x = this._x; // return the component x
  else
    x = this.GetProperty('x');
  return x ? x : 0;
};


/**
 * Specifies the x position for this text object.
 * @param {number} x The x position
 * @return {dvt.OutputText}
 */
dvt.OutputText.prototype.setX = function(x) {
  this._x = (x != null) ? x : 0;
  if (dvt.Agent.isPlatformIE())
    return this.SetSvgProperty('x', this._x + this._getIEAlignmentOffset(), 0);
  else
    return this.SetSvgProperty('x', x, 0);
};


/**
 * Computes the x alignment offset for IE. The text-anchor attribute is buggy in IE, and only works correctly
 * if set to "start". Thus, for all other horizontal alignments, we use the "start" text-anchor and shift the
 * x position of the text in the DOM.
 * @return {number}
 * @private
 */
dvt.OutputText.prototype._getIEAlignmentOffset = function() {
  var align = this.getHorizAlignment();
  var isRTL = dvt.Agent.isRightToLeft();

  // Note that this.measureDimensions().w gets called at most once in the statement below.
  // Not assigning it to a var up front to avoid the perf hit in the two cases that just return zero.
  if (align == dvt.OutputText.H_ALIGN_LEFT)
    return isRTL ? this.measureDimensions().w : 0;
  else if (align == dvt.OutputText.H_ALIGN_CENTER)
    return isRTL ? this.measureDimensions().w / 2 : -this.measureDimensions().w / 2;
  else if (align == dvt.OutputText.H_ALIGN_RIGHT)
    return isRTL ? 0 : -this.measureDimensions().w;
};


/**
 * Returns the y position for this text object.
 * @return {number} The y position.
 */
dvt.OutputText.prototype.getY = function() {
  var y = this.GetProperty('y');
  return y ? y : 0;
};


/**
 * Specifies the y position for this text object.
 * @param {number} y The y position
 * @return {dvt.OutputText}
 */
dvt.OutputText.prototype.setY = function(y) {
  return this.SetSvgProperty('y', y, 0);
};


/**
 * Convenience function for specifying the font size. This function will clone the CSSStyle and apply it to the component.
 * @param {string} size The font-size which can be in the format '9', '9px', or 'xx-small'
 */
dvt.OutputText.prototype.setFontSize = function(size) {
  var style = this.getCSSStyle();
  style = style ? style.clone() : new dvt.CSSStyle();
  style.setFontSize(dvt.CSSStyle.FONT_SIZE, String(size));
  this.setCSSStyle(style);
};


/**
 * Returns the horizontal alignment for this text object.  Valid constants begin with dvt.OutputText.H_ALIGN_.
 * @return {string}
 */
dvt.OutputText.prototype.getHorizAlignment = function() {
  return this._horizAlign;
};


/**
 * Specifies the horizontal alignment for this text object.  Valid constants begin with dvt.OutputText.H_ALIGN_.
 * @param {string} align
 */
dvt.OutputText.prototype.setHorizAlignment = function(align) {
  if (align == dvt.OutputText.H_ALIGN_LEFT)
    this.alignLeft();
  else if (align == dvt.OutputText.H_ALIGN_CENTER)
    this.alignCenter();
  else if (align == dvt.OutputText.H_ALIGN_RIGHT)
    this.alignRight();
};


/**
 * Returns the vertical alignment for this text object.  Valid constants begin with dvt.OutputText.V_ALIGN_.
 * @return {string} The horizontal alignment
 */
dvt.OutputText.prototype.getVertAlignment = function() {
  return this._vertAlign;
};


/**
 * Specifies the vertical alignment for this text object.  Valid constants begin with dvt.OutputText.V_ALIGN_.
 * @param {string} align
 */
dvt.OutputText.prototype.setVertAlignment = function(align) {
  if (align == dvt.OutputText.V_ALIGN_TOP)
    this.alignTop();
  else if (align == dvt.OutputText.V_ALIGN_MIDDLE)
    this.alignMiddle();
  else if (align == dvt.OutputText.V_ALIGN_BOTTOM)
    this.alignBottom();
  else if (align == dvt.OutputText.V_ALIGN_AUTO)
    this.alignAuto();
};


/**
 * Aligns the left side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers a "start" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
dvt.OutputText.prototype.alignLeft = function() {
  // No change in value, return
  if (this._horizAlign == dvt.OutputText.H_ALIGN_LEFT)
    return;

  this._horizAlign = dvt.OutputText.H_ALIGN_LEFT;

  if (dvt.Agent.isPlatformIE()) {
    this.setX(this._x); // readjust x position. IE text-anchor attribute is buggy.
  }
  else {
    // : When html dir="rtl", Webkit and FF25+ treat the right side of the text as the start, and the left
    // side of the text as end.  Our API always treats the left side as start, so we need to adjust based on agent.
    var bAdjust = dvt.OutputText.needsTextAnchorAdjustment();
    dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'text-anchor', bAdjust ? 'end' : 'start', 'start');
  }
};


/**
 * Aligns the center of the text to the x coordinate.
 */
dvt.OutputText.prototype.alignCenter = function() {
  // No change in value, return
  if (this._horizAlign == dvt.OutputText.H_ALIGN_CENTER)
    return;

  this._horizAlign = dvt.OutputText.H_ALIGN_CENTER;

  if (dvt.Agent.isPlatformIE())
    this.setX(this._x); // readjust x position. IE text-anchor attribute is buggy.
  else
    dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'text-anchor', 'middle', 'start');
};


/**
 * Aligns the right side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers an "end" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
dvt.OutputText.prototype.alignRight = function() {
  // No change in value, return
  if (this._horizAlign == dvt.OutputText.H_ALIGN_RIGHT)
    return;

  this._horizAlign = dvt.OutputText.H_ALIGN_RIGHT;

  if (dvt.Agent.isPlatformIE()) {
    this.setX(this._x); // readjust x position. IE text-anchor attribute is buggy.
  }
  else {
    // : When html dir="rtl", Webkit and FF25+ treat the right side of the text as the start, and the left
    // side of the text as end.  Our API always treats the left side as start, so we need to adjust based on agent.
    var bAdjust = dvt.OutputText.needsTextAnchorAdjustment();
    dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'text-anchor', bAdjust ? 'start' : 'end', 'start');
  }
};


/**
 * Aligns the top of the text to the y coordinate.
 */
dvt.OutputText.prototype.alignTop = function() {
  // No change in value, return
  if (this._vertAlign == dvt.OutputText.V_ALIGN_TOP)
    return;
  else if (this._vertAlign == dvt.OutputText.V_ALIGN_BOTTOM && dvt.Agent.isBrowserSafari())
    this.SetBaseline(0);

  this._vertAlign = dvt.OutputText.V_ALIGN_TOP;

  // - NODE RENDERED INCORRECTLY IN IE9+
  if (dvt.Agent.isPlatformIE()) {
    //+ font-size
    this.SetBaseline(1);
  }
  else
    this.SetDominantBaselineAttr('text-before-edge');
};


/**
 * Aligns the middle of the text to the y coordinate.
 */
dvt.OutputText.prototype.alignMiddle = function() {
  // No change in value, return
  if (this._vertAlign == dvt.OutputText.V_ALIGN_MIDDLE)
    return;
  else if (this._vertAlign == dvt.OutputText.V_ALIGN_BOTTOM && dvt.Agent.isBrowserSafari())
    this.SetBaseline(0);

  this._vertAlign = dvt.OutputText.V_ALIGN_MIDDLE;

  // - NODE RENDERED INCORRECTLY IN IE9+
  if (dvt.Agent.isPlatformIE()) {
    //+ 2/5 font-size
    this.SetBaseline(.4);
  }
  else
    this.SetDominantBaselineAttr('middle');
};


/**
 * Aligns the bottom of the text to the y coordinate.
 */
dvt.OutputText.prototype.alignBottom = function() {
  // No change in value, return
  if (this._vertAlign == dvt.OutputText.V_ALIGN_BOTTOM)
    return;

  this._vertAlign = dvt.OutputText.V_ALIGN_BOTTOM;

  // - NODE RENDERED INCORRECTLY IN IE9+
  if (dvt.Agent.isPlatformIE()) {
    //- 1/5 font-size
    this.SetBaseline(-0.2);
  }
  else if (dvt.Agent.isBrowserSafari()) {
    // : Safari bottom text alignment is broken and produces middle alignment instead.
    this.SetBaseline(-0.2);
    this.SetDominantBaselineAttr(null);
  }
  else
    this.SetDominantBaselineAttr('text-after-edge');
};

/**
 * Aligns the bottom of the text based on default browser settings
 */
dvt.OutputText.prototype.alignAuto = function() {
  // No change in value, return
  if (this._vertAlign == dvt.OutputText.V_ALIGN_AUTO)
    return;
  else if (this._vertAlign == dvt.OutputText.V_ALIGN_BOTTOM && dvt.Agent.isBrowserSafari())
    this.SetBaseline(0);

  this._vertAlign = dvt.OutputText.V_ALIGN_AUTO;

  if (dvt.Agent.isPlatformIE())
    this.SetBaseline(0);
  else
    this.SetDominantBaselineAttr(null);
};

/**
 * Save the baseline and adjust the matrix for vertical alignment in IE.
 * @param {string} baseline
 * @protected
 */
dvt.OutputText.prototype.SetBaseline = function(baseline) {
  this._baseline = baseline;
  this.setMatrix(this.getMatrix());
};


/**
 * Set the dominant baseline for vertical alignment.
 * @param {string} baseline The value of the dominant-baseline attribute
 * @protected
 */
dvt.OutputText.prototype.SetDominantBaselineAttr = function(baseline) {
  if (baseline)
    dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'dominant-baseline', baseline);
  else
    dvt.ToolkitUtils.removeAttrNullNS(this.getElem(), 'dominant-baseline');
};


/**
 * Sets the dvt.CSSStyle of this object.
 * @param {dvt.CSSStyle} style The dvt.CSSStyle of this object.
 */
dvt.OutputText.prototype.setCSSStyle = function(style) {
  dvt.OutputText.superclass.setCSSStyle.call(this, style);
  var elem = this.getOuterElem();

  if (style) {
    //NOTE: svg does not recognize css "color" attribute, use "fill" instead
    var val = style.getStyle('color');
    var fillObj = dvt.ColorUtils.fixColorForPlatform(val);
    if (fillObj && fillObj['color']) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'fill', fillObj['color']);
      if (fillObj['alpha'] != null)
        dvt.ToolkitUtils.setAttrNullNS(elem, 'fill-opacity', fillObj['alpha'], 1);
    }

    val = style.getStyle('font-family');
    if (val && !this.getCtx().isDefaultFontFamily(val))
      dvt.ToolkitUtils.setAttrNullNS(elem, 'font-family', val);
    else
      dvt.ToolkitUtils.removeAttrNullNS(elem, 'font-family');

    val = style.getStyle('font-size');
    if (val && val != this.getCtx().getDefaultFontSize()) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'font-size', val);

      // - NODE RENDERED INCORRECTLY IN IE9+
      if (dvt.Agent.isPlatformIE() || dvt.Agent.isBrowserSafari()) {
        this.setMatrix(this.getMatrix());
      }
    }
    else
      dvt.ToolkitUtils.removeAttrNullNS(elem, 'font-size');

    val = style.getStyle('font-style');
    if (val) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'font-style', val);
    }

    val = style.getStyle('font-weight');
    if (val) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'font-weight', val);
    }

    //NOTE: svg does not recognize css "text-align" attribute,
    //call alignCenter, alignLeft, alignRight... if needed.
    //For multi line text, text-align is handled in DvtOutputTextArea
    val = style.getStyle('text-decoration');
    if (val) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'text-decoration', val);
    }

    val = style.getStyle('cursor');
    if (val) {
      dvt.ToolkitUtils.setAttrNullNS(elem, 'cursor', val);
    }

    if (dvt.Agent.isPlatformIE())
      this.setX(this._x); // readjust x position. IE text-anchor attribute is buggy.
  }
};


// - NODE RENDERED INCORRECTLY IN IE9+
/**
 * Returns the y translation used to compensate for IE's lack of dominant-baseline support
 * @return {number} the y translation
 * @private
 */
dvt.OutputText.prototype._getBaselineTranslation = function() {
  //if not in IE, no adjustment required
  var dy = 0;
  if (this._baseline != null) {
    var size;

    // Use text height for baseline translation if not representative text, else use font-size
    if (this._textString && !this._isRepresentativeText())
      size = dvt.TextUtils.getTextStringHeight(this.getCtx(), this.getCSSStyle());
    else {
      size = dvt.ToolkitUtils.getAttrNullNS(this.getElem(), 'font-size');

      if (!size)
        size = dvt.ToolkitUtils.getAttrNullNS(this.getOuterElem(), 'font-size');

      if (!size || (isNaN(size) && size.indexOf('px') == -1))
        size = dvt.StyleUtils.DEFAULT_FONT_SIZE;
    }

    dy = this._baseline * parseFloat(size);
  }
  return dy;
};


/**
 * Returns the specified matrix adjusted by the baseline (if any)
 * @param {dvt.Matrix} mat the matrix to adjust
 * @return {dvt.Matrix} the adjusted matrix
 * @private
 */
dvt.OutputText.prototype._getBaselineAdjustedMatrix = function(mat) {
  if (this._baseline != null) {
    // this._baseline is only set for IE
    if (!mat) {
      mat = new dvt.Matrix();
    }
    var nmat = new dvt.Matrix(null, null, null, null, null, this._getBaselineTranslation());
    nmat.concat(mat);
    mat = nmat;
  }
  return mat;
};


/**
 *  @override
 */
dvt.OutputText.prototype.setMatrix = function(mat) {
  if (dvt.Agent.isPlatformIE() || dvt.Agent.isBrowserSafari()) {
    this._matrixForIE = mat;
    mat = this._getBaselineAdjustedMatrix(mat);
  }
  dvt.OutputText.superclass.setMatrix.call(this, mat);
};


/**
 *  @override
 */
dvt.OutputText.prototype.getMatrix = function() {
  var matrix = null;
  if (dvt.Agent.isPlatformIE() || dvt.Agent.isBrowserSafari()) {
    matrix = this._matrixForIE;
  }
  if (!matrix) {
    matrix = dvt.OutputText.superclass.getMatrix.call(this);
  }
  return matrix;
};

/**
 * Checks if this textString is the representative text or the BIDI zero width character so that we only cache the size the first time.
 * @private
 * @return {boolean} is this a representative text
 */
dvt.OutputText.prototype._isRepresentativeText = function() {
  return (this._textString == dvt.OutputText.REPRESENTATIVE_TEXT) || (this._textString == dvt.OutputText.BIDI_ZERO_WIDTH) ||
         (this._textString == dvt.OutputText.BIDI_ZERO_WIDTH + dvt.OutputText.REPRESENTATIVE_TEXT);
};

/**
 * @override
 */
dvt.OutputText.prototype.GetSvgDimensions = function() { // TODO  target coord space would be broken here
  var bbox = dvt.OutputText.superclass.GetSvgDimensions.call(this);

  //  - NODE RENDERED INCORRECTLY IN IE9+
  if (bbox)
    bbox.y += this._getBaselineTranslation();

  //  - Japanese group label doesn't display in IE11
  if (!this._isRepresentativeText())
    bbox.h = dvt.TextUtils.getTextStringHeight(this.getCtx(), this.getCSSStyle());

  return bbox;
};


/**
 * @override
 */
dvt.OutputText.prototype.UpdateSelectionEffect = function() {
  // noop: Does not participate in selection effects
};


/**
 * Calculate the optimal text size based on the bounds provided.
 * @param {dvt.Rectangle} bounds The bounds to fit the label
 * @return {number}
 */
dvt.OutputText.prototype.getOptimalFontSize = function(bounds) {
  for (var i = Math.max(Math.min(bounds.w / this.getTextString().length, bounds.h / 2), 9); i < 51; i += 1) {
    this.setFontSize(i);
    var textDim = this.measureDimensions();
    if (textDim.w > bounds.w || textDim.h > bounds.h)
      return Math.min(i - 1, 50);
  }
  return 50;
};


/**
 * Optimized version of getDimensions.  Unlike getDimensions, this function will always returns useful dimensions,
 * adding the object to the DOM as needed.  The current implementation achieves improvements in performance by
 * storing the text calculations in a LRU cache, taking advantage of the fact that dimensions calculations do
 * not depend on container information.
 * @param {dvt.Displayable=} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the text
 */
dvt.OutputText.prototype.measureDimensions = function(targetCoordinateSpace) {
  // TODO : measureDimensions is now hooked into getDimensions, so it need not exist.  We can integrate into
  // getDimensions as soon as we have time to rename all usages.  The tricky part is just that DvtText also has a
  // measureDimensions call, so renames will need to be carefully done.
  var textString = this.getTextString() != null ? this.getTextString() : '';
  var hAlign = this.getHorizAlignment();
  var vAlign = this.getVertAlignment();

  // Initialize the cache if not done already.  The cache stores the stage relative dims of text at (0,0).
  if (!dvt.OutputText._cache)
    dvt.OutputText._cache = new dvt.Cache();

  // Create the key for cache, which is a combination of all attrs that affect dimensions calculations.
  var cssStyle = this.getCSSStyle();
  var cssStyleKey = (cssStyle != null) ? cssStyle.hashCodeForTextMeasurement() : '';
  var cacheKey = (textString.length > 0) ? textString + cssStyleKey : '';
  // cache dominant-baseline='auto' dimensions seperately
  if (vAlign === dvt.OutputText.V_ALIGN_AUTO)
    cacheKey += dvt.OutputText.V_ALIGN_AUTO;

  // Look for the value in the cache and add it if not found. Calculate the localDims.
  var localDims;
  var stageDims = dvt.OutputText._cache.get(cacheKey);
  if (stageDims != null) // Cache hit found, convert from stage coords to local and return.
    localDims = new dvt.Rectangle(stageDims.x + this.getX(), stageDims.y + this.getY(), stageDims.w, stageDims.h);
  else {
    var bRTL = dvt.Agent.isRightToLeft(this.getCtx());
    // No cache hit.  Find the stage coords and add to cache.
    // Adjust the alignment to top-left for text caching
    if (!dvt.Agent.isPlatformIE()) { // avoid infinite recursion in IE
      this.alignLeft();
    }
    else {
      if (bRTL) {
        // Force true left alignment to avoid storing incorrect values in the cache
        dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'unicode-bidi', null);
      }
    }
    if (vAlign !== dvt.OutputText.V_ALIGN_AUTO)
      this.alignTop();

    var attached = false;
    var stage = this.getCtx().getStage();
    var disp = this.getParent();
    while (disp) {
      if (disp == stage) {
        attached = true;
        break;
      }
      disp = disp.getParent();
    }

    if (attached) {
      // If we're already attached to the DOM, get the real local dimensions and cache the stage dimensions by removing
      // x and y offsets.
      localDims = this.GetSvgDimensions();
    }

    // For Firefox, localDims is null for disconnected elements
    if (!localDims)
      localDims = new dvt.Rectangle(0, 0, 0, 0);

    // If the object is not connected to the DOM, it will return incorrect size of 0.
    if (localDims.w <= 0 && localDims.h <= 0 && textString.length > 0) {
      // Saves the parent and the index
      var parent = this.getParent();
      var index;
      if (parent) {
        index = parent.getChildIndex(this);
      }
      // Add to the stage to obtain correct measurements
      stage.addChild(this);
      localDims = this.GetSvgDimensions();
      stage.removeChild(this);
      // Restore the parent
      if (parent) {
        parent.addChildAt(this, index);
      }
    }

    // Restore the alignment
    if (dvt.Agent.isPlatformIE()) { // avoid infinite recursion in IE
      if (bRTL) {
        dvt.ToolkitUtils.setAttrNullNS(this.getElem(), 'unicode-bidi', 'embed');
      }

      // Adjust the dimensions that's stored in the cache so that it's the alignLeft value
      if (hAlign === dvt.OutputText.H_ALIGN_RIGHT) {
        localDims.x += localDims.w;
      }
      else if (hAlign === dvt.OutputText.H_ALIGN_CENTER) {
        localDims.x += localDims.w / 2;
      }
    }
    else {
      this.setHorizAlignment(hAlign);
    }
    this.setVertAlignment(vAlign);

    // Convert to stage dims by removing own x and y.
    stageDims = new dvt.Rectangle(localDims.x - this.getX(), localDims.y - this.getY(), localDims.w, localDims.h);
    dvt.OutputText._cache.put(cacheKey, stageDims);
  }

  // Adjust dimensions for text alignment.  We do this because we don't take alignment into account in the cache, and
  // also because browsers return inconsistently calculated dimensions based on alignment.
  if (hAlign === dvt.OutputText.H_ALIGN_RIGHT)
    localDims.x -= localDims.w;
  else if (hAlign === dvt.OutputText.H_ALIGN_CENTER)
    localDims.x -= localDims.w / 2;

  if (vAlign === dvt.OutputText.V_ALIGN_BOTTOM)
    localDims.y -= localDims.h;
  else if (vAlign === dvt.OutputText.V_ALIGN_MIDDLE)
    localDims.y -= localDims.h / 2;

  // Transform to the target coord space and return
  return (!targetCoordinateSpace || targetCoordinateSpace === this) ? localDims : this.ConvertCoordSpaceRect(localDims, targetCoordinateSpace);
};


/**
 * @override
 */
dvt.OutputText.prototype.copyShape = function() {
  var ret = new dvt.OutputText(this.getCtx(), this.getTextString(), this.getX(), this.getY());
  ret.setCSSStyle(this.getCSSStyle());
  ret.setHorizAlignment(this.getHorizAlignment());
  ret.setVertAlignment(this.getVertAlignment());
  return ret;
};


/**
 * @override
 */
dvt.OutputText.prototype.addChild = function(obj) {
  // Prevent this class from being used as a shape container.  It's bad practice and doesn't make sense.  Placeholder
  // until the shape container APIs are removed altogether.
  if (dvt.Agent.isEnvironmentTest()) {
    print('dvt.OutputText.prototype.addChild: Text should not be used as a shape container.');
    var nullObj = null;
    nullObj.errorShouldOccurDueToInvalidAddChild();
  }
};


/**
 * Returns true if the text anchor needs to be flipped from "start" to "end" and vice versa.
 * @return {boolean}
 */
dvt.OutputText.needsTextAnchorAdjustment = function() {
  // : When html dir="rtl", theright side of the text is treated as the start, and the left as the end. Our
  // API always treats the left side as start, so we need to adjust based on agent.
  // Don't adjust anchor in Batik environment.
  return dvt.Agent.isRightToLeft() && !dvt.Agent.isEnvironmentBatik();
};


/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the displayable relative to the target coordinate space.
 */
dvt.OutputText.prototype.getDimensionsSelf = function(targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  return this.measureDimensions(targetCoordinateSpace);
};

/**
 * Returns the cached text dimensions for a textString and cssStyle, or null if no cached size is available.
 * @param {string} textString
 * @param {dvt.CSSStyle} cssStyle
 * @return {dvt.Rectangle} The text dimensions. Only the w and h should be used. The x and y are meaningless.
 */
dvt.OutputText.getCachedDimensions = function(textString, cssStyle) {
  // Create the key for cache, which is a combination of all attrs that affect dimensions calculations.
  var cssStyleKey = (cssStyle != null) ? cssStyle.hashCodeForTextMeasurement() : '';
  var cacheKey = (textString.length > 0) ? textString + cssStyleKey : '';

  // Look for the value in the cache and return it if found or null otherwise.
  return dvt.OutputText._cache ? dvt.OutputText._cache.get(cacheKey) : null;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Creates an instance of dvt.BackgroundOutputText.
 * @extends {dvt.Container}
 * @class dvt.BackgroundOutputText
 * @constructor
 * @param {dvt.Context} context
 * @param {string} textStr
 * @param {number} x
 * @param {number} y
 * @param {dvt.CSSStyle} style The CSS style to be applied to the text and background
 * @param {string} id
 */
dvt.BackgroundOutputText = function(context, textStr, x, y, style, id) {
  this.Init(context, textStr, x, y, style, id);
};

dvt.Obj.createSubclass(dvt.BackgroundOutputText, dvt.Container);

/**
 * @const
 * @private
 */
dvt.BackgroundOutputText._PADDING = 0.15;
/**
 * @param {dvt.Context} context
 * @param {string} textStr the text string
 * @param {number} x
 * @param {number} y
 * @param {dvt.CSSStyle} style The CSS style to be applied to the text and background
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.BackgroundOutputText.prototype.Init = function(context, textStr, x, y, style, id) {
  dvt.BackgroundOutputText.superclass.Init.call(this, context, 'g', id);

  this.TextInstance = this.CreateTextInstance(context, textStr, x, y, id);
  this._backgroundRect = null;
  if (style)
    this.setCSSStyle(style);
  this.addChild(this.TextInstance);
};

/**
 * Returns the text string for this text object.
 * @return {string} the text string
 */
dvt.BackgroundOutputText.prototype.getTextString = function() {
  return this.TextInstance.getTextString();
};


/**
 * Specifies the text string for this text object.
 * @param {string} textString the text string
 * @return {dvt.BackgroundOutputText}
 */
dvt.BackgroundOutputText.prototype.setTextString = function(textString) {
  this.TextInstance.setTextString(textString);
  return this;
};


/**
 * Returns true if this text instance has been truncated.  When truncated, the getUntruncatedTextString function can be
 * used to find the full text String.
 * @return {boolean}
 */
dvt.BackgroundOutputText.prototype.isTruncated = function() {
  return this.TextInstance.isTruncated();
};


/**
 * Returns the untruncated text string for this text object.  Returns null if the text string has not been truncated.
 * @return {string} the untruncated text string
 */
dvt.BackgroundOutputText.prototype.getUntruncatedTextString = function() {
  return this.TextInstance.getUntruncatedTextString();
};


/**
 * Specifies the untruncated text string for this text object. This should only be set if the dvt.OutputText was
 * truncated by dvt.TextUtils.
 * @param {string} textString the untruncated text string
 */
dvt.BackgroundOutputText.prototype.setUntruncatedTextString = function(textString) {
  this.TextInstance.setUntruncatedTextString(textString);
};


/**
 * Returns the x position for this text object.
 * @return {number} The x position.
 */
dvt.BackgroundOutputText.prototype.getX = function() {
  return this.TextInstance.getX();
};


/**
 * Specifies the x position for this text object.
 * @param {number} x The x position
 * @return {dvt.BackgroundOutputText}
 */
dvt.BackgroundOutputText.prototype.setX = function(x) {
  this.TextInstance = this.TextInstance.setX(x);
  this._realignBackground();
  return this;
};

/**
 * Returns the y position for this text object.
 * @return {number} The y position.
 */
dvt.BackgroundOutputText.prototype.getY = function() {
  return this.TextInstance.getY();
};


/**
 * Specifies the y position for this text object.
 * @param {number} y The y position
 * @return {dvt.BackgroundOutputText}
 */
dvt.BackgroundOutputText.prototype.setY = function(y) {
  this.TextInstance = this.TextInstance.setY(y);
  this._realignBackground();
  return this;
};


/**
 * Convenience function for specifying the font size. This function will clone the CSSStyle and apply it to the component.
 * @param {string} size The font-size which can be in the format '9', '9px', or 'xx-small'
 */
dvt.BackgroundOutputText.prototype.setFontSize = function(size) {
  this.TextInstance.setFontSize(size);
  // Also update the local copy of DvtCssStyle
  this._style.setFontSize(dvt.CSSStyle.FONT_SIZE, String(size));
  this._realignBackground();
};


/**
 * Returns the horizontal alignment for this text object.  Valid constants begin with dvt.OutputText.H_ALIGN_.
 * @return {string}
 */
dvt.BackgroundOutputText.prototype.getHorizAlignment = function() {
  return this.TextInstance.getHorizAlignment();
};


/**
 * Specifies the horizontal alignment for this text object.  Valid constants begin with dvt.OutputText.H_ALIGN_.
 * @param {string} align
 */
dvt.BackgroundOutputText.prototype.setHorizAlignment = function(align) {
  this.TextInstance.setHorizAlignment(align);
  this._realignBackground();
};


/**
 * Returns the vertical alignment for this text object.  Valid constants begin with dvt.OutputText.V_ALIGN_.
 * @return {string} The horizontal alignment
 */
dvt.BackgroundOutputText.prototype.getVertAlignment = function() {
  return this.TextInstance.getVertAlignment();
};


/**
 * Specifies the vertical alignment for this text object.  Valid constants begin with dvt.OutputText.V_ALIGN_.
 * @param {string} align
 */
dvt.BackgroundOutputText.prototype.setVertAlignment = function(align) {
  this.TextInstance.setVertAlignment(align);
  this._realignBackground();
};


/**
 * Aligns the left side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers a "start" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
dvt.BackgroundOutputText.prototype.alignLeft = function() {
  this.TextInstance.alignLeft();
  this._realignBackground();
};


/**
 * Aligns the center of the text to the x coordinate.
 */
dvt.BackgroundOutputText.prototype.alignCenter = function() {
  this.TextInstance.alignCenter();
  this._realignBackground();
};


/**
 * Aligns the right side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers an "end" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
dvt.BackgroundOutputText.prototype.alignRight = function() {
  this.TextInstance.alignRight();
  this._realignBackground();
};


/**
 * Aligns the top of the text to the y coordinate.
 */
dvt.BackgroundOutputText.prototype.alignTop = function() {
  this.TextInstance.alignTop();
  this._realignBackground();
};


/**
 * Aligns the middle of the text to the y coordinate.
 */
dvt.BackgroundOutputText.prototype.alignMiddle = function() {
  this.TextInstance.alignMiddle();
  this._realignBackground();
};


/**
 * Aligns the bottom of the text to the y coordinate.
 */
dvt.BackgroundOutputText.prototype.alignBottom = function() {
  this.TextInstance.alignBottom();
  this._realignBackground();
};

/**
 * Aligns the bottom of the text to the y coordinate.
 */
dvt.BackgroundOutputText.prototype.alignAuto = function() {
  this.TextInstance.alignAuto();
  this._realignBackground();
};

/**
 * Sets the dvt.CSSStyle of this object.
 * @param {dvt.CSSStyle} style The dvt.CSSStyle of this object.
 * @override
 */
dvt.BackgroundOutputText.prototype.setCSSStyle = function(style) {
  // support automatic text color for text with backgrounds
  if (style.getStyle(dvt.CSSStyle.BACKGROUND_COLOR) && !style.getStyle(dvt.CSSStyle.COLOR))
    style.setStyle(dvt.CSSStyle.COLOR, dvt.ColorUtils.getContrastingTextColor(style.getStyle(dvt.CSSStyle.BACKGROUND_COLOR)));

  if (this.TextInstance)
    this.TextInstance.setCSSStyle(style);

  if (this._backgroundRect || dvt.BackgroundOutputText._hasBackgroundStyles(style)) {
    if (!this._backgroundRect) {
      this._backgroundRect = this.CreateBackground(this.getCtx(), this.TextInstance);
      this.addChildAt(this._backgroundRect, 0);
    }
    this._setBackgroundCSSStyle(this._backgroundRect, style);
  }

  this._style = style;
};

/**
 * Returns the dvt.CSSStyle of this object.
 * @return {dvt.CSSStyle} the dvt.CSSStyle of this object.
 * @override
 */
dvt.BackgroundOutputText.prototype.getCSSStyle = function() {
  return this._style;
};

/**
 *  @override
 */
dvt.BackgroundOutputText.prototype.setMatrix = function(mat) {
  this.TextInstance.setMatrix(mat);

  if (this._backgroundRect)
    this._backgroundRect.setMatrix(mat);
};


/**
 *  @override
 */
dvt.BackgroundOutputText.prototype.getMatrix = function() {
  return this.TextInstance.getMatrix();
};


/**
 * Calculate the optimal text size based on the bounds provided.
 * @param {dvt.Rectangle} bounds The bounds to fit the label
 * @return {number}
 */
dvt.BackgroundOutputText.prototype.getOptimalFontSize = function(bounds) {
  return this.TextInstance.getOptimalFontSize(bounds);
};


/**
 * Optimized version of getDimensions.  Unlike getDimensions, this function will always returns useful dimensions,
 * adding the object to the DOM as needed.  The current implementation achieves improvements in performance by
 * storing the text calculations in a LRU cache, taking advantage of the fact that dimensions calculations do
 * not depend on container information.
 * @param {dvt.Displayable=} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the text
 */
dvt.BackgroundOutputText.prototype.measureDimensions = function(targetCoordinateSpace) {
  return this.getDimensions(targetCoordinateSpace);
};

/**
 * Returns the bounds of the output text relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {dvt.Rectangle} The bounds of the output text relative to the target coordinate space.
 */
dvt.BackgroundOutputText.prototype.getTextDimensions = function(targetCoordinateSpace) {
  return this.TextInstance.getDimensions(targetCoordinateSpace);
};

/**
 * @override
 */
dvt.BackgroundOutputText.prototype.getDimensions = function(targetCoordinateSpace) {
  // include the bounds of the rectangle background for the dimensions
  var dims = this.TextInstance.getDimensions(targetCoordinateSpace);
  var padding = dims.h * dvt.BackgroundOutputText._PADDING;
  dims.x -= padding;
  dims.w += (2 * padding);
  return dims;
};

/**
 * @override
 */
dvt.BackgroundOutputText.prototype.copyShape = function() {
  return this.TextInstance.copyShape();
};


/**
 * @this {dvt.BackgroundOutputText}
 * Returns true if the text anchor needs to be flipped from "start" to "end" and vice versa.
 * @param {dvt.Context} context
 * @return {boolean}
 */
dvt.BackgroundOutputText.needsTextAnchorAdjustment = function(context) {
  return this.TextInstance.needsTextAnchorAdjustment(context);
};

/**
 * @this {dvt.BackgroundOutputText}
 * Returns the cached text dimensions for a textString and cssStyle, or null if no cached size is available.
 * @param {string} textString
 * @param {dvt.CSSStyle} cssStyle
 * @return {dvt.Rectangle} The text dimensions. Only the w and h should be used. The x and y are meaningless.
 */
dvt.BackgroundOutputText.getCachedDimensions = function(textString, cssStyle) {
  return this.TextInstance.getCachedDimensions(textString, cssStyle);
};

/**
 * Creates and returns the text object for the dvt.BackgroundOutputText object
 * @param {dvt.Context} context
 * @param {string} textStr the text string
 * @param {number} x
 * @param {number} y
 * @param {string=} id The optional id for the corresponding DOM element.
 * @return {dvt.Displayable}
 * @protected
 */
dvt.BackgroundOutputText.prototype.CreateTextInstance = function(context, textStr, x, y, id) {
  return new dvt.OutputText(context, textStr, x, y, id);
};


/**
 * Returns an object with the background styles of the output text applied
 * @param {dvt.Context} context
 * @param {dvt.OutputText} text The output text.
 * @return {dvt.Rect} The object to be rendered behind the text.
 * @protected
 */
dvt.BackgroundOutputText.prototype.CreateBackground = function(context, text) {
  var bboxDims = text.getDimensions();
  var padding = bboxDims.h * dvt.BackgroundOutputText._PADDING;
  return new dvt.Rect(context, bboxDims.x - padding, bboxDims.y, bboxDims.w + (2 * padding), bboxDims.h);
};

/**
 * Realigns the background rect with the text
 * @private
 */
dvt.BackgroundOutputText.prototype._realignBackground = function() {
  if (!this._backgroundRect)
    return;

  var bboxDims = this.TextInstance.getDimensions();
  var padding = bboxDims.h * 0.15;

  var hAlign = this.getHorizAlignment();
  var vAlign = this.getVertAlignment();

  // Align x-Coordinate
  if (hAlign == dvt.OutputText.H_ALIGN_LEFT)
    this._backgroundRect.setX(this.getX() - padding);
  else if (hAlign == dvt.OutputText.H_ALIGN_CENTER)
    this._backgroundRect.setX(this.getX() - bboxDims.w * 0.5 - padding);
  else if (hAlign == dvt.OutputText.H_ALIGN_RIGHT)
    this._backgroundRect.setX(this.getX() - bboxDims.w - padding);

  // Align y-Coordinate
  var fontSize = parseFloat(this._style.getFontSize());
  if (isNaN(fontSize))
    fontSize = 0;
  var yAdjustment = 0; // fudge factor for specific alignments in certain browsers

  if ((dvt.Agent.isBrowserChrome() || dvt.Agent.isEnvironmentTest()) && vAlign == dvt.OutputText.V_ALIGN_MIDDLE)
    yAdjustment = fontSize * 0.12; // Chrome, vALign = middle, rect must be shifted up a bit
  else if (dvt.Agent.isPlatformIE() && vAlign == dvt.OutputText.V_ALIGN_BOTTOM)
    yAdjustment = -fontSize * 0.4; // IE, vAlign = bottom, rect must be shifted down a bit

  var deltaH = this.GetTextDimensionsForRealign(bboxDims);
  if (vAlign == dvt.OutputText.V_ALIGN_TOP)
    this._backgroundRect.setY(this.getY());
  else if (vAlign == dvt.OutputText.V_ALIGN_MIDDLE)
    this._backgroundRect.setY(this.getY() - deltaH * 0.5 - yAdjustment);
  else if (vAlign == dvt.OutputText.V_ALIGN_BOTTOM)
    this._backgroundRect.setY(this.getY() - deltaH - yAdjustment);
  else if (vAlign == dvt.OutputText.V_ALIGN_AUTO)
    this._backgroundRect.setY(bboxDims.y);

  // width may need to be reset (rotated labels ended up extra long)
  this._backgroundRect.setWidth(bboxDims.w + 2 * padding);
  this._backgroundRect.setHeight(bboxDims.h);

};

/**
 * Sets the dvt.CSSStyle of the given background rect.
 * @param {dvt.Rect} rect The background dvt.Rect
 * @param {dvt.CSSStyle} style The dvt.CSSStyle of this object.
 * @private
 */
dvt.BackgroundOutputText.prototype._setBackgroundCSSStyle = function(rect, style) {
  if (style) {
    var bgColor = style.getStyle(dvt.CSSStyle.BACKGROUND_COLOR);
    if (bgColor != null)
      rect.setSolidFill(bgColor);
    else
      rect.setInvisibleFill();

    var borderColor = style.getStyle(dvt.CSSStyle.BORDER_COLOR);
    var borderWidth = style.getStyle(dvt.CSSStyle.BORDER_WIDTH);
    var borderRadius = style.getStyle(dvt.CSSStyle.BORDER_RADIUS);
    if (borderColor || borderWidth || borderRadius) {
      var bgStyle = new dvt.CSSStyle();
      bgStyle.setStyle(dvt.CSSStyle.BORDER_COLOR, borderColor);
      bgStyle.setStyle(dvt.CSSStyle.BORDER_WIDTH, borderWidth);
      bgStyle.setStyle(dvt.CSSStyle.BORDER_RADIUS, borderRadius);
      rect.setCSSStyle(bgStyle);
    }

  }
  else {
    rect.setInvisibleFill();
  }

  rect.setMouseEnabled(false);
};

/**
 * Returns the change in height needed to realign the background rect after the text instance is realigned
 * @param {Object=} dims
 * @return {number}
 * @protected
 */
dvt.BackgroundOutputText.prototype.GetTextDimensionsForRealign = function(dims) {
  return dims.h;
};

/**
 * returns true if style has any of the background styles
 * set by dvt.BackgroundOutputText.prototype._setBackgroundCSSStyle
 * @private
 * @param {dvt.CSSStyle} style the styles of the background text
 * @return {boolean} true if style has any of the background styles
 */
dvt.BackgroundOutputText._hasBackgroundStyles = function(style) {
  if (!style) {
    return false;
  }
  if (style.getStyle(dvt.CSSStyle.BORDER_COLOR) || style.getStyle(dvt.CSSStyle.BORDER_WIDTH) ||
      style.getStyle(dvt.CSSStyle.BORDER_RADIUS) || style.getStyle(dvt.CSSStyle.BACKGROUND_COLOR))
    return true;
  return false;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Read-only text object that supports wrapping.
 * @extends {dvt.Container}
 * @class dvt.MultilineText
 * @constructor
 * @param {dvt.Context} context
 * @param {string} textStr
 * @param {number} x
 * @param {number} y
 * @param {string} id
 */
dvt.MultilineText = function(context, textStr, x, y, id) {
  this.Init(context, textStr, x, y, id);
};

dvt.Obj.createSubclass(dvt.MultilineText, dvt.Container);


/**
 * The space between lines expressed as a percentage of line height.
 * @private
 */
dvt.MultilineText._LINE_SPACE = 0;

// Horizontal Alignments
/** @const */
dvt.MultilineText.H_ALIGN_LEFT = 'left';
/** @const */
dvt.MultilineText.H_ALIGN_CENTER = 'center';
/** @const */
dvt.MultilineText.H_ALIGN_RIGHT = 'right';

// Vertical Alignments
/** @const */
dvt.MultilineText.V_ALIGN_TOP = 'top';
/** @const */
dvt.MultilineText.V_ALIGN_MIDDLE = 'middle';
/** @const */
dvt.MultilineText.V_ALIGN_BOTTOM = 'bottom';


/**
 * @param {dvt.Context} context
 * @param {string} textStr the text string
 * @param {number} x
 * @param {number} y
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.MultilineText.prototype.Init = function(context, textStr, x, y, id) {
  dvt.MultilineText.superclass.Init.call(this, context, null, id);

  /**
   * The primary text instance.  All properties are stored here.  If dvt.TextUtils.fitText is not called, the text will
   * appear as a single line using this instance.
   * @private
   */
  this._textInstance = null;

  /**
   * Any additional lines of text resulting from text wrapping.
   * @private
   */
  this._additionalLines = [];

  /** The height of a line of text.
   *  Useful for estimating or reserving vertical space for wrapped text
   *  @private
   */
  this._lineHeight = null;

  /** Store the yCoordinate set on the text.
   * getY() returns ycoordinate of primary text instance.
   * getYAlignCoord() returns ycoordinate used for vertical alignment
   * @private
   */
  this._yCoord = null;

  /** Flag for optimizing attempts to fit a MultilineText object.
   *  A layout algorithm can set the value to true if it figures out
   *  that it will not be possible to fit more than one line of text
   *  in the space available for the text.
   *  @private
   */
  this._noWrap = false;

  // Apply properties
  this.setTextString(textStr);
  this.setX(x ? x : 0);
  this.setY(y ? y : 0);
  this.setMaxLines(Infinity);
};

/**
 * Returns the text string for this text object.  Unlike the implementation on dvt.OutputText, this always returns the
 * full and untruncated text string.
 * @return {string} the text string
 */
dvt.MultilineText.prototype.getTextString = function() {
  return this._textString;
};

/**
 * Specifies the text string for this text object.
 * @param {string} textString the text string
 */
dvt.MultilineText.prototype.setTextString = function(textString) {
  // Store the full string
  this._textString = (textString != null) ? String(textString) : null;

  // Update the text instances
  if (!this._textInstance) {
    // Create the primary text instance.  This instance is used to store all properties.
    this._textInstance = new dvt.OutputText(this.getCtx(), this._textString);
    this.addChild(this._textInstance);
  }
  else {
    this._textInstance.setTextString(textString);

    // Remove any additional text lines
    this._removeAdditionalLines();
  }

  // Since this is a new text string, truncation has not occurred
  this._bTruncated = false;
};

/**
 * Returns an array with pointers to all the lines in this dvt.MultilineText object
 * @return {Array} the lines in this object.
 * @private
 */
dvt.MultilineText.prototype._getTextLines = function() {
  var lines = this._additionalLines.slice();
  // Add this._textInstance unless it was removed by a fitText call
  if (this._textInstance.getParent() == this) {
    lines.unshift(this._textInstance);
  }
  return lines;
};

/**
 * Returns the x position for this text object.
 * @return {number} The x position.
 */
dvt.MultilineText.prototype.getX = function() {
  return this._textInstance.getX();
};


/**
 * Specifies the x position for this text object.
 * @param {number} x The x position
 * @return {dvt.MultilineText}
 */
dvt.MultilineText.prototype.setX = function(x) {
  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) { entry.setX(x)});
  return this;
};


/**
 * Returns the y position for the primary instance of this text object.
 * @return {number} The y position.
 */
dvt.MultilineText.prototype.getY = function() {
  return this._textInstance.getY();
};

/** Returns the y position used for vertical alignment
 *  @return {number} The y position.
 */
dvt.MultilineText.prototype.getYAlignCoord = function() {
  return this._yCoord;
};

/**
 * Specifies the y position for this text object.
 * @param {number} y The y position
 * @return {dvt.MultilineText}
 */
dvt.MultilineText.prototype.setY = function(y) {
  this._yCoord = y;

  // If not using vertical align, use default alignment for the multiline text
  if (!this._vertAlign) {
    var yChange = y - this._textInstance.getY();
    if (!yChange)
      yChange = y;
    dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) { var yLine = entry.getY(); entry.setY(yLine ? yLine + yChange : yChange)});
  }
  else // Align each entry in reference to the yCoord based on it's alignment
    this._alignVerticalText();

  return this;
};


/**
 * Returns the y position for this text object.
 * @return {number} The y position.
 */
dvt.MultilineText.prototype.getMaxLines = function() {
  return this.GetProperty('maxLines');
};


/**
 * Specifies the maximum number of lines to display when wrapped. Defaults to Infinity.
 * @param {number} maxLines
 * @return {dvt.MultilineText}
 */
dvt.MultilineText.prototype.setMaxLines = function(maxLines) {
  // Ignore values of 0 or less
  if (maxLines > 0)
    return this.SetProperty('maxLines', maxLines);
};


/**
 * Returns true if this text instance has been truncated.
 * @return {boolean}
 */
dvt.MultilineText.prototype.isTruncated = function() {
  return this._bTruncated;
};


/**
 * Returns the horizontal alignment for this text object.  Valid constants begin with dvt.OutputText.H_ALIGN_.
 * @return {string}
 */
dvt.MultilineText.prototype.getHorizAlignment = function() {
  return this._textInstance.getHorizAlignment();
};


/**
 * Specifies the horizontal alignment for this text object.  Valid constants begin with dvt.OutputText.H_ALIGN_.
 * @param {string} align
 * @return {dvt.MultilineText}
 */
dvt.MultilineText.prototype.setHorizAlignment = function(align) {
  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) { entry.setHorizAlignment(align)});
  return this;
};


/**
 * Aligns the left side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers a "start" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
dvt.MultilineText.prototype.alignLeft = function() {
  // No change in value, return
  if (this._horizAlign == dvt.MultilineText.H_ALIGN_LEFT)
    return;

  this._horizAlign = dvt.MultilineText.H_ALIGN_LEFT;

  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) { entry.alignLeft()});
};


/**
 * Aligns the center of the text to the x coordinate.
 */
dvt.MultilineText.prototype.alignCenter = function() {
  // No change in value, return
  if (this._horizAlign == dvt.MultilineText.H_ALIGN_CENTER)
    return;

  this._horizAlign = dvt.MultilineText.H_ALIGN_CENTER;

  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) { entry.alignCenter()});
};


/**
 * Aligns the right side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers an "end" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
dvt.MultilineText.prototype.alignRight = function() {
  // No change in value, return
  if (this._horizAlign == dvt.MultilineText.H_ALIGN_RIGHT)
    return;

  this._horizAlign = dvt.MultilineText.H_ALIGN_RIGHT;

  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) { entry.alignRight()});
};

/**
 * Aligns the top side of the full text object to the y coordinate.
 */
dvt.MultilineText.prototype.alignTop = function() {
  // No change in value, return
  if (this._vertAlign == dvt.MultilineText.V_ALIGN_TOP)
    return;

  this._vertAlign = dvt.MultilineText.V_ALIGN_TOP;

  this._alignVerticalText();
  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) {
    entry.alignTop();
  });

  return;
};


/**
 * Aligns the middle of the full text object to the y coordinate.
 */
dvt.MultilineText.prototype.alignMiddle = function() {
  // No change in value, return
  if (this._vertAlign == dvt.MultilineText.V_ALIGN_MIDDLE)
    return;

  this._vertAlign = dvt.MultilineText.V_ALIGN_MIDDLE;

  this._alignVerticalText();
  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) {
    entry.alignMiddle();
  });

  return;
};

/**
 *  Aligns the bottom side of the full text object to the y coordinate.
 */
dvt.MultilineText.prototype.alignBottom = function() {
  // No change in value, return
  if (this._vertAlign == dvt.MultilineText.V_ALIGN_BOTTOM)
    return;

  this._vertAlign = dvt.MultilineText.V_ALIGN_BOTTOM;

  this._alignVerticalText();
  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) {
    entry.alignBottom();
  });

  return;
};

/**
 * Sets y coordinates for each text line such that the full text object is aligned in reference to the y coordinate
 * @private
 */
dvt.MultilineText.prototype._alignVerticalText = function() {
  if (!this._vertAlign)
    return;

  var yCoord = this.getYAlignCoord();
  var lineCount = this.getLineCount();
  var lineHeight = this.getLineHeight();
  var textLines = this._getTextLines();
  var adjustment = 0;

  for (var i = 0; i < textLines.length; i++) {
    var entry = textLines[i];

    if (this._vertAlign == dvt.MultilineText.V_ALIGN_TOP)
      adjustment = lineHeight * i;
    else if (this._vertAlign == dvt.MultilineText.V_ALIGN_MIDDLE) {
      var range = lineHeight * (lineCount - 1);
      adjustment = (lineHeight * i) - (range / 2);
    }
    else if (this._vertAlign == dvt.MultilineText.V_ALIGN_BOTTOM)
      adjustment = -lineHeight * (lineCount - i - 1);

    entry.setY(yCoord + adjustment);
  }
};

/**
 * Returns the dvt.CSSStyle for this object.
 * @return {dvt.CSSStyle} The dvt.CSSStyle of this object.
 */
dvt.MultilineText.prototype.getCSSStyle = function() {
  return this._textInstance.getCSSStyle();
};


/**
 * Sets the dvt.CSSStyle of this object. If the dvt.CSSStyle is changed, then dvt.TextUtils.fitText must be called again, as the previous multi-line layouts will not be valid.
 * @param {dvt.CSSStyle} style The dvt.CSSStyle of this object.
 * @return {dvt.MultilineText}
 */
dvt.MultilineText.prototype.setCSSStyle = function(style) {
  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) { entry.setCSSStyle(style)});
  return this;
};


/**
 * @override
 */
dvt.MultilineText.prototype.copyShape = function() {
  var ret = new dvt.MultilineText(this.getCtx(), this.getTextString(), this.getX(), this.getY());
  ret.setCSSStyle(this.getCSSStyle()).setHorizAlignment(this.getHorizAlignment()).setMaxLines(this.getMaxLines());
  return ret;
};


/**
 * Helper function to remove additional text lines.
 * @private
 */
dvt.MultilineText.prototype._removeAdditionalLines = function() {
  for (var i = 0; i < this._additionalLines.length; i++) {
    this.removeChild(this._additionalLines[i]);
  }

  this._additionalLines = [];
};


/**
 * Truncates the text instance to fit within the given width.  Sets the untruncated text string on itself if
 * truncated text does not fit.  Only for use by dvt.TextUtils.
 * @param {number} maxWidth The maximum width of the text.
 * @param {number} maxHeight The maximum height of the text.
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis after truncation.
 * @return {boolean} false if the text cannot fit at all, true otherwise.
 */
dvt.MultilineText.prototype.__fitText = function(maxWidth, maxHeight, minChars) {
  // Clear any previous layout results
  this._textInstance.setTextString(this.getTextString());
  this._removeAdditionalLines();

  // First try to fit the entire string in 1 line
  if (!dvt.TextUtils.fitText(this._textInstance, maxWidth, maxHeight, this, minChars)) {
    // String doesn't fit at all, remove from parent and return
    this.getParent().removeChild(this);
    return false;
  }
  else if (!this._textInstance.isTruncated()) // No truncation needed, text fits in one line.
    return true;
  else if (!this.isWrapEnabled()) // Accept text that fits partially
    return true;

  // Then wrap and truncate text to fit within the given parameters
  return this.wrapText(maxWidth, maxHeight, minChars, false);
};

/**
 * Wrap and truncates text to fit within the given parameters
 * @param {number} maxWidth The maximum width of the text.
 * @param {number} maxHeight The maximum height of the text.
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis after truncation.
 * @param {boolean=} breakOnTruncation Optional boolean to return unwrapped text if text does not fully fit in given dimensions
 * @return {boolean} false if the text cannot fit in the parameters, true otherwise.
 */
dvt.MultilineText.prototype.wrapText = function(maxWidth, maxHeight, minChars, breakOnTruncation) {
  // Truncation occurred.  Calculate line height so that we can add additional lines as space allows.
  var lineHeight = this.getLineHeight();
  var lineSpace = lineHeight * dvt.MultilineText._LINE_SPACE;
  var maxLines = this.getMaxLines();
  var availHeight = Math.min(maxHeight, maxLines * (lineHeight + lineSpace) - lineSpace) - lineHeight - lineSpace;

  if (this.getLineCount() > 1) // Clear any previous wrapping results
    this._removeAdditionalLines();

  // Split the string into parts.  Reverse the array so that we can use like a queue.
  var splits = this.getTextString().split(' ');
  splits.reverse();

  // Loop and add each part into the current line.  Create a new line once the current is full.
  var currentLine = this._textInstance;
  var currentString = null;
  while (splits.length > 0) {
    // Try adding the next split into the current line.
    var split = splits.pop();
    var newString = currentString ? currentString + ' ' + split : split;
    currentLine.setTextString(newString);
    currentLine.setUntruncatedTextString(null);

    if (!dvt.TextUtils.fitText(currentLine, maxWidth, Infinity, this, minChars)) {
      // Text doesn't fit at all, and there's no more space.  Returns true because previous lines had fit.
      return true;
    }
    else if (currentLine.isTruncated()) {
      // If there's no more space to add lines, we're done
      if (availHeight < lineSpace + lineHeight) {
        this._bTruncated = true;
        return true;
      }

      // Decide whether to keep this split in the current line or push to the next
      if (currentString) {
        // Always push the split to the next line if it didn't fit with the current one.
        currentLine.setTextString(currentString);
        splits.push(split);
      }
      else {
        // This means that we are keeping a truncated text line, because we're not pushing the split back onto the stack
        if (breakOnTruncation) {
          this._textInstance.setTextString(this.getTextString());
          this._removeAdditionalLines();
          return false;
        }
        else
          this._bTruncated = true;
      }

      // Text partially fit, create a new line for the next split
      if (splits.length > 0) {
        var newLine = currentLine.copyShape();
        newLine.setY(currentLine.getY() + lineSpace + lineHeight);
        this.addChild(newLine);
        this._additionalLines.push(newLine);

        // Update the pointers to the line and the availHeight
        currentLine = newLine;
        currentString = null;
        availHeight -= (lineSpace + lineHeight);
      }
    }
    else // Text completely fit, continue using this line
      currentString = newString;
  }

  return true;
};

/**
 * @override
 */
dvt.MultilineText.prototype.GetSvgDimensions = function(targetCoordinateSpace) {
  var dimensions;
  dvt.ArrayUtils.forEach(this._getTextLines(), function(entry) {
    dimensions = dimensions ? dimensions.getUnion(entry.measureDimensions(targetCoordinateSpace)) : entry.measureDimensions(targetCoordinateSpace);
  });
  return dimensions ? dimensions : new dvt.Rectangle(0, 0, 0, 0);
};

/**
 * Returns the number of lines for the text
 * @return {number}
 */
dvt.MultilineText.prototype.getLineCount = function() {
  return this._additionalLines.length + 1;
};

/**
 * Returns the line height
 * @return {number}
 */
dvt.MultilineText.prototype.getLineHeight = function() {
  if (!this._lineHeight)
    this._lineHeight = this._textInstance.measureDimensions().h;

  return this._lineHeight;
};

/**
 * Enables or disables attempting to wrap during text fitting
 * @param {boolean} wrapEnabled
 */
dvt.MultilineText.prototype.setWrapEnabled = function(wrapEnabled) {
  if (wrapEnabled == false) {
    if (this._textInstance.getParent() != this)
      this.addChild(this._textInstance);

    if (!this._textInstance.getTextString())
      this._textInstance.setTextString(this.getTextString());

    this._removeAdditionalLines();
  }

  this._noWrap = !wrapEnabled;
};

/**
 * Returns whether or not text will attempt to wrap during fitting
 * @return {boolean}
 */
dvt.MultilineText.prototype.isWrapEnabled = function() {
  return this._noWrap == false;
};

//// Functions added so that dvt.MultilineText can be used in the same instances as dvt.OutputText
/**
 * Returns the text string for this text object.  Returns null if the text string has not been truncated.
 * @return {string} the untruncated text string
 */
dvt.MultilineText.prototype.getUntruncatedTextString = function() {
  return this.isTruncated() ? this.getTextString() : null;
};

/**
 * Added for compatibilty with dvt.OutputText usages
 * @param {string} textString
 */
dvt.MultilineText.prototype.setUntruncatedTextString = function(textString) {
  // noop
};

/**
 * @override
 */
dvt.MultilineText.prototype.measureDimensions = function(targetCoordinateSpace) {
  return this.GetSvgDimensions(targetCoordinateSpace);
};

/**
 * @override
 */
dvt.MultilineText.prototype.getDimensions = function(targetCoordinateSpace) {
  return this.GetSvgDimensions(targetCoordinateSpace);
};

/**
 * @override
 */
dvt.MultilineText.prototype.UpdateSelectionEffect = function() {
  // noop: Does not participate in selection effects
};

/**
 * Returns the horizontal alignment for this text object.  Valid constants begin with dvt.MultilineText.H_ALIGN_.
 * @return {string}
 */
dvt.MultilineText.prototype.getHorizAlignment = function() {
  return this._horizAlign;
};

/**
 * Specifies the horizontal alignment for this text object.  Valid constants begin with dvt.MultilineText.H_ALIGN_.
 * @param {string} align
 */
dvt.MultilineText.prototype.setHorizAlignment = function(align) {
  if (align == dvt.MultilineText.H_ALIGN_LEFT)
    this.alignLeft();
  else if (align == dvt.MultilineText.H_ALIGN_CENTER)
    this.alignCenter();
  else if (align == dvt.MultilineText.H_ALIGN_RIGHT)
    this.alignRight();
};

/**
 * Returns the vertical alignment for this text object.  Valid constants begin with dvt.MultilineText.V_ALIGN_.
 * @return {string} The horizontal alignment
 */
dvt.MultilineText.prototype.getVertAlignment = function() {
  return this._vertAlign;
};

/**
 * Specifies the vertical alignment for this text object.  Valid constants begin with dvt.MultilineText.V_ALIGN_.
 * @param {string} align
 */
dvt.MultilineText.prototype.setVertAlignment = function(align) {
  if (align == dvt.MultilineText.V_ALIGN_TOP)
    this.alignTop();
  else if (align == dvt.MultilineText.V_ALIGN_MIDDLE)
    this.alignMiddle();
  else if (align == dvt.MultilineText.V_ALIGN_BOTTOM)
    this.alignBottom();
};

// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Read-only text object that supports wrapping.
 * @extends {dvt.Container}
 * @class dvt.BackgroundMultilineText
 * @extends {dvt.BackgroundOutputText}
 * @constructor
 * @param {dvt.Context} context
 * @param {string} textStr
 * @param {number} x
 * @param {number} y
 * @param {dvt.CSSStyle} style
 * @param {string=} id
 */
dvt.BackgroundMultilineText = function(context, textStr, x, y, style, id) {
  this.Init(context, textStr, x, y, style, id);
};

dvt.Obj.createSubclass(dvt.BackgroundMultilineText, dvt.BackgroundOutputText);

/**
 * @param {dvt.Context} context
 * @param {string} textStr the text string
 * @param {number} x
 * @param {number} y
 * @param {dvt.CSSStyle} style
 * @param {string=} id The optional id for the corresponding DOM element.
 * @protected
 */
dvt.BackgroundMultilineText.prototype.Init = function(context, textStr, x, y, style, id) {
  dvt.BackgroundMultilineText.superclass.Init.call(this, context, textStr, x, y, style, id);
};

/**
 * Wraps the text instance for this object.
 * @param {number} maxWidth The maximum width of the text.
 * @param {number} maxHeight The maximum height of the text.
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis after truncation.
 * @param {boolean=} breakOnTruncation Optional boolean to return unwrapped text if text does not fully fit in given dimensions
 * @return {boolean} false if the text cannot fit in the parameters, true otherwise.
 */
dvt.BackgroundMultilineText.prototype.wrapText = function(maxWidth, maxHeight, minChars, breakOnTruncation) {
  return this.TextInstance.wrapText(maxWidth, maxHeight, minChars, breakOnTruncation);
};

/**
 * @override
 */
dvt.BackgroundMultilineText.prototype.CreateTextInstance = function(context, textStr, x, y, id) {
  return new dvt.MultilineText(context, textStr, x, y, id);
};

/**
 * @override
 */
dvt.BackgroundMultilineText.prototype.GetTextDimensionsForRealign = function() {
  return this.getLineHeight();
};

/**
 * @override
 */
dvt.BackgroundMultilineText.prototype.measureDimensions = function() {
  return this.TextInstance.measureDimensions();
};

//// Functions added so that dvt.BackgroundMultilineText can be used in the same instances as dvt.MultilineText
/**
 * Truncates the text instance to fit within the given width.  Sets the untruncated text string on itself if
 * truncated text does not fit.  Only for use by dvt.TextUtils.
 * @param {number} maxWidth The maximum width of the text.
 * @param {number} maxHeight The maximum height of the text.
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis after truncation.
 * @return {boolean} false if the text cannot fit at all, true otherwise.
 */
dvt.BackgroundMultilineText.prototype.__fitText = function(maxWidth, maxHeight, minChars) {
  return this.TextInstance.__fitText(maxWidth, maxHeight, minChars);
};

/**
 * Returns an array with pointers to all the lines in this dvt.BackgroundMultilineText object
 * @return {Array} the lines in this object.
 * @private
 */
dvt.BackgroundMultilineText.prototype._getTextLines = function() {
  return this.TextInstance._getTextLines();
};

/**
 * Returns the line height
 * @return {number}
 */
dvt.BackgroundMultilineText.prototype.getLineHeight = function() {
  return this.TextInstance.getLineHeight();
};

/**
 * Returns the number of lines for the text
 * @return {number}
 */
dvt.BackgroundMultilineText.prototype.getLineCount = function() {
  return this.TextInstance.getLineCount();

};

/** Returns the y position used for vertical alignment
 *  @return {number} The y position.
 */
dvt.BackgroundMultilineText.prototype.getYAlignCoord = function() {
  return this.TextInstance.getYAlignCoord();
};

/**
 * Enables or disables attempting to wrap during text fitting
 * @param {boolean} wrapEnabled
 */
dvt.BackgroundMultilineText.prototype.setWrapEnabled = function(wrapEnabled) {
  this.TextInstance.setWrapEnabled(wrapEnabled);
};

/**
 * Returns whether or not text will attempt to wrap during fitting
 * @return {boolean}
 */
dvt.BackgroundMultilineText.prototype.isWrapEnabled = function() {
  return this.TextInstance.isWrapEnabled();
};

/**
 * @override
 */
dvt.BackgroundMultilineText.prototype.UpdateSelectionEffect = function() {
  // noop: Does not participate in selection effects
};
/**
 * Style Utilities
 * @class dvt.StyleUtils
 */
dvt.StyleUtils = {};

dvt.Obj.createSubclass(dvt.StyleUtils, dvt.Obj);

dvt.StyleUtils.DEFAULT_FONT_FAMILY = 'Tahoma,Verdana,Helvetica,sans-serif';
dvt.StyleUtils.DEFAULT_FONT_SIZE = '11px';
dvt.StyleUtils.DEFAULT_FONT_COLOR = 'black';

dvt.StyleUtils.getStyle = function(styleMap, styleName, defaultStyle) {
  if (styleMap && styleMap[styleName] !== null && typeof styleMap[styleName] !== 'undefined')
    return styleMap[styleName];
  else
    return defaultStyle;
};

dvt.StyleUtils.setStyle = function(styleMap, styleName, styleValue) {
  if (styleMap && styleValue !== null && typeof styleValue !== 'undefined')
    styleMap[styleName] = styleValue;
};


/**
 * Creates a dvt.Shadow object from a CSS box-shadow specification
 *
 * @param {string} shadowStyle the CSS box-shadow specification
 * @return {dvt.Shadow} the dvt.Shadow object
 */
dvt.StyleUtils.getShadow = function(shadowStyle) {
  var shadow = null;
  if (shadowStyle != null && shadowStyle != 'none') {
    var shadowRGBA;
    var shadowH = 0;
    var shadowV = 0;
    var shadowBlur = 0;

    var arr = shadowStyle.replace(/, /g, ',').split(' ');

    if (shadowStyle.match(/rgb/i) == null)
      arr[arr.length] = 'rgba(0, 0, 0, 0.2)';

    if (arr.length < 3)
      return null;

    for (var i = 0; i < arr.length; i++) {
      if (i == 0)
        shadowH = parseInt(arr[0]);
      else if (i == 1)
        shadowV = parseInt(arr[1]);
      else if (i == 2 && arr[i].match(/rgb/i) == null)
        shadowBlur = parseInt(arr[i]);
      else if (arr[i].match(/rgb/i))
        shadowRGBA = arr[i];
    }

    var shadowDistance = Math.sqrt(shadowH * shadowH + shadowV * shadowV);
    var angle = Math.atan2(shadowV, shadowH) * 180 / Math.PI;

    shadow = new dvt.Shadow(shadowRGBA,
        shadowDistance, // distance
        shadowBlur, // blurX
        shadowBlur, // blurY
        angle, // angle of the shadow
        1, // strength or the imprint/spread
        3, // quality
        false, // inner shadow
        false, // knockout effect
        false // hide object
        );
  }

  return shadow;
};

/**
 * Parses the ms time value.
 *
 * @param {object} value The time as read from the json object. Could be in ms or s. If intger value then assume it's ms.
 * @return {number} the value in milliseconds
 */
dvt.StyleUtils.getTimeMilliseconds = function(value) {
  if (typeof value == 'string') {
    if (value.slice(-2) == 'ms')
      value = parseInt((value.slice(0, -2)));
    else if (value.slice(-1) == 's')
      value = parseFloat(value.slice(0, -1)) * 1000;
    else
      value = parseInt(value);
  }
  return value;
};
/**
 * @constructor
 * dvt.CSSGradient
 */
dvt.CSSGradient = function(type) {
  this.Init(type);
};

dvt.Obj.createSubclass(dvt.CSSGradient, dvt.Obj);


dvt.CSSGradient.LINEAR = 0;
dvt.CSSGradient.RADIAL = 1;


dvt.CSSGradient.prototype.Init = function(type) {
  this._type = type;
};


/**
  *   Returns dvt.CSSGradient.LINEAR or dvt.CSSGradient.RADIAL
  */
dvt.CSSGradient.prototype.getGradientType = function()
{
  return this._type;
};


/**
  *   Returns an array of alpha's.
  *   @type {Array}
  */
dvt.CSSGradient.prototype.getAlphas = function()
{
  return this._arAlphas;
};


/**
  *  Sets the alphas of the gradient.
  *  @param {Array} arAlphas  The array of alphas
  */
dvt.CSSGradient.prototype.setAlphas = function(arAlphas)
{
  this._arAlphas = arAlphas;
};


/**
  *   Returns an array of colors.
  *   @type {Array}
  */
dvt.CSSGradient.prototype.getColors = function()
{
  return this._arColors;
};


/**
  *  Sets the colors of the gradient.
  *  @param {Array} arColors  The array of colors
  */
dvt.CSSGradient.prototype.setColors = function(arColors)
{
  this._arColors = arColors;
};


/**
  *   Returns an array of stop ratios.
  *   @type {Array}
  */
dvt.CSSGradient.prototype.getRatios = function()
{
  return this._arRatios;
};


/**
  *  Sets the ratios of the gradient.
  *  @param {Array} arRatios  The array of ratios
  */
dvt.CSSGradient.prototype.setRatios = function(arRatios)
{
  this._arRatios = arRatios;
};


/**
 * @constructor
 * DvtLinearGradient
 */
var DvtLinearGradient = function() {
  this.Init();
};

/*
 * make dvt.CSSGradient a subclass of DvtLinearGradient
 */
dvt.Obj.createSubclass(DvtLinearGradient, dvt.CSSGradient);

//convert sides into an angle (in radian)
//Note: in toolkit, angles are in degree (not radian)
DvtLinearGradient.LEFT = 0;   //0;
DvtLinearGradient.BOTTOM_LEFT = 45;
DvtLinearGradient.BOTTOM = 90; //Math.PI / 2;
DvtLinearGradient.BOTTOM_RIGHT = 135;
DvtLinearGradient.RIGHT = 180;    //Math.PI;
DvtLinearGradient.TOP_RIGHT = 225;
DvtLinearGradient.TOP = 270;     //3 * Math.PI / 2;
DvtLinearGradient.TOP_LEFT = 315;

DvtLinearGradient.prototype.Init = function() {
  DvtLinearGradient.superclass.Init.call(this, dvt.CSSGradient.LINEAR);
};


/*---------------------------------------------------------------------*/
/*   get/setAngle()                                                    */
/*---------------------------------------------------------------------*/
/**
  *  Returns the angle of the gradient.
  *  @return {number} the angle of the gradient.
  */
DvtLinearGradient.prototype.getAngle = function()
{
  // return angle
  // usage:
  // angle = Math.atan2(hh, ww)
  // var fill_matrix:Matrix = new Matrix();
  // fill_matrix.createGradientBox(ww, hh, angle, xx, yy);

  return this._angle;
};


/**
  *  Sets the angle of the gradient.
  *  @param {number} angle  The angle of the gradient.
  */
DvtLinearGradient.prototype.setAngle = function(angle)
{
  this._angle = angle;
};

/**
 * parse gradient string into gradient object
 * @class dvt.GradientParser
 * @constructor
 */
dvt.GradientParser = function() {
};

dvt.Obj.createSubclass(dvt.GradientParser, dvt.Obj);


/*ADF Faces FusionFx-v3-desktop linear gradient syntax */
/*using CSS3 gradients for button background-image */

/*********************************************************************
@agent webkit {
  .AFButtonBackground:alias {
    background-image: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#FFFFFF), to(#CCD6E8));
  }
}

@agent webkit and (min-version: 534.16) {
  .AFButtonBackground:alias {
    background-image: -webkit-linear-gradient(top, #FFFFFF, #CCD6E8);
  }
}

@agent gecko {
  .AFButtonBackground:alias {
    background-image: -moz-linear-gradient(top, #FFFFFF, #CCD6E8);
  }
}

@agent ie and (max-version: 7.0) {
  .AFButtonBackground:alias {
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#FFFFFF', endColorstr='#CCD6E8');
  }
}

@agent ie and (min-version: 8.0) {
  .AFButtonBackground:alias {
    -ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#FFFFFF', endColorstr='#CCD6E8')";
  }
}
*********************************************************************/

/* End of CSS3 gradients for buttom background-image*/


dvt.GradientParser.WEBKIT_GD_LINEAR = '-webkit-linear-gradient';
dvt.GradientParser.FIREFOX_GD_LINEAR = '-moz-linear-gradient';
dvt.GradientParser.IE_GD_LINEAR = 'progid:DXImageTransform.Microsoft.gradient';
dvt.GradientParser.IE_GD_LINEAR2 = 'progid:DXImageTransform.Microsoft.Gradient';
dvt.GradientParser.IE7_GD_FILTER = 'filter';
dvt.GradientParser.IE8_GD_FILTER = '-ms-filter';
dvt.GradientParser.IE10_GD_LINEAR = '-ms-linear-gradient';

dvt.GradientParser.IE_GD_START_COLOR_STR = 'startColorstr';
dvt.GradientParser.IE_GD_END_COLOR_STR = 'endColorstr';
dvt.GradientParser.IE_GD_GRADIENT_TYPE = 'GradientType';


//TODO: should we support old webkit gradient syntax???
dvt.GradientParser.OLD_WEBKIT_GD_LINEAR = '-webkit-gradient';

//W3C CSS3 gradient
dvt.GradientParser.GD_LINEAR = 'linear-gradient';
dvt.GradientParser.GD_RADIAL = 'radial-gradient';


dvt.GradientParser.GD_TOP = 'top';
dvt.GradientParser.GD_BOTTOM = 'bottom';
dvt.GradientParser.GD_LEFT = 'left';
dvt.GradientParser.GD_RIGHT = 'right';
dvt.GradientParser.GD_CENTER = 'center';
dvt.GradientParser.GD_TO = 'to';


/**
 * Parse a gradient style String and turn it into a dvt.CSSStyle.
 * @param {String} gradient string
 * @return a CSSGradient object if it is a gradient value,
 *         a null otherwise.
 */
dvt.GradientParser.parseCSSGradient = function(gradient) {

  if (gradient != null) {
    gradient = dvt.StringUtils.trim(gradient);

    if (dvt.GradientParser._startsWith(gradient, dvt.GradientParser.WEBKIT_GD_LINEAR)) {
      gradient = dvt.GradientParser._removeParenthesis(gradient, dvt.GradientParser.WEBKIT_GD_LINEAR);
      return dvt.GradientParser._parseLinearGradient(gradient);
    }
    else if (dvt.GradientParser._startsWith(gradient, dvt.GradientParser.FIREFOX_GD_LINEAR)) {
      gradient = dvt.GradientParser._removeParenthesis(gradient, dvt.GradientParser.FIREFOX_GD_LINEAR);
      return dvt.GradientParser._parseLinearGradient(gradient);
    }
    else if (dvt.GradientParser._startsWith(gradient, dvt.GradientParser.IE_GD_LINEAR)) {
      gradient = dvt.GradientParser._removeParenthesis(gradient, dvt.GradientParser.IE_GD_LINEAR);
      return dvt.GradientParser._parseIELinearGradient(gradient);
    }
    else if (dvt.GradientParser._startsWith(gradient, dvt.GradientParser.IE_GD_LINEAR2)) {
      gradient = dvt.GradientParser._removeParenthesis(gradient, dvt.GradientParser.IE_GD_LINEAR2);
      return dvt.GradientParser._parseIELinearGradient(gradient);
    }
    else if (dvt.GradientParser._startsWith(gradient, dvt.GradientParser.IE10_GD_LINEAR)) {
      gradient = dvt.GradientParser._removeParenthesis(gradient, dvt.GradientParser.IE10_GD_LINEAR);
      return dvt.GradientParser._parseLinearGradient(gradient);
    }
    //W3C CSS3 gradient (Draft 13 Dec 2011)
    else if (dvt.GradientParser._startsWith(gradient, dvt.GradientParser.GD_LINEAR)) {
      gradient = dvt.GradientParser._removeParenthesis(gradient, dvt.GradientParser.GD_LINEAR);
      return dvt.GradientParser._parseLinearGradient(gradient);
    }
  }
  return null;
};


/****************************************************************
   CSS3 - http://dev.w3.org/csswg/css3-images/#gradients

   <linear-gradient> = linear-gradient(
      [ [ <angle> | to <side-or-corner> ] ,]?
      <color-stop>[, <color-stop>]+
   )

   <side-or-corner> = [left | right] || [top | bottom]

/(([0-9]+)(deg|rad|grad)|\s*(to\s+)?((left|right)\s+)?(top|bottom)?\s*,\s*)?/i

/(#[0-9a-f]+|rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\)|rgba\(\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d?)(\.\d+)?\s*\)|[a-z]+)(\s+\d+%)?/gi


  ******************************************************************/

dvt.GradientParser._parseLinearGradient = function(gradient) {
  var number = new RegExp('(-?(?:\\d*\\.)?\\d+)');
  var angleUnit = new RegExp('(deg|rad|grad|turn)');
  var horiz = new RegExp('(left|right)');
  var vert = new RegExp('(top|bottom)');
  var to = new RegExp('(?:(to)\\s+)');
  var angle = new RegExp('(?:' + number.source + angleUnit.source + ')');
  var horizThenVert = new RegExp('(?:' + horiz.source + '(?:\\s+' + vert.source + ')?)');
  var vertThenHoriz = new RegExp('(?:' + vert.source + '(?:\\s+' + horiz.source + ')?)');
  var sideOrCorner = new RegExp('(?:' + horizThenVert.source + '|' + vertThenHoriz.source + ')');
  var direction = new RegExp('(?:' + angle.source + '|(?:' + to.source + '?' + sideOrCorner.source + '))');
  var everythingBeforeColorStops = new RegExp('(?:\\s*' + direction.source + '\\s*,\\s*)', 'i');
  var sides = gradient.match(everythingBeforeColorStops);

  if (sides == null || sides.length == 0)
    return null;

  // sides
  // 0: match string
  // 1: angle
  // 2: angle unit
  // 3: to (if present)
  // 4: horiz (if horizThenVert)
  // 5: vert (if horizThenVert)
  // 6: vert (if vertThenHoriz)
  // 7: horiz (if vertThenHoriz)

  var size = sides.length;
  var gradObj = new DvtLinearGradient();

  var bTop = sides[5] == dvt.GradientParser.GD_TOP || sides[6] == dvt.GradientParser.GD_TOP;
  var bBottom = sides[5] == dvt.GradientParser.GD_BOTTOM || sides[6] == dvt.GradientParser.GD_BOTTOM;
  var bLeft = sides[4] == dvt.GradientParser.GD_LEFT || sides[7] == dvt.GradientParser.GD_LEFT;
  var bRight = sides[4] == dvt.GradientParser.GD_RIGHT || sides[7] == dvt.GradientParser.GD_RIGHT;
  var bTo = sides[3] == dvt.GradientParser.GD_TO;
  if (bTo) {
    // specifying end rather than start, swap top/bottom, left/right if specified
    if (bTop || bBottom) {
      bTop = !bTop;
      bBottom = !bBottom;
    }

    if (bLeft || bRight) {
      bLeft = !bLeft;
      bRight = !bRight;
    }
  }

  // top left | top right | top
  if (bTop) {
    if (bLeft) {
      gradObj.setAngle(DvtLinearGradient.TOP_LEFT);
    }
    else if (bRight) {
      gradObj.setAngle(DvtLinearGradient.TOP_RIGHT);
    }
    else {
      gradObj.setAngle(DvtLinearGradient.TOP);
    }
  }
  // bottom left | bottom right | bottom
  else if (bBottom) {
    if (bLeft) {
      gradObj.setAngle(DvtLinearGradient.BOTTOM_LEFT);
    }
    else if (bRight) {
      gradObj.setAngle(DvtLinearGradient.BOTTOM_RIGHT);
    }
    else {
      gradObj.setAngle(DvtLinearGradient.BOTTOM);
    }
  }
  else if (bLeft) {
    gradObj.setAngle(DvtLinearGradient.LEFT);
  }
  else if (bRight) {
    gradObj.setAngle(DvtLinearGradient.RIGHT);
  }
  // parse angle if specified
  else if (sides[2]) {
    var angle = parseFloat(sides[1]);

    if (! isNaN(angle)) {
      if (sides[2] == 'grad') {
        angle = (angle / 200) * 180;
      }
      else if (sides[2] == 'rad') {
        angle = (angle / Math.PI) * 180;
      }
      else if (sides[2] == 'turn') {
        angle = (angle / .5) * 180;
      }
      //TODO: dont need to convert negative angle to positive
      //because beginGradientFill take negative angle
      //      angle = angle % (2 * Math.PI);
      //      if (angle < 0) {
      //        angle += 2 * Math.PI;
      //      }

      gradObj.setAngle(angle);
    }
  }

  // parse colorStops
  gradient = gradient.substring(sides[0].length);
  dvt.GradientParser._parseCSSColorStops(gradient, gradObj);

  return gradObj;
};


dvt.GradientParser._parseIELinearGradient = function(gradient) {
  var props = gradient.split(',');
  var size = props.length;
  var prop;
  var colorStops = [];

  //In IE GradientType = 0 (default, vertical)
  //      GradientType = 1 (horizontal)
  var gradObj = new DvtLinearGradient();
  gradObj.setAngle(DvtLinearGradient.TOP);

  // parse gradient properties
  for (var i = 0; i < size; i++) {
    prop = (dvt.StringUtils.trim(props[i])).split('=');
    if (prop.length == 2) {
      prop[0] = dvt.StringUtils.trim(prop[0]);
      if (prop[0] == dvt.GradientParser.IE_GD_START_COLOR_STR) {
        colorStops[0] = dvt.GradientParser.removeQuotes(prop[1], dvt.CSSStyle.SINGLE_QUOTE);
      }
      else if (prop[0] == dvt.GradientParser.IE_GD_END_COLOR_STR) {
        colorStops[1] = dvt.GradientParser.removeQuotes(prop[1], dvt.CSSStyle.SINGLE_QUOTE);
      }
      else if (prop[0] == dvt.GradientParser.IE_GD_GRADIENT_TYPE) {
        if (prop[1] == '1') {
          gradObj.setAngle(DvtLinearGradient.LEFT);
        }
      }
    }
  }

  // parse color stops
  dvt.GradientParser._parseColorStops(colorStops, gradObj);

  return gradObj;
};


/**
 * Parse Gradient CSS Color Stops
 * @private
 * @param {string} s  style attribute
 * @param {dvt.CSSGradient} gradObj  Gradient object
 */
dvt.GradientParser._parseCSSColorStops = function(s, gradObj) {

  var colorStops = s.match(/(#[0-9a-f]+|rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\)|rgba\(\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d?)(\.\d+)?\s*\)|[a-z]+)(\s+\d+\.?\d*%)?/gi);

  if (colorStops != null && colorStops.length > 0) {
    dvt.GradientParser._parseColorStops(colorStops, gradObj);
  }
};


dvt.GradientParser._parseColorStops = function(colorStops, gradObj) {

  var size = colorStops.length;
  var alphas = [];
  var colors = [];
  var ratios = [];
  var alphaColor;
  var position;
  var noRatio = true;
  var sPosition;
  var colorArray = [];

  for (var i = 0; i < colorStops.length; i++) {
    sPosition = dvt.CSSStyle.parseBorderColor(colorStops[i], colorArray);
    alphaColor = colorArray.pop();

    colors[i] = alphaColor;
    alphas[i] = dvt.ColorUtils.getAlpha(alphaColor);

    sPosition = dvt.StringUtils.trim(sPosition);
    if (sPosition.length > 0) {
      position = parseFloat(sPosition);
      if (! isNaN(position)) {
        //NOTE: support % but not length or ratio.
        if (dvt.StringUtils.endsWith(sPosition, '%')) {
          ratios[i] = position / 100;
          noRatio = false;
        }
      }
    }
  }

  // no location is specified, even space is assumed
  if (size > 1 && noRatio) {
    for (var r = 0; r < size; r++) {
      ratios[r] = r / (size - 1);
    }
  }
  else if (noRatio) {
    ratios[0] = 0;
  }

  gradObj.setColors(colors);
  gradObj.setAlphas(alphas);
  gradObj.setRatios(ratios);
};

dvt.GradientParser._removeParenthesis = function(gradient, keyWord) {
  if (gradient.charAt(gradient.length - 1) != ')')
    return null;

  // remove keyWord and parethesis around it
  gradient = gradient.substring(keyWord.length);

  return dvt.GradientParser.removeQuotes(gradient, '(', ')');
};

dvt.GradientParser.removeQuotes = function(colorStr, openQ, closeQ) {
  // remove quote around the color string
  colorStr = dvt.StringUtils.trim(colorStr);
  if (colorStr.charAt(0) != openQ)
    return colorStr;

  if (closeQ == null)
    closeQ = openQ;

  var iStart = 1;
  var iEnd = colorStr.lastIndexOf(closeQ);
  if (iEnd < 0)
    return colorStr.substring(iStart);

  return colorStr.substring(iStart, iEnd);
};



dvt.GradientParser._startsWith = function(str, value) {
  return str.indexOf(value) == 0;
};

/**
 * @constructor
 * Represents a set of CSS styles.
 * @param {String} style inlineStyle
 */
dvt.CSSStyle = function(style) {
  this.Init(style);
};

dvt.Obj.createSubclass(dvt.CSSStyle, dvt.Obj);

/** @const **/
dvt.CSSStyle.SKIN_FUSION = 'fusion';
/** @const **/
dvt.CSSStyle.SKIN_SKYROS = 'skyros';
/** @const **/
dvt.CSSStyle.SKIN_ALTA = 'alta';
/**
 * Placeholder for the post-Alta skin.
 * @const
 */
dvt.CSSStyle.SKIN_NEXT = 'next';

// Background Properties
dvt.CSSStyle.BACKGROUND = 'background';
dvt.CSSStyle.BACKGROUND_COLOR = 'background-color';
dvt.CSSStyle.BACKGROUND_IMAGE = 'background-image';
dvt.CSSStyle.BACKGROUND_REPEAT = 'background-repeat';
dvt.CSSStyle.BACKGROUND_POSITION = 'background-position';

// Border Properties
dvt.CSSStyle.BORDER = 'border';
dvt.CSSStyle.BORDER_TOP = 'border-top';
dvt.CSSStyle.BORDER_BOTTOM = 'border-bottom';
dvt.CSSStyle.BORDER_LEFT = 'border-left';
dvt.CSSStyle.BORDER_RIGHT = 'border-right';

dvt.CSSStyle.BORDER_WIDTH = 'border-width';
dvt.CSSStyle.BORDER_TOP_WIDTH = 'border-top-width';
dvt.CSSStyle.BORDER_BOTTOM_WIDTH = 'border-bottom-width';
dvt.CSSStyle.BORDER_LEFT_WIDTH = 'border-left-width';
dvt.CSSStyle.BORDER_RIGHT_WIDTH = 'border-right-width';

dvt.CSSStyle.BORDER_COLOR = 'border-color';
dvt.CSSStyle.BORDER_TOP_COLOR = 'border-top-color';
dvt.CSSStyle.BORDER_BOTTOM_COLOR = 'border-bottom-color';
dvt.CSSStyle.BORDER_LEFT_COLOR = 'border-left-color';
dvt.CSSStyle.BORDER_RIGHT_COLOR = 'border-right-color';

dvt.CSSStyle.BORDER_STYLE = 'border-style';

// - border-radius css property not supported when used inside <dvt:node>
dvt.CSSStyle.BORDER_RADIUS = 'border-radius';
dvt.CSSStyle.BORDER_TOP_LEFT_RADIUS = 'border-top-left-radius';
dvt.CSSStyle.BORDER_TOP_RIGHT_RADIUS = 'border-top-right-radius';
dvt.CSSStyle.BORDER_BOTTOM_RIGHT_RADIUS = 'border-bottom-right-radius';
dvt.CSSStyle.BORDER_BOTTOM_LEFT_RADIUS = 'border-bottom-left-radius';

// Margin Properties
dvt.CSSStyle.MARGIN = 'margin';
dvt.CSSStyle.MARGIN_TOP = 'margin-top';
dvt.CSSStyle.MARGIN_BOTTOM = 'margin-bottom';
dvt.CSSStyle.MARGIN_LEFT = 'margin-left';
dvt.CSSStyle.MARGIN_RIGHT = 'margin-right';

// Padding Properties
dvt.CSSStyle.PADDING = 'padding';
dvt.CSSStyle.PADDING_TOP = 'padding-top';
dvt.CSSStyle.PADDING_BOTTOM = 'padding-bottom';
dvt.CSSStyle.PADDING_LEFT = 'padding-left';
dvt.CSSStyle.PADDING_RIGHT = 'padding-right';

// Font Properties
dvt.CSSStyle.COLOR = 'color';
dvt.CSSStyle.FONT_FAMILY = 'font-family';
dvt.CSSStyle.FONT_SIZE = 'font-size';
dvt.CSSStyle.FONT_STYLE = 'font-style';
dvt.CSSStyle.FONT_WEIGHT = 'font-weight';
dvt.CSSStyle.TEXT_DECORATION = 'text-decoration';
dvt.CSSStyle.TEXT_ALIGN = 'text-align';

// - DIFFICULT TO SIZE PGLS WHEN USING PADDING AND BORDERS
//value for box-sizing
dvt.CSSStyle.BORDER_BOX = 'border-box';
dvt.CSSStyle.CONTENT_BOX = 'content-box';

// Size Properties
dvt.CSSStyle.HEIGHT = 'height';
dvt.CSSStyle.WIDTH = 'width';

//value for background-image
dvt.CSSStyle.NONE = 'none';

//values for background-repeat
dvt.CSSStyle.NO_REPEAT = 'no-repeat';
dvt.CSSStyle.REPEAT = 'repeat';
dvt.CSSStyle.REPEAT_X = 'repeat-x';
dvt.CSSStyle.REPEAT_Y = 'repeat-y';

//value for margin
dvt.CSSStyle.AUTO = 'auto';
dvt.CSSStyle.AUTO_MARGIN = '8';

//HV recognizes these for "gradient" or "solid"
dvt.CSSStyle.BORDER_TYPE = 'border-type';
dvt.CSSStyle.FILL_TYPE = 'fill-type';

//used for icon url
dvt.CSSStyle.CONTENT = 'content';

//For Alta selection effects. Not proper CSS and should move when possible
dvt.CSSStyle.INNER_COLOR = '-tr-inner-color';
dvt.CSSStyle.OUTER_COLOR = '-tr-outer-color';

/** @const */
dvt.CSSStyle.WHITE_SPACE = 'white-space';

/** @private **/
dvt.CSSStyle._NAMED_FONT_SIZE_MAP = {
  'xx-small' : '9', 'x-small' : '10', 'small' : '13', 'medium' : '16', 'large' : '18', 'x-large' : '24', 'xx-large' : '32'
};


/** @private **/
dvt.CSSStyle._NAMED_WIDTH_MAP = {
  thin: '2', medium: '4', thick: '6'
};


/** @private **/
dvt.CSSStyle._NAMED_COLOR_MAP = {
  'aqua': '#00FFFF', 'black': '#000000', 'blue': '#0000FF', 'white': '#FFFFFF', 'fuchsia': '#FF00FF', 'gray': '#848284',
  'lime': '#00FF00', 'maroon': '#840000', 'green': '#008200', 'navy': '#000084', 'olive': '#848200', 'red': '#FF0000',
  'silver': '#C6C3C6', 'teal': '#008284', 'yellow': '#FFFF00', 'purple': '#800080', 'cyan': '#D2B48C', 'goldenrod': '#DAA520',
  'lightblue': '#ADD8E6', 'lightyellow': '#FFFFE0', 'orange': '#FFA500', 'paleGoldenRod': '#EEE8AA', 'paleturquoise': '#AFEEEE',
  'peachpuff': '#FFDAB9', 'pink': '#FFC0CB', 'tan': '#D2B48C', 'thistle': '#D8BFD8', 'transparent': 'transparent'
};

// numeric attributes List
dvt.CSSStyle._numericAttrsList = [dvt.CSSStyle.WIDTH, dvt.CSSStyle.HEIGHT, dvt.CSSStyle.BORDER_WIDTH, dvt.CSSStyle.BORDER_TOP_WIDTH, dvt.CSSStyle.BORDER_BOTTOM_WIDTH, dvt.CSSStyle.BORDER_LEFT_WIDTH, dvt.CSSStyle.BORDER_RIGHT_WIDTH, dvt.CSSStyle.MARGIN, dvt.CSSStyle.MARGIN_TOP, dvt.CSSStyle.MARGIN_BOTTOM, dvt.CSSStyle.MARGIN_LEFT, dvt.CSSStyle.MARGIN_RIGHT, dvt.CSSStyle.PADDING, dvt.CSSStyle.PADDING_TOP, dvt.CSSStyle.PADDING_BOTTOM, dvt.CSSStyle.PADDING_LEFT, dvt.CSSStyle.PADDING_RIGHT];

dvt.CSSStyle._DOUBLE_QUOTE = '\"';
dvt.CSSStyle._SINGLE_QUOTE = "'";

// Default color ramps
dvt.CSSStyle.COLORS_SKYROS = ['#003366', '#CC3300', '#666699', '#006666', '#FF9900', '#993366', '#99CC33', '#624390', '#669933', '#FFCC33', '#006699', '#EBEA79'];
dvt.CSSStyle.COLORS_ALTA = ['#267db3', '#68c182', '#fad55c', '#ed6647', '#8561c8', '#6ddbdb', '#ffb54d', '#e371b2', '#47bdef', '#a2bf39', '#a75dba', '#f7f37b'];


/**
 * Initializes the dvt.CSSStyle using the specified inline style string.
 * @param {String} style The inline style string containing the attributes for this dvt.CSSStyle.
 * @protected
 */
dvt.CSSStyle.prototype.Init = function(style) {
  // Initialize the object map containing all the style properties
  this._styleMap = {
  };

  this.parseInlineStyle(style);
};


/**
 * Parse an inlineStyle string into a set of CSS styles and merge the results to this style object.
 * @param {String} style inlineStyle
 */
dvt.CSSStyle.prototype.parseInlineStyle = function(style) {
  if (style && style.length > 0) {
    var splits = style.split(';');
    for (var i = 0; i < splits.length; i++) {
      var s = splits[i];
      if (s && s.length > 0) {
        //find the first colon instead of using String.split because
        //there may be other colons in the string, for instance in
        //a fully qualified background-image url (http://some.server.com/...)
        var colonIndex = s.indexOf(':');
        if (colonIndex > - 1) {
          var attrName = dvt.StringUtils.trim(s.substring(0, colonIndex));
          var attrVal = dvt.StringUtils.trim(s.substring(colonIndex + 1));

          if (attrName && attrName.length > 0 && attrVal && attrVal.length > 0) {

            //inline images with data url
            if (attrName == dvt.CSSStyle.BACKGROUND_IMAGE && attrVal.indexOf('data:image/') >= 0) {
              attrVal = attrVal + ';' + splits[i + 1];
              i++;
            }

            this.setStyle(attrName, attrVal);
          }
        }
      }
    }
  }
};


/**
 * Sets the value for a CSS attribute. This function will do all necessary conversion for the value.
 * @param {string} key The attribute name.
 * @param {string} val The attribute value.
 * @return {dvt.CSSStyle} This dvt.CSSStyle instance, useful for linking calls.
 */
dvt.CSSStyle.prototype.setStyle = function(key, val) {
  // TODO: This function can be made faster by indexing the attributes to their conversion routines.
  // TODO: This function can be made faster by removing unnecessary conversion routines (color)
  if (val == null)
    this._setStyleAttr(key, val);
  else {
    // The specialized routines don't do a good job of null checking. TODO CLEANUP
    switch (key) {
      case 'background-repeat':
        this._setBackgroundRepeat(key, val);
        break;
      case 'color':
      case 'background-color':
      case 'border-top-color':
      case 'border-bottom-color':
      case 'border-left-color':
      case 'border-right-color':
        this._setColorAttr(key, val);
        break;

      case 'border-top':
      case 'border-bottom':
      case 'border-left':
      case 'border-right':
        this._setBorderSide(key, val);
        break;

      case 'border':
        this._setBorderShorthand(key, val);
        break;
      case 'border-color':
        this._setBorderColorShorthand(key, val);
        break;
      case 'border-width':
        this._setBorderWidthShorthand(key, val);
        break;

      // - border-radius css property not supported when used inside <dvt:node>
      case 'border-radius':
        this._setBorderRadius(key, val);
        break;

      case 'padding':
        this._setPaddingShorthand(key, val);
        break;
      case 'margin':
        this._setMarginShorthand(key, val);
        break;
      case 'font-size':
        this.setFontSize(key, val);
        break;

      // - hv command button loses gradient
      //TODO: allow gradient syntax on BACKGROUND_COLOR???
      case 'background-image':
        var gradObj = dvt.GradientParser.parseCSSGradient(val);
        if (gradObj) {
          val = gradObj;
        }
        this._setStyleAttr(key, val);
        break;

      //IE gradient syntax
      case dvt.GradientParser.IE7_GD_FILTER:
      case dvt.GradientParser.IE8_GD_FILTER:
        //remove quotes around the value
        var val1 = dvt.GradientParser.removeQuotes(val, dvt.CSSStyle._DOUBLE_QUOTE);

        var gradObj = dvt.GradientParser.parseCSSGradient(val1);
        if (gradObj) {
          key = dvt.CSSStyle.BACKGROUND_IMAGE;
          val = gradObj;
        }

        this._setStyleAttr(key, val);
        break;

      default :
        this._setStyleAttr(key, val);
        break;
    }
  }

  // Return this instance to support linking of set calls.
  return this;
};


/**
 * Returns the value of the specified style property.
 * @param {string} key The style property whose value will be returned.
 * @return {string} The value of the specified style property.
 */
dvt.CSSStyle.prototype.getStyle = function(key) {
  return this._styleMap[key];
};


/**
 * Specifies the value of the specified style property.  Does not perform any conversion.
 * @param {string} key The style property whose value will be returned.
 * @param {string} value The value of the specified style property.
 * @return {dvt.CSSStyle} This dvt.CSSStyle instance, useful for linking calls.
 * @private
 */
dvt.CSSStyle.prototype._setStyleAttr = function(key, value) {
  if (value != null)
    this._styleMap[key] = value;
  else delete this._styleMap[key];

  return this;
};


/**
 * Sets the font-size on a dvt.CSSStyle object
 * @param {string} key The css key to set the font-size under TODO , is this ever not font-size?
 * @param {string} val The font-size which can be in the format '9', '9px', or 'xx-small'
 */
dvt.CSSStyle.prototype.setFontSize = function(key, val) {
  var fsize = dvt.StringUtils.trim(val);
  var specSize = dvt.CSSStyle._NAMED_FONT_SIZE_MAP[fsize];
  if (specSize)
    this._setStyleAttr(key, (String(specSize) + 'px'));
  else
    this._setStyleAttr(key, isNaN(parseFloat(fsize)) ? dvt.StyleUtils.DEFAULT_FONT_SIZE : fsize);
};


/**
 * @param key is a shorthand for the four border properties: top, right, bottom and left border, respectively.
 * @param val may contain up to 4 border-width values.
 * @private
 */
dvt.CSSStyle.prototype._setBorderWidthShorthand = function(key, val) {
  var bwArray = val.split(' ');
  var bWidth = null;

  switch (bwArray.length) {
    case 1:
      this._setStyleAttr(key, dvt.CSSStyle._getBorderWidth(bwArray[0]));
      // remove other border widths
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_WIDTH, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_WIDTH, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_RIGHT_WIDTH, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_LEFT_WIDTH, null);
      break;

    case 2:
      bWidth = dvt.CSSStyle._getBorderWidth(bwArray[0]);
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_WIDTH, bWidth);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_WIDTH, bWidth);

      bWidth = dvt.CSSStyle._getBorderWidth(bwArray[1]);
      this._setStyleAttr(dvt.CSSStyle.BORDER_LEFT_WIDTH, bWidth);
      this._setStyleAttr(dvt.CSSStyle.BORDER_RIGHT_WIDTH, bWidth);
      break;

    case 3:
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_WIDTH, dvt.CSSStyle._getBorderWidth(bwArray[0]));
      bWidth = dvt.CSSStyle._getBorderWidth(bwArray[1]);
      this._setStyleAttr(dvt.CSSStyle.BORDER_LEFT_WIDTH, bWidth);
      this._setStyleAttr(dvt.CSSStyle.BORDER_RIGHT_WIDTH, bWidth);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_WIDTH, dvt.CSSStyle._getBorderWidth(bwArray[2]));
      break;

    case 4:
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_WIDTH, dvt.CSSStyle._getBorderWidth(bwArray[0]));
      this._setStyleAttr(dvt.CSSStyle.BORDER_RIGHT_WIDTH, dvt.CSSStyle._getBorderWidth(bwArray[1]));
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_WIDTH, dvt.CSSStyle._getBorderWidth(bwArray[2]));
      this._setStyleAttr(dvt.CSSStyle.BORDER_LEFT_WIDTH, dvt.CSSStyle._getBorderWidth(bwArray[3]));
      break;

    case 0:
    default :
      break;
  }
};


/**
 * @param val contain only one borderWidth value
 * @private
 */
dvt.CSSStyle._getBorderWidth = function(val) {

  var bwidth = dvt.StringUtils.trim(val);
  var specSize = dvt.CSSStyle._NAMED_WIDTH_MAP[bwidth];
  if (!specSize) {
    specSize = isNaN(parseFloat(bwidth)) ? '0px' : bwidth;
  }

  return specSize;
};


/**
 * @param {string} key The border-*** attribute, such as border-top.
 * @param {string} val The value of the border property, such as "#797975 1px solid".  Accepts width, style, and color
 *                     in any order, separated by spaces.
 * @private
 */
dvt.CSSStyle.prototype._setBorderSide = function(key, val) {
  var borderArray = val.split(' ');
  var borderVal = null;
  var noBorder = false;
  var key1;

  for (var i = 0; i < borderArray.length; i++) {
    borderVal = borderArray[i];
    key1 = key;

    //rgb border color
    if (borderVal.indexOf('rgb') == 0) {
      for (var k = i + 1; k < borderArray.length; k++) {
        borderVal += borderArray[k];
        i++;
        if (borderArray[k].indexOf(')') != - 1)
          break;
      }
      if (!dvt.StringUtils.endsWith(key, '-' + dvt.CSSStyle.COLOR))
        key1 = key + '-' + dvt.CSSStyle.COLOR;
      this._setStyleAttr(key1, borderVal);
    }
    //border color
    else if (dvt.CSSStyle._isColorValue(borderVal)) {
      if (!dvt.StringUtils.endsWith(key, '-' + dvt.CSSStyle.COLOR))
        key1 = key + '-' + dvt.CSSStyle.COLOR;
      this._setStyleAttr(key1, dvt.CSSStyle._parseHexColor(borderVal));
    }
    //border width
    else if (dvt.CSSStyle._isBorderWidthValue(borderVal)) {
      if (!dvt.StringUtils.endsWith(key, '-' + dvt.CSSStyle.WIDTH))
        key1 = key + '-' + dvt.CSSStyle.WIDTH;
      this._setStyleAttr(key1, borderVal);
    }
    //we don't currently handle border style, but if it's none, set width=0
    else if (val == 'none')
      noBorder = true;
  }

  if (noBorder) {
    this._setStyleAttr(key + '-' + dvt.CSSStyle.WIDTH, '0');
  }
};


/**
 * Computes and returns the border width for the specified side.
 * @param {string} key The border-***-width attribute, such as border-top-width.
 * @param {number}
 */
dvt.CSSStyle.prototype.getBorderSideWidth = function(key) {
  return this._getSideWidth(key, dvt.CSSStyle.BORDER_WIDTH);
};


/**
 * Computes and returns the margin for the specified side.
 * @param {string} key The margin-*** attribute, such as margin-top.
 * @param {number}
 */
dvt.CSSStyle.prototype.getMargin = function(key) {
  return this._getSideWidth(key, dvt.CSSStyle.MARGIN);
};


/**
 * Computes and returns the padding for the specified side.
 * @param {string} key The padding-*** attribute, such as padding-top.
 * @param {number}
 */
dvt.CSSStyle.prototype.getPadding = function(key) {
  return this._getSideWidth(key, dvt.CSSStyle.PADDING);
};

dvt.CSSStyle.prototype.getBorderWidth = function() {
  var bwidth = this.getStyle(dvt.CSSStyle.BORDER_WIDTH);
  if (bwidth) {
    return dvt.CSSStyle.toNumber(bwidth);
  }
  bwidth = this.getStyle(dvt.CSSStyle.BORDER_TOP_WIDTH);
  if (bwidth) {
    return dvt.CSSStyle.toNumber(bwidth);
  }
  bwidth = this.getStyle(dvt.CSSStyle.BORDER_RIGHT_WIDTH);
  if (bwidth) {
    return dvt.CSSStyle.toNumber(bwidth);
  }
  bwidth = this.getStyle(dvt.CSSStyle.BORDER_BOTTOM_WIDTH);
  if (bwidth) {
    return dvt.CSSStyle.toNumber(bwidth);
  }
  bwidth = this.getStyle(dvt.CSSStyle.BORDER_LEFT_WIDTH);
  if (bwidth) {
    return dvt.CSSStyle.toNumber(bwidth);
  }
  return 0;
};

// width and height
dvt.CSSStyle.prototype.getWidth = function() {
  return this.getStyle(dvt.CSSStyle.WIDTH);
};

dvt.CSSStyle.prototype.getHeight = function() {
  return this.getStyle(dvt.CSSStyle.HEIGHT);
};


/**
 * Convert a string to a number
 *
 * @return a number or zero if not a number or value is not specified
 */
dvt.CSSStyle.toNumber = function(val) {
  if (val) {
    val = parseFloat(val);
    return isNaN(val) ? 0 : val;
  }
  return 0;
};


/**
 * Determine if the given style can be inherited.
 *
 * @return true if the style can be inherited from an ancestor,
 *         false if not
 */
dvt.CSSStyle.isInheritable = function(key) {
  switch (key) {
    case dvt.CSSStyle.COLOR:
    case dvt.CSSStyle.FONT_FAMILY:
    case dvt.CSSStyle.FONT_SIZE:
    case dvt.CSSStyle.FONT_STYLE:
    case dvt.CSSStyle.FONT_WEIGHT:
    case dvt.CSSStyle.TEXT_ALIGN:
      return true;

    default :
      return false;
  }
};

// val is a string contains up to 4 rgb colors, ex:
// border-color: rgb(221, 221, 216) rgb(185, 185, 132) rgb(121, 121, 117)
dvt.CSSStyle.prototype._setBorderColorShorthand = function(key, val) {
  var bcArray = dvt.CSSStyle._parseBorderColorString(key, val);
  var bcolor;

  switch (bcArray.length) {
    case 1:
      this._setStyleAttr(key, bcArray[0]);
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_COLOR, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_COLOR, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_RIGHT_COLOR, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_LEFT_COLOR, null);
      break;

    case 2:
      bcolor = bcArray[0];
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_COLOR, bcolor);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_COLOR, bcolor);

      bcolor = bcArray[1];
      this._setStyleAttr(dvt.CSSStyle.BORDER_LEFT_COLOR, bcolor);
      this._setStyleAttr(dvt.CSSStyle.BORDER_RIGHT_COLOR, bcolor);
      break;

    case 3:
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_COLOR, bcArray[0]);
      bcolor = bcArray[1];
      this._setStyleAttr(dvt.CSSStyle.BORDER_LEFT_COLOR, bcolor);
      this._setStyleAttr(dvt.CSSStyle.BORDER_RIGHT_COLOR, bcolor);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_COLOR, bcArray[2]);
      break;

    case 4:
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_COLOR, bcArray[0]);
      this._setStyleAttr(dvt.CSSStyle.BORDER_RIGHT_COLOR, bcArray[1]);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_COLOR, bcArray[2]);
      this._setStyleAttr(dvt.CSSStyle.BORDER_LEFT_COLOR, bcArray[3]);
      break;

    case 0:
    default :
      break;
  }
};

// val is a string contains up to 4 padding sizes, ex:
// padding: 2px 9px 1px
dvt.CSSStyle.prototype._setPaddingShorthand = function(key, val) {
  var padArray = val.split(' ');
  var padding = null;

  switch (padArray.length) {
    case 1:
      this._setStyleAttr(key, this._getPercent(padArray[0]));
      this._setStyleAttr(dvt.CSSStyle.PADDING_TOP, null);
      this._setStyleAttr(dvt.CSSStyle.PADDING_BOTTOM, null);
      this._setStyleAttr(dvt.CSSStyle.PADDING_RIGHT, null);
      this._setStyleAttr(dvt.CSSStyle.PADDING_LEFT, null);
      break;

    case 2:
      padding = this._getPercent(padArray[0]);
      this._setStyleAttr(dvt.CSSStyle.PADDING_TOP, padding);
      this._setStyleAttr(dvt.CSSStyle.PADDING_BOTTOM, padding);

      padding = this._getPercent(padArray[1]);
      this._setStyleAttr(dvt.CSSStyle.PADDING_LEFT, padding);
      this._setStyleAttr(dvt.CSSStyle.PADDING_RIGHT, padding);
      break;

    case 3:
      this._setStyleAttr(dvt.CSSStyle.PADDING_TOP, this._getPercent(padArray[0]));
      padding = this._getPercent(padArray[1]);
      this._setStyleAttr(dvt.CSSStyle.PADDING_LEFT, padding);
      this._setStyleAttr(dvt.CSSStyle.PADDING_RIGHT, padding);
      this._setStyleAttr(dvt.CSSStyle.PADDING_BOTTOM, this._getPercent(padArray[2]));
      break;

    case 4:
      this._setStyleAttr(dvt.CSSStyle.PADDING_TOP, this._getPercent(padArray[0]));
      this._setStyleAttr(dvt.CSSStyle.PADDING_RIGHT, this._getPercent(padArray[1]));
      this._setStyleAttr(dvt.CSSStyle.PADDING_BOTTOM, this._getPercent(padArray[2]));
      this._setStyleAttr(dvt.CSSStyle.PADDING_LEFT, this._getPercent(padArray[3]));
      break;

    case 0:
    default :
      break;
  }
};

// val is a string contains up to 4 margin sizes, ex:
// margin: 2px 9px 1px
//TODO: margin can be negative numbers and in CM
dvt.CSSStyle.prototype._setMarginShorthand = function(key, val) {
  var padArray = val.split(' ');
  var margin = null;

  switch (padArray.length) {
    case 1:
      this._setStyleAttr(key, this._getMargin(padArray[0]));
      this._setStyleAttr(dvt.CSSStyle.MARGIN_TOP, null);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_BOTTOM, null);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_RIGHT, null);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_LEFT, null);
      break;

    case 2:
      margin = this._getMargin(padArray[0]);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_TOP, margin);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_BOTTOM, margin);

      margin = this._getMargin(padArray[1]);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_LEFT, margin);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_RIGHT, margin);
      break;

    case 3:
      this._setStyleAttr(dvt.CSSStyle.MARGIN_TOP, this._getMargin(padArray[0]));
      margin = this._getMargin(padArray[1]);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_LEFT, margin);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_RIGHT, margin);
      this._setStyleAttr(dvt.CSSStyle.MARGIN_BOTTOM, this._getMargin(padArray[2]));
      break;

    case 4:
      this._setStyleAttr(dvt.CSSStyle.MARGIN_TOP, this._getMargin(padArray[0]));
      this._setStyleAttr(dvt.CSSStyle.MARGIN_RIGHT, this._getMargin(padArray[1]));
      this._setStyleAttr(dvt.CSSStyle.MARGIN_BOTTOM, this._getMargin(padArray[2]));
      this._setStyleAttr(dvt.CSSStyle.MARGIN_LEFT, this._getMargin(padArray[3]));
      break;

    case 0:
    default :
      break;
  }
};

//TODO: auto size defined by browsers
dvt.CSSStyle.prototype._getMargin = function(val) {
  var margin = dvt.StringUtils.trim(val);
  if (dvt.CSSStyle.AUTO == margin)
    return dvt.CSSStyle.AUTO_MARGIN;
  else
    return this._getPercent(margin);
};

// TODO: No idea how this has anything to do with percentages
dvt.CSSStyle.prototype._getPercent = function(val) {
  return dvt.StringUtils.trim(val);
};

dvt.CSSStyle.prototype._setBorderShorthand = function(key, val) {
  /*
   * "border" Shorthand property can specify width, style, and color
   * separated by spaces, which are applied to all 4 border sides
   * ex: "1px solid rgb(185, 185, 180)"
   */
  var borderArray = val.split(' ');
  var borderVal = null;
  var noBorder = false;

  for (var i = 0; i < borderArray.length; i++) {
    borderVal = borderArray[i];

    //rgb border color
    if (borderVal.indexOf('rgb') == 0) {
      for (var k = i + 1; k < borderArray.length; k++) {
        borderVal += borderArray[k];
        i++;
        if (borderArray[k].indexOf(')') != - 1)
          break;
      }
      this._setBorderColorShorthand(dvt.CSSStyle.BORDER_COLOR, borderVal);
    }

    //border color
    else if (dvt.CSSStyle._isColorValue(borderVal))
      this._setBorderColorShorthand(dvt.CSSStyle.BORDER_COLOR, borderVal);

    //border width
    else if (dvt.CSSStyle._isBorderWidthValue(borderVal))
      this._setBorderWidthShorthand(dvt.CSSStyle.BORDER_WIDTH, borderVal);

    //we don't currently handle border style, but if it's none, set width=0
    else if (val == 'none')
      noBorder = true;

  }

  if (noBorder) {
    this._setBorderWidthShorthand(dvt.CSSStyle.BORDER_WIDTH, '0');
  }
};

dvt.CSSStyle._getBorderRadius = function(val) {

  var radii = dvt.StringUtils.trim(val);
  return isNaN(parseFloat(radii)) ? '0px' : radii;
};

// - border-radius css property not supported when used inside <dvt:node>
dvt.CSSStyle.prototype._setBorderRadius = function(key, val) {
  /*
   * border-radius: 1-4 length|% / 1-4 length|%;
   *
   * Note: order of 4 values: top-left, top-right, bottom-right, bottom-left.
   * If bottom-left is omitted it is the same as top-right. If bottom-right is omitted
   * it is the same as top-left.
   */
  var brArray = val.split('/');
  if (brArray[0] == null) {
    this._setStyleAttr(key, '0px');
    return;
  }
  // horizontal radii
  var brHorzArr = dvt.StringUtils.trim(brArray[0]).split(' ');
  var bRadius = null;

  switch (brHorzArr.length) {
    case 1:
    default :
      this._setStyleAttr(key, dvt.CSSStyle._getBorderRadius(brHorzArr[0]));
      // remove other border radius
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_LEFT_RADIUS, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_RIGHT_RADIUS, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_RIGHT_RADIUS, null);
      this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_LEFT_RADIUS, null);
      break;

      /*
 * only support 4 corner with the same radius

  case 2:
    bRadius = dvt.CSSStyle._getBorderRadius(brHorzArr[0]);
    this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_LEFT_RADIUS, bRadius);
    this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_RIGHT_RADIUS, bRadius);

    bRadius = dvt.CSSStyle._getBorderRadius(brHorzArr[1]);
    this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_RIGHT_RADIUS, bRadius);
    this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_LEFT_RADIUS, bRadius);
    break;

  case 3:
    this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_LEFT_RADIUS, dvt.CSSStyle._getBorderRadius(brHorzArr[0]));
    bRadius = dvt.CSSStyle._getBorderRadius(brHorzArr[1]);
    this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_RIGHT_RADIUS, bRadius);
    this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_RIGHT_RADIUS, dvt.CSSStyle._getBorderRadius(brHorzArr[2]));
    this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_LEFT_RADIUS, bRadius);
    break;

  case 4:
    this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_LEFT_RADIUS, dvt.CSSStyle._getBorderRadius(brHorzArr[0]));
    this._setStyleAttr(dvt.CSSStyle.BORDER_TOP_RIGHT_RADIUS, dvt.CSSStyle._getBorderRadius(brHorzArr[1]));
    this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_RIGHT_RADIUS, dvt.CSSStyle._getBorderRadius(brHorzArr[2]));
    this._setStyleAttr(dvt.CSSStyle.BORDER_BOTTOM_LEFT_RADIUS, dvt.CSSStyle._getBorderRadius(brHorzArr[3]));
    break;

  case 0:
  default:
    break;

      */
  }

  // vertical radii
  if (brArray.length == 2 && brArray[1] != null) {
    var brVertArr = dvt.StringUtils.trim(brArray[1]).split(' ');

    switch (brVertArr.length) {
      case 1:
        if (this.getStyle(key))
          this._setStyleAttr(key, this.getStyle(key) + ' ' + dvt.CSSStyle._getBorderRadius(brVertArr[0]));
        else
          this._setStyleAttr(key, dvt.CSSStyle._getBorderRadius(brVertArr[0]));
        break;

      case 0:
      default :
        break;
    }
  }

};


/**
 * Returns border radius as a number. If the radius were not set for this style, returns 0
 * @return {number} border radius
 */
dvt.CSSStyle.prototype.getBorderRadius = function() {
  if (this.getStyle(dvt.CSSStyle.BORDER_RADIUS) !== 'undefined' && this.getStyle(dvt.CSSStyle.BORDER_RADIUS) !== null)
    return dvt.CSSStyle.toNumber(this.getStyle(dvt.CSSStyle.BORDER_RADIUS));
  else
    return 0;
};

dvt.CSSStyle.prototype._setBackgroundRepeat = function(key, val) {
  var a = val.split(' ');

  //  - buttons look broken on safari
  // in Safari button -> background-repeat: repeat no-repeat
  if (a.length == 2) {
    // both repeat or no_repeat
    if (a[0] == a[1])
      val = a[0];
    else if (a[0] == dvt.CSSStyle.REPEAT && a[1] == dvt.CSSStyle.NO_REPEAT)
      val = dvt.CSSStyle.REPEAT_X;
    if (a[0] == dvt.CSSStyle.NO_REPEAT && a[1] == dvt.CSSStyle.REPEAT)
      val = dvt.CSSStyle.REPEAT_Y;
  }
  this._setStyleAttr(key, val);
};


/**
 * set a color attribute
 *
 * @param {string} key color attribute
 * @param {string} val is a string in color keyword or a numeric value in #AARRGGBB or #RRGGBB format
 */
dvt.CSSStyle.prototype._setColorAttr = function(key, val) {
  // TODO : This entire function seems unnecessary
  var color = dvt.CSSStyle._toColorVal(val);
  if (color) {
    this._setStyleAttr(key, color);
  }
  else if (dvt.CSSStyle._isColorValue(val)) {
    this._setStyleAttr(key, val);
  }
};


/**
 * If the given string is a color keyword, return its color value
 *
 * @param s string that may specify a color keyword
 * @return color value if the string is a color keyword.
 */
dvt.CSSStyle._toColorVal = function(val) {
  // TODO : This entire function seems unnecessary
  val = dvt.StringUtils.trim(val);

  // color name?
  var color = dvt.CSSStyle._NAMED_COLOR_MAP[val.toLowerCase()];
  if (color) {
    return color;
  }
  return null;
};

dvt.CSSStyle.prototype.setColor = function(key, val) {
  this._setStyleAttr(key, val);
};


/**
 * @private
 * @param value a number with unit
 */
dvt.CSSStyle._isValueInEM = function(value) {
  return value.toLowerCase().indexOf('em') >= 0;
};


/**
 * @private
 * @param key its value is a number with unit
 * @param fontSize (string) a number with unit
 *
 */
dvt.CSSStyle.prototype._resolveEMx = function(key, fontSize) {
  var value = this.getStyle(key);

  if (value && dvt.CSSStyle._isValueInEM(value)) {
    // if value is in EM unit, convert it to px so value no longer in EM
    if (fontSize) {
      this._setStyleAttr(key, String(Math.round(parseFloat(value) * parseFloat(fontSize))) + 'px');
      return true;
    }
    return false;
  }
  return true;
};


/**
 * @return font size if is a font size is specified and not in relative length unit(em)
 * otherwise return null
 */
dvt.CSSStyle.prototype.getAbsoluteFontSize = function() {
  // get the current font size
  var fontSize = this.getFontSize();
  if (fontSize && !dvt.CSSStyle._isValueInEM(fontSize)) {
    return fontSize;
  }
  return null;
};


/**
 * @param {string} fontSize to be used in resolving em if no fontSize specified in this css style
 */
dvt.CSSStyle.prototype.resolveEM = function(fontSize) {

  // try to resolved em unit with the current font size
  var myFontSize = this.getFontSize();

  if (myFontSize) {
    // FONT_SIZE value is in "em"
    if (dvt.CSSStyle._isValueInEM(myFontSize)) {
      // resolve fontSize and use this new fontSize value
      this._resolveEMx(dvt.CSSStyle.FONT_SIZE, fontSize);
    }
    // FONT_SIZE value is NOT in "em", use new fontSize value
    else {
      fontSize = myFontSize;
    }
  }

  var numList = dvt.CSSStyle._numericAttrsList;
  for (var i = 0; i < numList.length; i++) {
    if (!this._resolveEMx(numList[i], fontSize)) {
      return false;
    }
  }
  return true;
};


/**
 * return a copy of this object
 */
dvt.CSSStyle.prototype.clone = function() {
  var ret = new dvt.CSSStyle();
  for (var key in this._styleMap) {
    ret._setStyleAttr(key, this.getStyle(key));
  }
  return ret;
};


/**
 * Merge the properties of the given CSSStyle into this one.
 *
 * @param style properties to merge into this CSSStyle
 */
dvt.CSSStyle.prototype.merge = function(style) {
  if (style) {
    for (var key in style._styleMap) {
      this._setStyleAttr(key, style.getStyle(key));
    }
  }
  return this;
};


/**
 * Merge the properties of the given CSSStyle under this one.
 *
 * @param style properties to merge under this CSSStyle
 */
dvt.CSSStyle.prototype.mergeUnder = function(style) {
  if (style) {
    for (var key in style._styleMap) {
      if (!this.getStyle(key))
        this._setStyleAttr(key, style.getStyle(key));
    }
  }
  return this;
};


/**
 * Returns a inline style representation of the style attributes contained in this dvt.CSSStyle.
 * @return {string}
 */
dvt.CSSStyle.prototype.toString = function() {
  var strBuf = '';
  for (var key in this._styleMap) {
    strBuf += key + ':' + this.getStyle(key) + '; ';
  }
  return strBuf;
};

dvt.CSSStyle.prototype.getBackgroundImage = function() {
  var ret = this.getStyle(dvt.CSSStyle.BACKGROUND_IMAGE);

  var startx;
  var endx;

  if (ret && (ret instanceof dvt.CSSGradient)) {
    return ret;
  }

  //strip off the 'url(' and ')'
  if (ret) {
    startx = ret.indexOf('url(');
    endx = ret.lastIndexOf(')');
    if ((startx == 0) && (endx == (ret.length - 1))) {
      ret = ret.substring(4, endx);
    }
  }

  //strip off single or double quotes
  if (ret) {
    startx = ret.indexOf(dvt.CSSStyle._SINGLE_QUOTE);
    endx = ret.lastIndexOf(dvt.CSSStyle._SINGLE_QUOTE);
    if ((startx == 0) && (endx == (ret.length - 1))) {
      ret = ret.substring(1, endx);
    }
    else {
      startx = ret.indexOf(dvt.CSSStyle._DOUBLE_QUOTE);
      endx = ret.lastIndexOf(dvt.CSSStyle._DOUBLE_QUOTE);
      if ((startx == 0) && (endx == (ret.length - 1))) {
        ret = ret.substring(1, endx);
      }
    }
  }

  return ret;
};


/**
 * Determine if the given string specifies a color value.
 *
 * @param s string that may specify a color value
 *
 * @return true if the string specifies a color value, false otherwise
 */
dvt.CSSStyle._isColorValue = function(val) {
  val = dvt.StringUtils.trim(val);

  if (val.indexOf('rgb') == 0 || val.indexOf('#') == 0)
    return true;

  // color name?
  var color = dvt.CSSStyle._NAMED_COLOR_MAP[val.toLowerCase()];
  if (color) {
    return true;
  }
  return false;
};


/**
 * @private
 * #param val contain only one borderWidth value
 */
dvt.CSSStyle._isBorderWidthValue = function(val) {

  var bwidth = dvt.StringUtils.trim(val);
  if (dvt.CSSStyle._NAMED_WIDTH_MAP[bwidth])
    return true;

  return !isNaN(parseFloat(bwidth));
};

// val is a string contains up to 4 rgb colors, ex:
// border-color: rgb(221, 221, 216) rgb(185, 185, 132) rgb(121, 121, 117)
dvt.CSSStyle._parseBorderColorString = function(key, val) {

  var val = dvt.StringUtils.trim(val);
  var cArray = [];
  while (val != null && val.length > 0) {
    val = dvt.CSSStyle.parseBorderColor(val, cArray);
  }
  return cArray;
};

dvt.CSSStyle.parseBorderColor = function(val, cArray) {
  val = dvt.StringUtils.trim(val);
  var strLen = val.length;
  var endIndex = - 1;
  var colorObj;

  if (!val) {
    return val;
  }
  // rgb format?
  if (val.indexOf('rgb') == 0) {
    endIndex = val.indexOf(')') + 1;
    colorObj = val.slice(0, endIndex);
  }

  // color name?
  else {
    endIndex = val.indexOf(' ');
    if (endIndex == - 1)
      endIndex = strLen;
    var singleColor = val.slice(0, endIndex);

    colorObj = dvt.CSSStyle._toColorVal(singleColor);

    // hex color
    if (!colorObj) {
      colorObj = dvt.CSSStyle._parseHexColor(singleColor);
    }
  }

  if (colorObj) {
    cArray.push(colorObj);
    val = val.slice(endIndex);
  }
  return val;
};

// val is a string in #AARRGGBB or #RRGGBB format
dvt.CSSStyle._parseHexColor = function(s) {
  var n;
  var colorObj;
  if (s && s.length > 0) {
    var bHasAlpha = (s.length > 7);
    n = Number('0x' + s.substring(1));
    if (isNaN(n)) {
      n = 0;// assume black if we didn't get a valid numeric string
    }
    if (bHasAlpha) {
      var x = '#' + s.substring(3);
      colorObj = x;
    }
    else {
      colorObj = s;
    }
  }
  return colorObj;
};

// get padding-top, padding-right, padding-bottom and padding-left
// get border-top-width, border-right-width, border-bottom-width and border-left=width
// get margin-top, margin-right, margin-bottom and margin-left
//TODO: percent
dvt.CSSStyle.prototype._getSideWidth = function(key, shortKey) {
  var side = this.getStyle(key);
  if (!side) {
    side = this.getStyle(shortKey);
  }
  return dvt.CSSStyle.toNumber(side);
};

dvt.CSSStyle.prototype.getFontSize = function() {
  return this.getStyle(dvt.CSSStyle.FONT_SIZE);
};

// Returns a CSSStyle object as a merge of the array
dvt.CSSStyle.mergeStyles = function(styleArray) {
  var style = new dvt.CSSStyle();
  if (styleArray) {
    for (var i = 0; i < styleArray.length; i++) {
      style.merge(styleArray[i]);
    }
  }
  return style;
};


/**
 * Returns true if this object does not contain any style properties.
 * @return {boolean}
 */
dvt.CSSStyle.prototype.isEmpty = function() {
  for (var key in this._styleMap) {
    return false;
  }
  return true;
};


/**
 * Returns true if the text is set to align end.  Takes reading direction into account when dealing with values of
 * "left" and "right".
 * @param {dvt.Context} context
 * @return {boolean}
 */
dvt.CSSStyle.prototype.isTextAlignEnd = function(context) {
  var align = this.getStyle(dvt.CSSStyle.TEXT_ALIGN);
  if (align == 'end')
    return true;

  if (dvt.Agent.isRightToLeft(context)) {
    return (align == 'left');
  }
  else {
    return (align == 'right');
  }
};

dvt.CSSStyle.prototype.parseBackgroundPosition = function() {
  var s = this.getStyle(dvt.CSSStyle.BACKGROUND_POSITION);
  if (!s)
    return null;

  var sPosArray = s.split(' ');
  if (sPosArray.length == 0)
    return ['0%', '0%'];

  var posArray = ['50%', '50%'];
  var position;
  if (sPosArray.length > 0) {
    position = dvt.StringUtils.trim(sPosArray[0]);
    if (position == 'left') {
      posArray[0] = '0%';
    }
    else if (position == 'right') {
      posArray[0] = '100%';
    }
    else if (position == 'top') {
      posArray[1] = '0%';
    }
    else if (position == 'bottom') {
      posArray[1] = '100%';
    }
    // percent
    else if (position != 'center') {
      posArray[0] = position;
    }
  }
  if (sPosArray.length > 1) {
    position = dvt.StringUtils.trim(sPosArray[1]);
    if (position == 'left') {
      posArray[0] = '0%';
    }
    else if (position == 'right') {
      posArray[0] = '100%';
    }
    else if (position == 'top') {
      posArray[1] = '0%';
    }
    else if (position == 'bottom') {
      posArray[1] = '100%';
    }
    // percent
    else if (position != 'center') {
      posArray[1] = position;
    }

  }
  return posArray;
};

dvt.CSSStyle.prototype.getIconUrl = function() {
  return this.getStyle(dvt.CSSStyle.CONTENT);
};

dvt.CSSStyle.prototype.setIconUrl = function(url) {
  this._setStyleAttr(dvt.CSSStyle.CONTENT, url);
};


/**
 * Returns a string that can be used as a hash code for caching text measurements.  Includes all attributes which can
 * affect the size of text.
 * @return {string}
 */
dvt.CSSStyle.prototype.hashCodeForTextMeasurement = function() {
  // Use a combination of all attrs that affect dimensions calculations.
  var ret = '';
  if (this.getStyle(dvt.CSSStyle.FONT_FAMILY))
    ret += this.getStyle(dvt.CSSStyle.FONT_FAMILY);
  if (this.getStyle(dvt.CSSStyle.FONT_SIZE))
    ret += this.getStyle(dvt.CSSStyle.FONT_SIZE);
  if (this.getStyle(dvt.CSSStyle.FONT_STYLE))
    ret += this.getStyle(dvt.CSSStyle.FONT_STYLE);
  if (this.getStyle(dvt.CSSStyle.FONT_WEIGHT))
    ret += this.getStyle(dvt.CSSStyle.FONT_WEIGHT);

  return ret;
};

/**
 * Returns true if the specified skin is Alta or was developed after the Alta skin.
 * @param {string} skin
 * @return {boolean}
 */
dvt.CSSStyle.afterSkinAlta = function(skin) {
  return skin != null && skin != dvt.CSSStyle.SKIN_FUSION && skin != dvt.CSSStyle.SKIN_SKYROS;
};
/**
 * Base class for JSON components.
 * @class
 * @constructor
 * @extends {dvt.Container}
 */
dvt.BaseComponent = function() {
  // Components should implement newInstance factory methods instead of exposing contructors.
};

dvt.Obj.createSubclass(dvt.BaseComponent, dvt.Container);


/**
 * Initializes the component.
 * @param {dvt.Context} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @protected
 */
dvt.BaseComponent.prototype.Init = function(context, callback, callbackObj) {
  dvt.BaseComponent.superclass.Init.call(this, context);
  this._callback = callback;
  this._callbackObj = callbackObj;

  /**
   * Reference to the dvt.BaseComponentDefaults instance for this component.
   * @type {dvt.BaseComponentDefaults}
   * @protected
   */
  this.Defaults = null;

  /**
   * Reference to the options specifications for the component.
   * @protected
   */
  this.Options = null;
  /**
   * Reference to the component width.
   * @protected
   */
  this.Width = 0;
  /**
   * Reference to the component height.
   * @protected
   */
  this.Height = 0;
  /**
   * Cache for the options. Resets when options are reset.
   * @private
   */
  this._optionsCache = {};
  /**
   * Cache for render. Resets when there is a render.
   * @private
   */
  this._renderCache = {};
};


/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @protected
 */
dvt.BaseComponent.prototype.GetDefaults = function(skin) 
{
  // This function will work as long as this.Defaults is properly initialized.
  return this.Defaults ? this.Defaults.getDefaults(skin) : {};
};

/**
 * Returns the component description to be appended to the component's aria-label.
 * @return {string}
 * @protected
 */
dvt.BaseComponent.prototype.GetComponentDescription = function() 
{
  // TODO: Subclass overrides will be removed in 1.1.1 once dvt.Bundle.getTranslation is cleaned up.
  return dvt.Bundle.getTranslation(this.getOptions(), 'componentName');
};

/**
 * Returns true if this is the root component.
 * @protected
 * @return {boolean}
 */
dvt.BaseComponent.prototype.IsParentRoot = function() {
  return (this.getParent() == this.getCtx().getStage());
};

/**
 * Applies the component WAI-ARIA accessibility information if root component.
 * @protected
 */
dvt.BaseComponent.prototype.UpdateAriaAttributes = function() {
  if (this.IsParentRoot()) {
    // Set up the aria role and label for this component for accessibility without deferring
    this.getCtx().setAriaRole('application');
    this.getCtx().setAriaLabel(dvt.Bundle.getTranslatedString(dvt.Bundle.UTIL_PREFIX, 'COLON_SEP_LIST',
        [dvt.Bundle.getTranslatedString(dvt.Bundle.UTIL_PREFIX, 'DATA_VISUALIZATION'), dvt.StringUtils.processAriaLabel(this.GetComponentDescription())]));
  }
};

/**
 * Specifies the options specifications for this component.
 * @param {object} options The object containing options specifications for this component.
 * @protected
 */
dvt.BaseComponent.prototype.SetOptions = function(options) {
  // Subclasses should override
};

/**
 * Returns the options specifications for this component.
 * @return {object} options The object containing options specifications for this component.
 */
dvt.BaseComponent.prototype.getOptions = function() {
  if (!this.Options)
    this.Options = this.GetDefaults();

  return this.Options;
};

/**
 * Applies the specified options on top of the existing properties.  This function is only supported after the
 * component is initially rendered.
 * @param {object} options The object containing data and specifications for this component.
 */
dvt.BaseComponent.prototype.applyOptions = function(options) 
{
  if (!this.Options || !options)
    return;

  // Merge the new properties with the existing ones and set
  this.SetOptions(dvt.JsonUtils.merge(options, this.Options));
};

/**
 * Renders the component with the specified options object.  If no options are supplied to a component
 * that has already been rendered, the component will be rerendered to the specified size.
 * @param {object} options The object containing data and specifications for this component.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
dvt.BaseComponent.prototype.render = function(options, width, height) 
{
  // Subclasses should override
};

/**
 * Fires the ready event to notify the component owner that the render is complete. Should be called by component when it's ready.
 * @protected
 */
dvt.BaseComponent.prototype.RenderComplete = function() 
{
  this.dispatchEvent(dvt.EventFactory.newReadyEvent());
};

/**
 * Returns the width of this component
 * @return {number}
 */
dvt.BaseComponent.prototype.getWidth = function() 
{
  return this.Width;
};

/**
 * Returns the height of this component
 * @return {number}
 */
dvt.BaseComponent.prototype.getHeight = function() 
{
  return this.Height;
};

/**
 * Highlights the specified categories.
 * @param {array} categories The array of categories whose data items will be highlighted. If null or empty, all
 *                           highlighting will be removed.
 */
dvt.BaseComponent.prototype.highlight = function(categories) {
  // subclasses should override if highlightedCategories is supported. Called from JET to avoid re-render.
};

/**
 * Selects the specified items.
 * @param {array} selection The array of selected items.
 */
dvt.BaseComponent.prototype.select = function(selection) {
  // subclasses should override if selection is supported. Called from JET to avoid re-render.
};

/**
 * Dispatches the event to the callback function.
 * @param {object} event The event to be dispatched.
 */
dvt.BaseComponent.prototype.dispatchEvent = function(event) {
  dvt.EventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
};

/**
 * @override
 */
dvt.BaseComponent.prototype.getDimensionsWithStroke = function(targetCoordinateSpace) {
  return this.getDimensions(targetCoordinateSpace);
};

/**
 * Returns this component's event manager
 * @return {dvt.EventManager}
 */
dvt.BaseComponent.prototype.getEventManager = function() {
  // subclasses should override
  return null;
};

/**
 * Returns the element that is the current keyboard focus
 * @return {DOMElement}
 */
dvt.BaseComponent.prototype.getKeyboardFocus = function() {
  var eventManager = this.getEventManager();
  if (eventManager)
    return eventManager.getFocus() ? eventManager.getFocus().getTargetElem() : null;
  return null;
};

/**
 * Initialize/clear the render cache. Cleared on each render.
 * // TO DO: this will eventually be moved to the render method.
 */
dvt.BaseComponent.prototype.clearRenderCache = function() {
  this._renderCache = {};
};

/**
 * Initialize/clear the options cache. Cleared on each setOptions.
 * // TO DO: this will eventually be moved to the SetOptions method
 */
dvt.BaseComponent.prototype.clearOptionsCache = function() {
  this._optionsCache = {};
};

/**
 * Returns the render cache. Cleared on each render.
 * @return {object}
 */
dvt.BaseComponent.prototype.getRenderCache = function() {
  return this._renderCache;
};

/**
 * Returns the options cache. Cleared on each setOptions
 * @return {object}
 */
dvt.BaseComponent.prototype.getOptionsCache = function() {
  return this._optionsCache;
};
/**
 * Base class for JSON component defaults.
 * @class
 * @constructor
 * @extends {dvt.Obj}
 */
dvt.BaseComponentDefaults = function() {
  this.Init();
};

dvt.Obj.createSubclass(dvt.BaseComponentDefaults, dvt.Obj);

/** @const **/
dvt.BaseComponentDefaults.FONT_SIZE = 'font-size: ';

/** @const **/
dvt.BaseComponentDefaults.FONT_SIZE_11 = dvt.BaseComponentDefaults.FONT_SIZE + '11px;';

/** @const **/
dvt.BaseComponentDefaults.FONT_SIZE_12 = dvt.BaseComponentDefaults.FONT_SIZE + '12px;';

/** @const **/
dvt.BaseComponentDefaults.FONT_SIZE_13 = dvt.BaseComponentDefaults.FONT_SIZE + '13px;';

/** @const **/
dvt.BaseComponentDefaults.FONT_SIZE_14 = dvt.BaseComponentDefaults.FONT_SIZE + '14px;';

/** @const **/
dvt.BaseComponentDefaults.FONT_WEIGHT_BOLD = 'font-weight: bold;';

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_SKYROS = 'font-family: tahoma, sans-serif;';

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA = "font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;";

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_11 = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA + dvt.BaseComponentDefaults.FONT_SIZE_11;

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_12 = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA + dvt.BaseComponentDefaults.FONT_SIZE_12;

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_13 = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA + dvt.BaseComponentDefaults.FONT_SIZE_13;

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_14 = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA + dvt.BaseComponentDefaults.FONT_SIZE_14;

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA + dvt.BaseComponentDefaults.FONT_WEIGHT_BOLD;

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD_11 = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD + dvt.BaseComponentDefaults.FONT_SIZE_11;

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD_12 = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD + dvt.BaseComponentDefaults.FONT_SIZE_12;

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD_13 = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD + dvt.BaseComponentDefaults.FONT_SIZE_13;

/** @const **/
dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD_14 = dvt.BaseComponentDefaults.FONT_FAMILY_ALTA_BOLD + dvt.BaseComponentDefaults.FONT_SIZE_14;

/**
 * Defines the progression of skin names.
 * @const
 * @private
 */
dvt.BaseComponentDefaults._SKINS = [dvt.CSSStyle.SKIN_FUSION, dvt.CSSStyle.SKIN_SKYROS, dvt.CSSStyle.SKIN_ALTA, dvt.CSSStyle.SKIN_NEXT];

/**
 * @param {object} defaultsMap A map of the skin names to the JSON of defaults.
 */
dvt.BaseComponentDefaults.prototype.Init = function(defaultsMap) {
  this._defaults = defaultsMap ? defaultsMap : {};

  // Initialize the defaults cache on the class if it doesn't already exist. This is used to prevent excess cloning and
  // merging of the defaults layers.
  if (!this.constructor.defaultsCache)
    this.constructor.defaultsCache = {};
};


/**
 * Returns the base skin name for this component
 * @return {String} The base skin name for this component
 */
dvt.BaseComponentDefaults.prototype.getBaseSkinName = function() 
{
  return dvt.CSSStyle.SKIN_NEXT;
};


/**
 * Combines the user options with the defaults for the specified version.  Returns the combined options object.  This
 * object will contain internal attribute values and should be accessed in internal code only.
 * @param {object} userOptions The object containing options specifications for this component.
 * @return {object} The combined options object.
 */
dvt.BaseComponentDefaults.prototype.calcOptions = function(userOptions) {
  var skin = userOptions ? userOptions['skin'] : null;
  var defaults = this.getDefaults(skin);

  // Use defaults if no overrides specified
  if (!userOptions)
    return defaults;
  else  // Merge the options object with the defaults
    return dvt.JsonUtils.merge(userOptions, defaults, this.getNoCloneObject());
};


/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 */
dvt.BaseComponentDefaults.prototype.getDefaults = function(skin) {
  if (!skin)
    skin = this.getBaseSkinName();

  // Return the cached defaults if available.
  if (this.constructor.defaultsCache[skin])
    return dvt.JsonUtils.clone(this.constructor.defaultsCache[skin]);
  else {
    // Note: Subsequent default objects are deltas on top of previous objects
    var skinIndex = Math.max(dvt.ArrayUtils.getIndex(dvt.BaseComponentDefaults._SKINS, skin), 0);
    var ret = dvt.JsonUtils.clone(this._defaults[dvt.BaseComponentDefaults._SKINS[0]]);
    for (var i = 1; i <= skinIndex; i++) {
      ret = dvt.JsonUtils.merge(this._defaults[dvt.BaseComponentDefaults._SKINS[i]], ret);
    }

    // Add to the cache and return. We need to clone to ensure the cached copy isn't changed.
    this.constructor.defaultsCache[skin] = dvt.JsonUtils.clone(ret);
    return ret;
  }
};

/**
 * Returns the object of keys not to be cloned.
 * @return {object} The object of keys not to be cloned
 */
dvt.BaseComponentDefaults.prototype.getNoCloneObject = function() 
{
  return {};
};
/**
 * ShowPopupBehavior property bag.
 * @param {string} popupId The id of the popup that will be fired.
 * @param {string} triggerType The interaction type that triggers the popup.
 * @param {string} alignId The id of the object that the popup will be aligned to.
 * @param {string} align  The alignment position for the popup.
 * @class
 * @constructor
 */
dvt.ShowPopupBehavior = function(popupId, triggerType, alignId, align) {
  this._popupId = popupId;
  this._triggerType = triggerType;
  this._alignId = alignId;
  this._align = align;
};

dvt.Obj.createSubclass(dvt.ShowPopupBehavior, dvt.Obj);

/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_ACTION = 'action';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_CLICK = 'click';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_CONTEXT_MENU = 'contextMenu';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_DBL_CLICK = 'dblClick';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_HOVER = 'mouseHover';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_OVER = 'mouseOver';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_DOWN = 'mouseDown';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_MOVE = 'mouseMove';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_UP = 'mouseUp';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_OUT = 'mouseOut';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_KEY_DOWN = 'keyDown';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_KEY_UP = 'keyUp';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_KEY_PRESS = 'keyPress';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_FOCUS = 'focus';
/** @const **/
dvt.ShowPopupBehavior.TRIGGER_TYPE_BLUR = 'blur';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_AFTER_START = 'afterStart';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_AFTER_END = 'afterEnd';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_BEFORE_START = 'beforeStart';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_BEFORE_END = 'beforeEnd';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_END_AFTER = 'endAfter';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_END_BEFORE = 'endBefore';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_START_AFTER = 'startAfter';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_START_BEFORE = 'startBefore';
/** @const **/
dvt.ShowPopupBehavior.ALIGN_OVERLAP = 'overlap';

/**
 * Creates an returns an array of dvt.ShowPopupBehavior objects using the specified array of options objects.
 * @param {array} optionsArray
 * @return {array}
 */
dvt.ShowPopupBehavior.createBehaviors = function(optionsArray) {
  var ret = [];
  for (var i = 0; i < optionsArray.length; i++) {
    var options = optionsArray[i];
    ret.push(dvt.ShowPopupBehavior.newInstance(options));
  }
  return ret;
};

/**
 * Creates and returns a new instance of dvt.ShowPopupBehavior with properties parsed from the specified options object.
 * @param {object} options A object sent from the BaseJsonWriter describing the popup behavior configuration.
 * @return {dvt.ShowPopupBehavior}
 */
dvt.ShowPopupBehavior.newInstance = function(options) {
  return new dvt.ShowPopupBehavior(options['popupId'], options['triggerType'], options['alignId'], options['align']);
};

/**
 * Returns the id of the popup that will be fired by this instance.
 * @return {string} The id of the popup that will be fired.
 */
dvt.ShowPopupBehavior.prototype.getPopupId = function() {
  return this._popupId;
};

/**
 * Returns the interaction type that triggers the popup.
 * @return {string} The the interaction type that triggers the popup.
 */
dvt.ShowPopupBehavior.prototype.getTriggerType = function() {
  return this._triggerType;
};


/**
 * Returns the id of the object that the popup will be aligned to.
 * @return {string} The id of the object that the popup will be aligned to.
 */
dvt.ShowPopupBehavior.prototype.getAlignId = function() {
  return this._alignId;
};


/**
 * Returns the alignment position for the popup.
 * @return {string} The alignment position for the popup.
 */
dvt.ShowPopupBehavior.prototype.getAlign = function() {
  return this._align;
};
/**
 * dvt.ClientBehavior property bag.
 * @param {string} type The type of client behavior
 * @param {string} triggerType The interaction type that triggers the client behavior.
 * @class
 * @constructor
 */
dvt.ClientBehavior = function(type, triggerType) {
  this._type = type;
  this._triggerType = triggerType;
  this._props = {};
};

// TODO NAMESPACE ONLY USED BY DIAGRAM AND HV

dvt.Obj.createSubclass(dvt.ClientBehavior, dvt.Obj);

dvt.ClientBehavior.TRIGGER_TYPE_ACTION = 'action';
dvt.ClientBehavior.TRIGGER_TYPE_CLICK = 'click';

dvt.ClientBehavior.TYPE_ROW_DISCLOSURE = 'DvtRowDisclosureBehavior';
dvt.ClientBehavior.TYPE_DRILL = 'DvtDrillBehavior';
dvt.ClientBehavior.TYPE_ISOLATE_LEVELS = 'DvtIsolateLevelsBehavior';
dvt.ClientBehavior.TYPE_RESTORE = 'DvtRestoreBehavior';


/**
 * Returns the type of client behavior
 * @return {string} The type of client behavior
 */
dvt.ClientBehavior.prototype.getType = function() {
  return this._type;
};


/**
 * Returns the interaction type that triggers the client behavior.
 * @return {string} The interaction type that triggers the client behavior.
 */
dvt.ClientBehavior.prototype.getTriggerType = function() {
  return this._triggerType;
};

dvt.ClientBehavior.prototype.setProperty = function(propName, propValue) {
  this._props[propName] = propValue;
};

dvt.ClientBehavior.prototype.getProperty = function(propName) {
  return this._props[propName];
};

dvt.ClientBehavior.prototype.getProperties = function() {
  return this._props;
};
/**
 * A minimalist scrollbar.
 * @class
 * @constructor
 * @extends {dvt.Container}
 * @param {dvt.Context} context
 * @param {function=} callback The callback function
 * @param {object=} callbackObj The object that the callback function belongs to
 * @param {dvt.Displayable=} dragTarget The displayable to use for listening to drag events
 */
dvt.SimpleScrollbar = function(context, callback, callbackObj, dragTarget) {
  dvt.SimpleScrollbar.superclass.Init.call(this, context);
  this._callback = callback;
  this._callbackObj = callbackObj;
  this._dragTarget = dragTarget;
};

dvt.Obj.createSubclass(dvt.SimpleScrollbar, dvt.Container);


/**
 * Renders the simple scrollbar at the specified size.
 * @param {object} options The object containing specifications for the scrollbar.
 * @param {number} width The width of the scrollbar.
 * @param {number} height The height of the scrollbar.
 */
dvt.SimpleScrollbar.prototype.render = function(options, width, height) {
  this._width = width;
  this._height = height;

  // Global min/max
  this._globalMin = options['min'];
  this._globalMax = options['max'];

  this._isHoriz = options['isHorizontal'];
  this._isReversed = options['isReversed'];

  // Create background
  var background = new dvt.Rect(this.getCtx(), 0, 0, width, height);
  background.setSolidFill(options['backgroundColor']);
  background.setPixelHinting(true);
  this.addChild(background);

  // Create thumb
  this._thumb = new dvt.Rect(this.getCtx(), 0, 0, width, height);
  this._thumb.setSolidFill(options['color']);
  this._thumb.setPixelHinting(true);
  this.addChild(this._thumb);

  this._thumbMin = this._globalMin;
  this._thumbMax = this._globalMax;

  // Add hit area to make interaction with scrollbar easier
  var hitAreaSize = dvt.Agent.isTouchDevice() ? 8 : 4;
  var hitArea = new dvt.Rect(this.getCtx(), -hitAreaSize, -hitAreaSize, this._width + 2 * hitAreaSize, this._height + 2 * hitAreaSize);
  hitArea.setInvisibleFill();
  this.addChild(hitArea);

  // Add event listeners
  var hasDragTarget = this._dragTarget != null;
  dvt.SvgDocumentUtils.addDragListeners(hasDragTarget ? this._dragTarget : this, this._onDragStart, this._onDragMove, this._onDragEnd, this, !hasDragTarget);
  if (!dvt.Agent.isTouchDevice() && !hasDragTarget) {
    this.addEvtListener(dvt.MouseEvent.CLICK, this._onClick, false, this);
  }

  this._dragged = false; // flag to indicate mouse/touch down
};


/**
 * Sets the range of the scrollbar thumb.
 * @param {number} min The min value of the range.
 * @param {number} max The max value of the range.
 */
dvt.SimpleScrollbar.prototype.setViewportRange = function(min, max) {
  // Get the coords and modify the thumb
  var minCoord = this._getCoord(min);
  var maxCoord = this._getCoord(max);

  if (this._isHoriz) {
    this._thumb.setX(Math.min(minCoord, maxCoord));
    this._thumb.setWidth(Math.abs(maxCoord - minCoord));
  } else {
    this._thumb.setY(Math.min(minCoord, maxCoord));
    this._thumb.setHeight(Math.abs(maxCoord - minCoord));
  }

  this._thumbMin = min;
  this._thumbMax = max;
};


/**
 * Gets the coordinate of a value.
 * @param {number} value
 * @return {number} coord
 * @private
 */
dvt.SimpleScrollbar.prototype._getCoord = function(value) {
  var ratio = (value - this._globalMin) / (this._globalMax - this._globalMin);
  if (this._isReversed)
    ratio = 1 - ratio;

  if (this._isHoriz)
    return ratio * this._width;
  else
    return ratio * this._height;
};


/**
 * Gets the value from a coord.
 * @param {number} pageX
 * @param {number} pageY
 * @return {number} value
 * @private
 */
dvt.SimpleScrollbar.prototype._getValue = function(pageX, pageY) {
  var coord = this.stageToLocal(this.getCtx().pageToStageCoords(pageX, pageY));
  var ratio = this._isHoriz ? coord.x / this._width : coord.y / this._height;
  if (this._isReversed)
    ratio = 1 - ratio;
  ratio = Math.min(Math.max(ratio, 0), 1); // bound the value within min/max
  return this._globalMin + ratio * (this._globalMax - this._globalMin);
};


/**
 * Handles click event.
 * @param {object} event
 * @private
 */
dvt.SimpleScrollbar.prototype._onClick = function(event) {
  var val = this._getValue(event.pageX, event.pageY);
  if (val >= this._thumbMin && val <= this._thumbMax)
    return;

  var range = this._thumbMax - this._thumbMin;
  this._setViewportRange(val - range / 2, val + range / 2, dvt.SimpleScrollbarEvent.SUBTYPE_END);
};


/**
 * Handles drag start.
 * @param {object} event
 * @return {boolean} True if the drag is initiated.
 * @private
 */
dvt.SimpleScrollbar.prototype._onDragStart = function(event) {
  var val;
  if (event.touches) {
    if (event.touches.length != 1)
      return false;
    val = this._getValue(event.touches[0].pageX, event.touches[0].pageY);
  }
  else
    val = this._getValue(event.pageX, event.pageY);

  // Bypass thumb checking logic if we're scrolling on an outer container
  if (this._dragTarget || (val >= this._thumbMin && val <= this._thumbMax)) {
    this._dragged = true;
    this._prevVal = val;
    return true;
  }
  return false;
};


/**
 * Handles drag move.
 * @param {object} event
 * @private
 */
dvt.SimpleScrollbar.prototype._onDragMove = function(event) {
  if (!this._dragged)
    return;

  var val;
  if (event.touches) {
    if (event.touches.length != 1)
      return;
    val = this._getValue(event.touches[0].pageX, event.touches[0].pageY);
  }
  else
    val = this._getValue(event.pageX, event.pageY);

  var dragOffset = val - this._prevVal;
  // If the drag target is not the scrollbar, the thumb should move in the opposite direction as the drag target
  if (this._dragTarget)
    dragOffset *= -1;

  this._setViewportRange(this._thumbMin + dragOffset, this._thumbMax + dragOffset, dvt.SimpleScrollbarEvent.SUBTYPE_MOVE);
  this._prevVal = val;

  event.preventDefault();  // prevent scrolling the page
};


/**
 * Handles drag end.
 * @param {object} event
 * @private
 */
dvt.SimpleScrollbar.prototype._onDragEnd = function(event) {
  if (!this._dragged)
    return;

  if (event.touches)
    this._setViewportRange(this._thumbMin, this._thumbMax, dvt.SimpleScrollbarEvent.SUBTYPE_END);
  else {
    var val = this._getValue(event.pageX, event.pageY);
    var dragOffset = val - this._prevVal;
    this._setViewportRange(this._thumbMin + dragOffset, this._thumbMax + dragOffset, dvt.SimpleScrollbarEvent.SUBTYPE_END);
  }

  this._dragged = false;
};


/**
 * Sets the range of the scrollbar thumb and fires an overview event.
 * @param {number} min The min value of the range.
 * @param {number} max The max value of the range.
 * @param {string} eventSubtype The subtype of the simple scrollbar event.
 * @private
 */
dvt.SimpleScrollbar.prototype._setViewportRange = function(min, max, eventSubtype) {
  // Adjust min/max so that they are within globalMin/Max
  var range = max - min;
  if (min < this._globalMin) {
    min = this._globalMin;
    max = this._globalMin + range;
  }
  if (max > this._globalMax) {
    max = this._globalMax;
    min = this._globalMax - range;
  }

  this.setViewportRange(min, max);

  // Fire event
  if (this._callback) {
    var evt = new dvt.SimpleScrollbarEvent(eventSubtype, min, max);
    this._callback.call(this._callbackObj, evt, this);
  }
};
/**
 * A minimalist scrollable container that can scroll either vertically or horizontally, but not both.
 * Use DvtScrollableContainer if scrolling in both directions is required.
 * @class
 * @constructor
 * @extends {dvt.Container}
 * @param {dvt.Context} context
 * @param {number} width The width of the scrollable container
 * @param {number} height The height of the scrollable container
 * @param {boolean} isHorizontalScrolling True if this container scrolls horizontally
 */
dvt.SimpleScrollableContainer = function(context, width, height, isHorizontalScrolling) {
  dvt.SimpleScrollableContainer.superclass.Init.call(this, context);
  this._contentSize = isHorizontalScrolling ? width : height;
  this._width = width;
  this._height = height;

  this._background = new dvt.Rect(context, 0, 0, width, height);
  this._background.setInvisibleFill();
  this.addChild(this._background);

  this._container = new dvt.Container(context);
  this.addChild(this._container);

  this._isHorizontalScrolling = isHorizontalScrolling;
  this._isScrollbarVisible = false;

  if (!dvt.Agent.isTouchDevice()) {
    this.addEvtListener(dvt.MouseEvent.MOUSEWHEEL, this._onMouseWheel, false, this);
  }
};

dvt.Obj.createSubclass(dvt.SimpleScrollableContainer, dvt.Container);

/** @private */
dvt.SimpleScrollableContainer._SCROLLBAR_WIDTH = 3;
/** @private */
dvt.SimpleScrollableContainer._SCROLLBAR_GAP = 2;

/**
 * Returns the scrolling pane of this container
 * @return {dvt.Container}
 */
dvt.SimpleScrollableContainer.prototype.getScrollingPane = function() {
  return this._container;
};

/**
 * Prepares the content pane for  For performance, this component defers scrollbar rendering until this value is set
 * by the owning component.
 */
dvt.SimpleScrollableContainer.prototype.prepareContentPane = function() {
  var size = this._container.getDimensions();
  if (this._isHorizontalScrolling)
    this._contentSize = size.w + size.x;
  else
    this._contentSize = size.h + size.y;

  // TODO 
  // - Support customization of scrollbar color, width, etc.

  if (this.hasScrollingContent()) {
    // add padding to bottom to match top when scrolling
    if (this._isHorizontalScrolling)
      this._contentSize += size.x;
    else
      this._contentSize += size.y;

    // create masks and scrollbars
    if (!this._maskContainer) {
      var dims = new dvt.Rectangle(0, 0, this._width, this._height);
      this._fadeTop = new dvt.Mask(new dvt.LinearGradientFill(this._isHorizontalScrolling ? 0 : 270, ['#FFFFFF', '#FFFFFF'], [0, 1], [0, 0.1]), dims);
      this._fadeBottom = new dvt.Mask(new dvt.LinearGradientFill(this._isHorizontalScrolling ? 180 : 90, ['#FFFFFF', '#FFFFFF'], [0, 1], [0, 0.1]), dims);
      this._fadeTopBottom = new dvt.Mask(new dvt.LinearGradientFill(this._isHorizontalScrolling ? 180 : 90, ['#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF'], [0, 1, 1, 0], [0, 0.1, 0.9, 1]), dims);

      this._maskContainer = new dvt.Container(this.getCtx());
      this.addChild(this._maskContainer);
      var clipPath = new dvt.ClipPath();
      clipPath.addRect(0, 0, this._width, this._height);
      this._container.setClipPath(clipPath);
      this._maskContainer.addChild(this._container);

      this._scrollbar = new dvt.SimpleScrollbar(this.getCtx(), this._handleScrollbar, this, this);
      this._scrollbarTimer = new dvt.Timer(this.getCtx(), 100, this._hideScrollbar, this);
    }

    this._maskContainer.setMask(this._fadeBottom);
    // Creates the scrollbar
    var scrollbarOptions = {
      'color' : '#9E9E9E',
      'backgroundColor' : '#F0F0F0',
      'isHorizontal' : this._isHorizontalScrolling,
      'isReversed' : false,
      'min' : 0,
      'max' : this._contentSize
    };
    if (this._isHorizontalScrolling) {
      this._scrollbar.render(scrollbarOptions, this._getScrollbarWidth(), dvt.SimpleScrollableContainer._SCROLLBAR_WIDTH);
      this._scrollbar.setTranslate(dvt.SimpleScrollableContainer._SCROLLBAR_GAP, this._height - (dvt.SimpleScrollableContainer._SCROLLBAR_WIDTH + dvt.SimpleScrollableContainer._SCROLLBAR_GAP));
    } else {
      this._scrollbar.render(scrollbarOptions, dvt.SimpleScrollableContainer._SCROLLBAR_WIDTH, this._getScrollbarWidth());
      this._scrollbar.setTranslate(dvt.Agent.isRightToLeft(this.getCtx()) ? dvt.SimpleScrollableContainer._SCROLLBAR_GAP :
          this._width - (dvt.SimpleScrollableContainer._SCROLLBAR_WIDTH + dvt.SimpleScrollableContainer._SCROLLBAR_GAP),
          dvt.SimpleScrollableContainer._SCROLLBAR_GAP);
    }
    this._scrollbar.setViewportRange(0, this._getAvailSize());
    // make scrollbars visible for tests
    if (!dvt.Agent.isEnvironmentTest())
      this._scrollbar.setAlpha(0);
    this.addChild(this._scrollbar);
  } else {
    this.addChild(this._container);
    this.removeChild(this._maskContainer);
    this.removeChild(this._scrollbar);
  }
};

/**
 * Returns the scrollbar width after adjusting for any styling gaps
 * @return {number}
 * @private
 */
dvt.SimpleScrollableContainer.prototype._getScrollbarWidth = function() {
  return (this._isHorizontalScrolling ? this._width : this._height) - 2 * dvt.SimpleScrollableContainer._SCROLLBAR_GAP;
};

/**
 * Returns the current available size of the scrollable dimension for this container. The available width is returned
 * if horizontal scrolling is enabled and the available height otherwise.
 * @return {number}
 * @private
 */
dvt.SimpleScrollableContainer.prototype._getAvailSize = function() {
  return (this._isHorizontalScrolling ? this._width : this._height);
};

/**
 * Fades out the scrollbar
 * @param {dvt.BaseEvent} event
 * @private
 */
dvt.SimpleScrollableContainer.prototype._hideScrollbar = function(event) {
  if (this._isScrollbarVisible) {
    this._isScrollbarVisible = false;
    this._scrollbarTimer.reset();
    this._fadeOutAnim = new dvt.AnimFadeOut(this.getCtx(), this._scrollbar, 0.2);
    this._fadeOutAnim.play();
  }
};

/**
 * Displays the scrollbar and sets/resets a scrollbar fade out timer
 * @param {dvt.BaseEvent} event
 * @private
 */
dvt.SimpleScrollableContainer.prototype._showScrollbar = function(event) {
  if (!this._isScrollbarVisible) {
    if (this._fadeOutAnim) {
      this._fadeOutAnim.stop(true);
      this._fadeOutAnim = null;
    }
    this._scrollbar.setAlpha(1);
    this._isScrollbarVisible = true;
    this._scrollbarTimer.start();
  } else {
    this._scrollbarTimer.reset();
    this._scrollbarTimer.start();
  }
};

/**
 * Updates the masking fade effects to indicate scrollable regions
 * @param {number} translate The scrollbar translation
 * @private
 */
dvt.SimpleScrollableContainer.prototype._updateFade = function(translate) {
  if (translate == 0) // scrolled to the top, show bottom mask only
    this._maskContainer.setMask(this._fadeBottom);
  else if (translate + this._getAvailSize() >= this._contentSize) // scrolled to the bottom, show top mask only
    this._maskContainer.setMask(this._fadeTop);
  else // scrolled to the middle, show mask at top and bottom
    this._maskContainer.setMask(this._fadeTopBottom);
};

/**
 * Scrolls the container on mouse wheel.
 * @param {dvt.BaseEvent} event
 * @private
 */
dvt.SimpleScrollableContainer.prototype._onMouseWheel = function(event) {
  if (!this.hasScrollingContent())
    return;

  this._showScrollbar();

  var delta = event.wheelDelta != null ? event.wheelDelta : 0;
  // Firefox flips the mouse wheel delta
  if (dvt.Agent.isPlatformGecko())
    delta *= -1;

  var newTranslate = -1 * (this._isHorizontalScrolling ? this._container.getTranslateX() : this._container.getTranslateY()) - 4 * delta;
  var minTranslate = 0;
  var maxTranslate = Math.max(this._contentSize - this._getAvailSize(), 0);
  var translate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);
  if (this._isHorizontalScrolling) {
    this._container.setTranslateX(translate * -1);
    this._scrollbar.setViewportRange(translate + this._width, translate);
  } else {
    this._container.setTranslateY(translate * -1);
    this._scrollbar.setViewportRange(translate, translate + this._height);
  }
  this._updateFade(translate);
  event.preventDefault();
};

/**
 * Handles the event fired by the scrollbar.
 * @param {dvt.SimpleScrollbarEvent} event
 * @private
 */
dvt.SimpleScrollableContainer.prototype._handleScrollbar = function(event) {
  this._showScrollbar();

  if (this._isHorizontalScrolling)
    this._container.setTranslateX(event.getNewMin() * -1);
  else
    this._container.setTranslateY(event.getNewMin() * -1);

  this._updateFade(event.getNewMin());
};

/**
 * Returns the width of this container
 * @return {number}
 */
dvt.SimpleScrollableContainer.prototype.getWidth = function() {
  return this._width;
};

/**
 * Returns the height of this container
 * @return {number}
 */
dvt.SimpleScrollableContainer.prototype.getHeight = function() {
  return this._height;
};

/**
 * Scrolls the container so that the displayable is visible.
 * @param {dvt.Displayable} displayable The displayable to view.
 */
dvt.SimpleScrollableContainer.prototype.scrollIntoView = function(displayable) {
  if (!this.hasScrollingContent())
    return;

  var dim = displayable.getDimensions(displayable.getParent());
  var size = this._container.getDimensions();
  var translate;
  if (this._isHorizontalScrolling) {
    var currTranslateX = -1 * this._container.getTranslateX();
    var maxTranslateX = dim.x - size.x;
    var minTranslateX = (dim.x + dim.w) - (this._width) + size.x;

    if (currTranslateX < minTranslateX) {
      this._container.setTranslateX(-1 * minTranslateX);
      this._scrollbar.setViewportRange(minTranslateX + this._width, minTranslateX);
      translate = minTranslateX;
    }
    else if (currTranslateX > maxTranslateX) {
      this._container.setTranslateX(-1 * maxTranslateX);
      this._scrollbar.setViewportRange(maxTranslateX + this._width, maxTranslateX);
      translate = maxTranslateX;
    }
  } else {
    var currTranslateY = -1 * this._container.getTranslateY();
    var maxTranslateY = dim.y - size.y;
    var minTranslateY = (dim.y + dim.h) - (this._height) + size.y;

    if (currTranslateY < minTranslateY) {
      this._container.setTranslateY(-1 * minTranslateY);
      this._scrollbar.setViewportRange(minTranslateY, minTranslateY + this._height);
      translate = minTranslateY;
    }
    else if (currTranslateY > maxTranslateY) {
      this._container.setTranslateY(-1 * maxTranslateY);
      this._scrollbar.setViewportRange(maxTranslateY, maxTranslateY + this._height);
      translate = maxTranslateY;
    }
  }
  if (translate != undefined)
    this._updateFade(translate);
};

/**
 * Returns whether or not content will scroll based on available space.
 * @return {boolean} true if content will scroll
 */
dvt.SimpleScrollableContainer.prototype.hasScrollingContent = function() {
  return this._contentSize > this._getAvailSize();
};
/**
 * Drag recognizer
 * @class dvt.DragRecognizer
 * @constructor
 */
dvt.DragRecognizer = function() {};

dvt.Obj.createSubclass(dvt.DragRecognizer, dvt.Obj);


/**
 * Notifies the component that a drag may have started.
 */
dvt.DragRecognizer.prototype.prepDrag = function() {
  // subclasses should override
};


/**
 * Notifies the component that a drag has been aborted.
 */
dvt.DragRecognizer.prototype.abortPrep = function() {
  // subclasses should override
};


/**
 * Returns true if the component allows drag. This function gives the peer the
 * chance to prevent a drag.  All other conditions for a drag
 * must be satisfied even if the peer returns true.
 */
dvt.DragRecognizer.prototype.recognizeDrag = function() {
  return true; // subclasses should override
};
/**
 * Drag source event handler.
 * @param {dvt.Context} context
 * @class dvt.DragSource
 * @constructor
 */
dvt.DragSource = function(context) {
  this.Init(context);
};

dvt.Obj.createSubclass(dvt.DragSource, dvt.Obj);

// Margin to add to drag feedback bounds to minimize clipping
dvt.DragSource.DRAG_FEEDBACK_MARGIN = 2;


/**
 * @param {dvt.Container} container
 * @param {dvt.Context} context
 */
dvt.DragSource.prototype.Init = function(context) {
  this._context = context;

  // current draggable object under the mouse pointer
  this._dragCandidate = null;

  // object being dragged
  this._dragObj = null;
  this._dragCoords = null;
};


/**
 * Returns the current drag candidate object.
 */
dvt.DragSource.prototype.getDragCandidate = function() {
  return this._dragCandidate;
};


/**
 * Sets the specified object as the current drag candidate, if it supports the DvtDraggable interface.
 * @param {object} obj
 */
dvt.DragSource.prototype.setDragCandidate = function(obj) {
  // a DnD candidate object must support all DvtDraggable methods
  if (obj && obj.isDragAvailable && obj.getDragTransferable)
    this._dragCandidate = obj;
  else
    this._dragCandidate = null;
};


/**
 * If there are any drag candidate, returns the client id of the drag component.
 * Otherwise returns null.
 */
dvt.DragSource.prototype.isDragAvailable = function(clientIds) {
  if (this._dragCandidate != null) {
    return this._dragCandidate.isDragAvailable(clientIds);
  }
  return null;
};


/**
 * If there are a drag candidate, return the dragTransferable object.
 */
dvt.DragSource.prototype.getDragTransferable = function(mouseX, mouseY) {
  // if there's anything to drag
  if (this._dragCandidate) {
    // store the dragObj and current mouse coords
    this._dragObj = this._dragCandidate;
    this._dragCoords = {
      x: mouseX, y: mouseY
    };

    return this._dragCandidate.getDragTransferable(mouseX, mouseY);
  }
  return null;
};


/**
 * Returns the feedback for the drag operation.
 */
dvt.DragSource.prototype.getDragOverFeedback = function(mouseX, mouseY) {
  // Hide the tooltip, since this is the last hook before the drag feedback is created
  this._context.getTooltipManager().hideTooltip();

  // Return the drag feedback
  var dragObj = this.getDragObject();
  if (dragObj && dragObj.getDragFeedback)
    return dragObj.getDragFeedback(mouseX, mouseY);
  else
    return null;
};


/**
 * Returns component specific context for the drag.
 */
dvt.DragSource.prototype.getDragContext = function(mouseX, mouseY) {
  if (this._dragObj && this._dragObj.getDragContext) {
    return this._dragObj.getDragContext(mouseX, mouseY);
  }
  return null;
};


/**
 * Returns the object currently being dragged.
 */
dvt.DragSource.prototype.getDragObject = function() {
  return this._dragObj;
};


/**
 * Returns the coordinates where the current drag was initiated.
 */
dvt.DragSource.prototype.getDragCoords = function() {
  return this._dragCoords;
};


/**
 * Return the offset to use for the drag feedback.
 */
dvt.DragSource.prototype.getDragOffset = function(mouseX, mouseY) {
  var offset = null;
  var feedback = this.getDragOverFeedback(mouseX, mouseY);
  if (feedback) {
    var bounds = dvt.DragAndDropUtils.getDragFeedbackBounds(feedback, this._context.getStage());

    //return displayables to their original condition, if necessary,
    //after determining bounds
    var dragObj = this.getDragObject();
    if (dragObj && dragObj.afterDragOverFeedback) {
      dragObj.afterDragOverFeedback(feedback);
    }

    if (bounds) {
      offset = {};
      offset.x = mouseX - bounds.x;
      offset.y = mouseY - bounds.y;
      offset.x += dvt.DragSource.DRAG_FEEDBACK_MARGIN;
      offset.y += dvt.DragSource.DRAG_FEEDBACK_MARGIN;
    }
  }
  return offset;
};


/**
 * Returns the offset from the mouse pointer where the drag is considered to be located.
 * @param {number} xOffset A suggested offset, usually the center of the drag feedback.
 * @param {number} yOffset A suggested offset, usually the center of the drag feedback.
 * @return {object}
 */
dvt.DragSource.prototype.getPointerOffset = function(xOffset, yOffset) {
  // Default implementation does not apply an offset, mouse position is used instead
  return {x: 0, y: 0};
};


/**
 * Called when a drag is started.
 */
dvt.DragSource.prototype.initiateDrag = function() {
  // On touch devices, when a drag is initiated, immediately cancel any touch and hold
  var tm = this.getTouchManager();
  if (dvt.Agent.isTouchDevice() && tm)
    tm.cancelTouchHold();
};


/**
 * Clean up after the drag is completed.
 */
dvt.DragSource.prototype.dragDropEnd = function() {
  this._dragCandidate = null;
  this._dragObj = null;
  this._dragCoords = null;
};


/**
 * Sets a touch manager object
 * @param {dvt.TouchManager} touch manager object
 */
dvt.DragSource.prototype.setTouchManager = function(touchManager) {
  this._touchManager = touchManager;
};


/**
 * Gets a touch manager object
 * @return {dvt.TouchManager} touch manager object
 */
dvt.DragSource.prototype.getTouchManager = function() {
  return this._touchManager;
};
/**
 * Drop target event handler.
 * @class dvt.DropTarget
 * @constructor
 */
dvt.DropTarget = function() {};

dvt.Obj.createSubclass(dvt.DropTarget, dvt.Obj);


/**
 * If a drop is possible at these mouse coordinates, returns the client id
 * of the drop component. Returns null if drop is not possible.
 * @param {number} mouseX x coordinate
 * @param {number} mouseY y coordinate
 * @param {object|array} clientIds object that contains client ids for potential drop targets
 * @param {function=} flavorAcceptanceFunc optional function for checking source and target data flavor compatibility
 * @return {string} client id of the drop component
 */
dvt.DropTarget.prototype.acceptDrag = function(mouseX, mouseY, clientIds, flavorAcceptanceFunc) {
  return null; // subclasses should override
};


/**
 * Paints drop site feedback as a drag enters the drop site.
 */
dvt.DropTarget.prototype.dragEnter = function() {
  // subclasses should override
};


/**
 * Cleans up drop site feedback as a drag exits the drop site.
 */
dvt.DropTarget.prototype.dragExit = function() {
  // subclasses should override
};


/**
 * Returns the object representing the drop site. This method is called when a valid
 * drop is performed.
 * @param {number} mouseX x coordinate
 * @param {number} mouseY y coordinate
 * @return {object} the object representing the drop site
 */
dvt.DropTarget.prototype.getDropSite = function(mouseX, mouseY) {
  return null; // subclasses should override
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * dvt.Button
 * @param {dvt.Context} context
 * @param {dvt.Displayable} upState
 * @param {dvt.Displayable} overState
 * @param {dvt.Displayable} downState
 * @param {dvt.Displayable} disabledState
 * @param {string} id
 * @param {object=} callback
 * @param {object=} callbackObj
 * @constructor
 */
dvt.Button = function(context, upState, overState, downState, disabledState, id, callback, callbackObj)
{
  this.Init(context, upState, overState, downState, disabledState, id, callback, callbackObj);
};

dvt.Obj.createSubclass(dvt.Button, dvt.Container);

dvt.Button.STATE_ENABLED = 0;
dvt.Button.STATE_OVER = 1;
dvt.Button.STATE_DOWN = 2;
dvt.Button.STATE_DISABLED = 3;

dvt.Button.NO_EVENT_LISTENERS = true;       //dont register any event listeners


/**
 * Initialization method called by the constructor
 *
 * @protected
 *
 * @param {dvt.Context} context  Platform specific context object
 * @param {dvt.Displayable} upState      Button up state
 * @param {dvt.Displayable} overState    Button over state
 * @param {dvt.Displayable} downState    Button down state
 * @param {dvt.Displayable} disabledState    Button disabled state
 * @param {string} id   The id for this object
 * @param {function} callback   The optional function that should be called on click event
 * @param {object} callbackObj  The optional object instance on which the callback function is defined
 *
 */
dvt.Button.prototype.Init = function(context, upState, overState, downState, disabledState, id, callback, callbackObj)
{
  dvt.Button.superclass.Init.call(this, context, null, id);

  this.setCallback(callback, callbackObj);

  //: don't do anything special in setUpState() during construction
  this._bDuringInit = true;

  this.setUpState(upState);
  this.setOverState(overState);
  this.setDownState(downState);

  if (disabledState) {
    this.setDisabledState(disabledState);
  }

  this.setEnabled(true);                 // enable mouse events for upState
  this.drawUpState();

  this._tooltip = null;

  this._bToggleEnabled = false;
  this._bToggled = false;

  //: don't do anything special in setUpState() during construction
  this._bDuringInit = false;
};


/**
  *  Returns the enabled state of this button
  *  @return {boolean}  true if the button is enabled,, else false.
  */
dvt.Button.prototype.isEnabled = function() {
  return this._enabled;
};


/**
  *   Enable/disable the button
  */
dvt.Button.prototype.setEnabled = function(bEnabled)
{
  if (this._enabled != bEnabled)
  {
    this._enabled = bEnabled;
    var clickEvent = dvt.Agent.isTouchDevice() ? dvt.TouchEvent.TOUCHSTART : dvt.MouseEvent.CLICK;

    if (bEnabled) {
      this.addEvtListener(dvt.MouseEvent.MOUSEOVER, this.OnMouseOver, false, this);
      this.addEvtListener(dvt.MouseEvent.MOUSEOUT, this.OnMouseOut, false, this);
      this.addEvtListener(dvt.MouseEvent.MOUSEDOWN, this.OnMouseDown, false, this);
      this.addEvtListener(dvt.MouseEvent.MOUSEUP, this.OnMouseUp, false, this);
      this.addEvtListener(clickEvent, this.OnClick, false, this);
      this.setCursor(dvt.SelectionEffectUtils.getSelectingCursor());
    }
    else {
      this.removeEvtListener(dvt.MouseEvent.MOUSEOVER, this.OnMouseOver, false, this);
      this.removeEvtListener(dvt.MouseEvent.MOUSEOUT, this.OnMouseOut, false, this);
      this.removeEvtListener(dvt.MouseEvent.MOUSEDOWN, this.OnMouseDown, false, this);
      this.removeEvtListener(dvt.MouseEvent.MOUSEUP, this.OnMouseUp, false, this);
      this.removeEvtListener(clickEvent, this.OnClick, false, this);
      this.setCursor(null);
    }
    // render disabled state
    this.initState();
  }
};


/**
 * Mouse over handler
 * @protected
 * @param {dvt.MouseEvent} event The dispatched event to be processed by the object
 */
dvt.Button.prototype.OnMouseOver = function(event) {
  if (!this._bToggled) {
    this.drawOverState();
  }
  else {
    this.drawOverDownState();
  }
};


/**
 * Mouse out handler
 * @protected
 * @param {dvt.MouseEvent} event The dispatched event to be processed by the object
 */
dvt.Button.prototype.OnMouseOut = function(event) {
  if (!this._bToggled) {
    this.drawUpState();
  }
  else {
    this.drawDownState();
  }
};


/**
 * Mouse down handler
 * @protected
 * @param {dvt.MouseEvent} event The dispatched event to be processed by the object
 */
dvt.Button.prototype.OnMouseDown = function(event) {
  this.drawDownState();
};


/**
 * Mouse up handler
 * @protected
 * @param {dvt.MouseEvent} event The dispatched event to be processed by the object
 */
dvt.Button.prototype.OnMouseUp = function(event) {
  if (!this._bToggled) {
    dvt.Agent.isTouchDevice() ? this.drawUpState() : this.drawOverState();
  }
  else {
    dvt.Agent.isTouchDevice() ? this.drawDownState() : this.drawOverDownState();
  }
};

/**
 * @protected
 * Click Handler
 * @param {dvt.MouseEvent} event The dispatched event to be processed by the object
 */
dvt.Button.prototype.OnClick = function(event) {
  if (this._bToggleEnabled) {
    this._bToggled = !this._bToggled;
    if (!this._bToggled) {
      dvt.Agent.isTouchDevice() ? this.drawUpState() : this.drawOverState();
    }
    else {
      dvt.Agent.isTouchDevice() ? this.drawDownState() : this.drawOverDownState();
    }
  }

  // Call the callback
  if (this._callback) {
    this._callback.call(this._callbackObj, event, this);
    event.stopPropagation();
    event.preventDefault();
  }
};

dvt.Button.prototype.drawUpState = function() {
  this._enableButton(this.upState, true);
  this._enableButton(this.downState, false);
  this._enableButton(this.overState, false);
  this._enableButton(this.disabledState, false);
  this._enableButton(this.overDownState, false);
};

dvt.Button.prototype.drawOverState = function() {
  this._enableButton(this.upState, false);
  this._enableButton(this.downState, false);
  this._enableButton(this.overState, true);
  this._enableButton(this.disabledState, false);
  this._enableButton(this.overDownState, false);
};

dvt.Button.prototype.drawDownState = function() {
  this._enableButton(this.upState, false);
  this._enableButton(this.downState, true);
  this._enableButton(this.overState, false);
  this._enableButton(this.disabledState, false);
  this._enableButton(this.overDownState, false);
};

dvt.Button.prototype.drawDisabledState = function() {
  this._enableButton(this.upState, false);
  this._enableButton(this.overState, false);
  this._enableButton(this.downState, false);
  this._enableButton(this.disabledState, true);
  this._enableButton(this.overDownState, false);
};


/**
 * Draws the over + down (hover selected) state.
 * If the state doesn't exist, defaults to drawing down state.
 */
dvt.Button.prototype.drawOverDownState = function() {
  if (this.overDownState) {
    this._enableButton(this.upState, false);
    this._enableButton(this.overState, false);
    this._enableButton(this.downState, false);
    this._enableButton(this.disabledState, false);
    this._enableButton(this.overDownState, true);
  }
  else
    this.drawDownState();
};


/**
  *   Show or hide the specified button face shape.
  */
dvt.Button.prototype._enableButton = function(button, enabled) {
  //   this._enableMouseEvents(button, enabled);
  if (button) {
    button.setAlpha(enabled ? 1 : 0);
  }

  //image button does not work when swapping different image states
  //   button.setVisible(enabled);
};


dvt.Button.prototype._enableMouseEvents = function(container, enabled) {
  if (container.setMouseEnabled) {
    container.setMouseEnabled(enabled);
  }
  var child = container.firstChild;

  //loop over all childs
  while (child != null) {
    this._enableMouseEvents(child, enabled);
    child = child.nextSibling;
  }
};

dvt.Button.prototype.setUpState = function(upState) {

  if ((!this.upState) || (this.upState != upState))
  {
    var enabled = false;
    if (this.upState) {
      enabled = this._isButtonEnabled(this.upState);
      this.removeChild(this.upState);
    }
  //: if the button has no enabled states, enable the up state by default
    else if (!this._bDuringInit) {
      var bDownEnabled = false;
      var bOverEnabled = false;
      var bDisabledEnabled = false;
      if (this.downState) {
        bDownEnabled = this._isButtonEnabled(this.downState);
      }
      if (this.overState) {
        bOverEnabled = this._isButtonEnabled(this.overState);
      }
      if (this.disabledState) {
        bDisabledEnabled = this._isButtonEnabled(this.disabledState);
      }
      if (!(bDownEnabled || bOverEnabled || bDisabledEnabled)) {
        enabled = true;
      }
    }

    if (upState) {
      this.addChild(upState);
    }

    this.upState = upState;
    this._enableButton(this.upState, enabled);
  }
};

dvt.Button.prototype.setDownState = function(downState) {

  if ((! this.downState) || (this.downState != downState))
  {
    var enabled = false;
    if (this.downState) {
      enabled = this._isButtonEnabled(this.downState);
      this.removeChild(this.downState);
    }

    if (downState) {
      this.addChild(downState);
    }

    this.downState = downState;
    this._enableButton(this.downState, enabled);
  }
};

dvt.Button.prototype.setOverState = function(overState) {

  if ((! this.overState) || (this.overState != overState))
  {
    var enabled = false;
    if (this.overState) {
      enabled = this._isButtonEnabled(this.overState);
      this.removeChild(this.overState);
    }

    if (overState) {
      this.addChild(overState);
    }

    this.overState = overState;
    this._enableButton(this.overState, enabled);
  }
};

dvt.Button.prototype.setDisabledState = function(disabledState) {

  if ((! this.disabledState) || (this.disabledState == disabledState))
  {
    var enabled = false;
    if (this.disabledState) {
      enabled = this._isButtonEnabled(this.disabledState);
      this.removeChild(this.disabledState);
    }

    if (disabledState) {
      this.addChild(disabledState);
    }

    this.disabledState = disabledState;
    this._enableButton(this.disabledState, enabled);
  }
};


/**
 * Sets the over + down (hover selected) state of a toggle button
 * @param {dvt.Shape} overDownState
 */
dvt.Button.prototype.setOverDownState = function(overDownState) {

  if ((! this.overDownState) || (this.overDownState == overDownState))
  {
    var enabled = false;
    if (this.overDownState) {
      enabled = this._isButtonEnabled(this.overDownState);
      this.removeChild(this.overDownState);
    }

    if (overDownState) {
      this.addChild(overDownState);
    }

    this.overDownState = overDownState;
    this._enableButton(this.overDownState, enabled);
  }
};


/**
 * Set the callback function handler
 *
 * @public
 *
 * @param {function} callback    The function that should be called on click event
 * @param {object} callbackObj   The object instance on which the callback function is defined
 */
dvt.Button.prototype.setCallback = function(callback, callbackObj) {
  this._callback = callback;
  this._callbackObj = callbackObj;
};

dvt.Button.prototype.setTooltip = function(tooltip) {
  this._tooltip = tooltip;

  // Assume that if using dvt.Button's tooltip getter/setter that we should set wai-aria properties
  // Otherwise, assume that button owner has separate logical object that will handle accessibility
  if (tooltip) {
    this.setAriaRole('button');
    this.setAriaProperty('label', tooltip);
  }
};

dvt.Button.prototype.getTooltip = function() {
  return this._tooltip;
};

dvt.Button.prototype.isClickEventPropagationStopped = function() {
  return true;
};


dvt.Button.prototype.initState = function()
{
  this.isEnabled() ? this.drawUpState() : this.drawDisabledState();
};


dvt.Button.prototype.setSize = function(width, height) {
  var up = this.upState;
  if (up) {
    if (up.setWidth && width) {
      up.setWidth(width);
    }
    if (up.setHeight && height) {
      up.setHeight(height);
    }
  }

  var down = this.downState;
  if (down) {
    if (down.setWidth && width) {
      down.setWidth(width);
    }
    if (down.setHeight && height) {
      down.setHeight(height);
    }
  }

  var over = this.overState;
  if (over) {
    if (over.setWidth && width) {
      over.setWidth(width);
    }
    if (over.setHeight && height) {
      over.setHeight(height);
    }
  }

  var disabled = this.disabledState;
  if (disabled) {
    if (disabled.setWidth && width) {
      disabled.setWidth(width);
    }
    if (disabled.setHeight && height) {
      disabled.setHeight(height);
    }
  }
};


/*
 * Called from DvtAfMenu and DvtAfGoButton to right align this component or its content.
 */
dvt.Button.prototype.rightAlign = function(maxw, ww, self) {
  var delta = maxw - ww;

  var up = this.upState;
  if (up && maxw) {
    if (self)
      up.setTranslateX(delta);
    else
      this._setChildX(up, delta);
  }

  var down = this.downState;
  if (down && maxw) {
    if (self)
      down.setTranslateX(delta);
    else
      this._setChildX(down, delta);
  }

  var over = this.overState;
  if (over && maxw) {
    if (self)
      over.setTranslateX(delta);
    else
      this._setChildX(over, delta);
  }

  var disabled = this.disabledState;
  if (disabled) {
    if (self)
      disabled.setTranslateX(delta);
    else
      this._setChildX(disabled, delta);
  }
};

dvt.Button.prototype._setChildX = function(state, delta) {
  for (var i = 0; i < state.getNumChildren(); i++) {
    var child = state.getChildAt(i);

    if (child instanceof dvt.Displayable) {
      child.setTranslateX(delta);
    }
  }
};

dvt.Button.prototype.setToggleEnabled = function(bToggleEnabled) {
  this._bToggleEnabled = bToggleEnabled;
};

dvt.Button.prototype.isToggleEnabled = function() {
  return this._bToggleEnabled;
};

dvt.Button.prototype.setToggled = function(bToggled) {
  if (this._bToggleEnabled) {
    this._bToggled = bToggled;
    if (!this._bToggled) {
      this.drawUpState();
    }
    else {
      this.drawDownState();
    }
  }
};

dvt.Button.prototype.isToggled = function() {
  return this._bToggled;
};

dvt.Button.prototype._isButtonEnabled = function(button) {
  var enabled = false;
  if (button) {
    enabled = button.getAlpha() > 0 ? true : false;
  }
  return enabled;
};

dvt.Button.prototype.getUpState = function() {
  return this.upState;
};

dvt.Button.prototype.getDownState = function() {
  return this.downState;
};

dvt.Button.prototype.getOverState = function() {
  return this.overState;
};


/**
 * Show keyboard focus
 */
dvt.Button.prototype.showKeyboardFocusEffect = function() {
  if (!this._keyboardFocusEffect)
    this._keyboardFocusEffect = this.CreateKeyboardFocusEffect();
  this._keyboardFocusEffect.show();
  this._isShowingKeyboardFocusEffect = true;
  this.getCtx().setActiveElement(this);
};


/**
 * Hide keyboard focus
 */
dvt.Button.prototype.hideKeyboardFocusEffect = function() {
  if (this._keyboardFocusEffect)
    this._keyboardFocusEffect.hide();
  this._isShowingKeyboardFocusEffect = false;
};


/**
 * Returns true if this navigable is showing its keyboard focus effect
 * @return {boolean} true if showing keyboard focus effect
 */
dvt.Button.prototype.isShowingKeyboardFocusEffect = function() {
  return this._isShowingKeyboardFocusEffect;
};


/**
 * @protected
 * Creates keyboard focus effect for the component
 * @return {dvt.KeyboardFocusEffect} keyboard focus effect
 */
dvt.Button.prototype.CreateKeyboardFocusEffect = function() {
  return new dvt.KeyboardFocusEffect(this.getCtx(), this, this.getDimensions(), null, null, true);
};

/**
 * Handle keyboard event
 * @param {dvt.KeyboardEvent} event keyboard event
 */
dvt.Button.prototype.handleKeyboardEvent = function(event) {
  var keyCode = event.keyCode;
  if (keyCode == dvt.KeyboardEvent.ENTER || keyCode == dvt.KeyboardEvent.SPACE) {
    // Call the callback
    if (this._callback) {
      this._callback.call(this._callbackObj, event, this);
      event.stopPropagation();
      event.preventDefault();
    }
  }
};

/**
 * dvt.TransientButton. This adds listeners that hide and show this button based
 * on focus, blur, mouse over, and mouse out events on the current stage.
 * @param {dvt.Context} context The rendering context.
 * @param {dvt.Displayable} upState The displayable representing this button's enabled state.
 * @param {dvt.Displayable} overState The displayable representing this button's hover state.
 * @param {dvt.Displayable} downState The displayable representing this button's active state.
 * @param {dvt.Displayable} disabledState The displayable representing this button's disabled state.
 * @param {string} callback The function that should be called to when this button is activated.
 * @param {object} callbackObj The object instance on which the callback function is defined.
 * @extends {dvt.Button}
 * @constructor
 */
dvt.TransientButton = function(context, upState, overState, downState, disabledState, callback, callbackObj)
{
  this.Init(context, upState, overState, downState, disabledState, callback, callbackObj);
};

dvt.Obj.createSubclass(dvt.TransientButton, dvt.Button);

/**
 * Attribute for button radius.
 * @const
 * @private
 */
dvt.TransientButton._DEFAULT_RADIUS = 16;

/**
 * Attribute for button background color.
 * @const
 * @private
 */
dvt.TransientButton._DEFAULT_FILL_COLOR = '#ffffff';

/**
 * Attribute for button border color.
 * @const
 * @private
 */
dvt.TransientButton._DEFAULT_BORDER_COLOR = '#d6d7d8';

/**
 * Helper method called by the constructor to initialize this object.
 * @param {dvt.Context} context The rendering context.
 * @param {dvt.Displayable} upState The displayable representing this button's enabled state.
 * @param {dvt.Displayable} overState The displayable representing this button's hover state.
 * @param {dvt.Displayable} downState The displayable representing this button's active state.
 * @param {dvt.Displayable} disabledState The displayable representing this button's disabled state.
 * @param {string} callback The function that should be called to when this button is activated.
 * @param {object} callbackObj The object instance on which the callback function is defined.
 * @protected
 */
dvt.TransientButton.prototype.Init = function(context, upState, overState, downState, disabledState, callback, callbackObj)
{
  dvt.TransientButton.superclass.Init.call(this, context, upState, overState, downState, disabledState, null, callbackObj, callback);
  var stage = context.getStage();
  // Need to set 'useCapture' to true for focus/blur event listeners since dvt.EventManager calls 'stopPropagation'
  stage.addEvtListener(DvtFocusEvent.FOCUS, this._onFocus, true, this);
  stage.addEvtListener(DvtFocusEvent.BLUR, this._onBlur, true, this);
  if (!dvt.Agent.isTouchDevice())
  {
    // IE does not always fire the appropriate mouseover and mouseout events, so use mouseenter and mouseleave instead
    if (dvt.Agent.isPlatformIE())
    {
      stage.addEvtListener('mouseenter', this._onMouseOver, false, this);
      stage.addEvtListener('mouseleave', this._onMouseOut, false, this);
    }
    else
    {
      stage.addEvtListener(dvt.MouseEvent.MOUSEOVER, this._onMouseOver, false, this);
      stage.addEvtListener(dvt.MouseEvent.MOUSEOUT, this._onMouseOut, false, this);
    }
  }
};

/**
 * Creates and returns the dvt.Circle representing the button's given state.
 * @param {dvt.Context} context The rendering context.
 * @param {string} stateURL The string URL of the button's state.
 * @return {dvt.Circle}
 */
dvt.TransientButton.getStateFromURL = function(context, stateURL)
{
  var radius = dvt.TransientButton._DEFAULT_RADIUS;
  var halfRadius = radius / 2;

  var background = new dvt.Circle(context, radius, radius, radius);
  background.setSolidFill(dvt.TransientButton._DEFAULT_FILL_COLOR);
  background.setSolidStroke(dvt.TransientButton._DEFAULT_BORDER_COLOR);
  var image = new dvt.Image(context, stateURL, halfRadius, halfRadius, radius, radius);

  background.addChild(image);
  return background;
};

/**
 * Sets this button as visible.
 */
dvt.TransientButton.prototype.show = function()
{
  this.setAlpha(1);
};

/**
 * Sets this button as hidden.
 */
dvt.TransientButton.prototype.hide = function()
{
  this.setAlpha(0);
};

/**
 * Focus handler.
 * @private
 * @param {DvtFocusEvent} event The dispatched event to be processed by the object.
 */
dvt.TransientButton.prototype._onFocus = function(event)
{
  this._isFocused = true;
  this.show();
};

/**
 * Blur handler.
 * @private
 * @param {DvtFocusEvent} event The dispatched event to be processed by the object.
 */
dvt.TransientButton.prototype._onBlur = function(event)
{
  this._isFocused = false;
  if (!this._isMouseOver)
    this.hide();
};

/**
 * Mouse over handler.
 * @private
 * @param {dvt.MouseEvent} event The dispatched event to be processed by the object.
 */
dvt.TransientButton.prototype._onMouseOver = function(event)
{
  if (this._mouseOutTimer && this._mouseOutTimer.isRunning())
    this._mouseOutTimer.stop();

  this._isMouseOver = true;
  this.show();
};

/**
 * Mouse out handler.
 * @private
 * @param {dvt.MouseEvent} event The dispatched event to be processed by the object.
 */
dvt.TransientButton.prototype._onMouseOut = function(event)
{
  if (!this._mouseOutTimer)
    this._mouseOutTimer = new dvt.Timer(this.getCtx(), 10, this._onMouseOutTimerEnd, this, 1);

  this._mouseOutTimer.reset();
  this._mouseOutTimer.start();
};

/**
 * Mouse out timer handler.
 * @private
 */
dvt.TransientButton.prototype._onMouseOutTimerEnd = function()
{
  this._isMouseOver = false;
  if (!this._isFocused)
    this.hide();
};

/**
 * @override
 */
dvt.TransientButton.prototype.OnMouseDown = function(event)
{
  dvt.TransientButton.superclass.OnMouseDown.call(this, event);
  //Event propagation is stopped because TransientButton should not initiate drag on mouse down event
  event.stopPropagation();
};

/**
 * @override
 */
dvt.TransientButton.prototype.OnMouseUp = function(event)
{
  dvt.TransientButton.superclass.OnMouseUp.call(this, event);
  //Event propagation is stopped because TransientButton should not initiate drag on mouse up event
  event.stopPropagation();
};
/**
 * A logical object for a set of displayables.
 * @interface
 */
var DvtLogicalObject = function() {};

dvt.Obj.createSubclass(DvtLogicalObject, dvt.Obj);


/**
 * Returns the array of DvtDisplayables corresponding to this object.
 * @return {array}
 */
DvtLogicalObject.prototype.getDisplayables = function() {};


/**
 * Optional function, used by dvt.EventManager's WAI-ARIA support to provide an aria-label whose creation is deferred
 * until needed.
 * @return {string}
 */
DvtLogicalObject.prototype.getAriaLabel = function() {};
/**
 * An object that displays tooltips.
 * @interface
 */
var DvtTooltipSource = function() {};

dvt.Obj.createSubclass(DvtTooltipSource, dvt.Obj);


/**
 * Returns the tooltip text for this object.
 * @param {dvt.Displayable} target The displayable that was the target of the event.
 * @return {string} The tooltip text for this object.
 */
DvtTooltipSource.prototype.getTooltip = function(target, x, y) {};


/**
 * Returns the datatip text for this object.
 * @param {dvt.Displayable} target The displayable that was the target of the event.
 * @return {string} The datatip text for this object.
 */
DvtTooltipSource.prototype.getDatatip = function(target, x, y) {};


/**
 * Returns the border color of the datatip for this object.
 * @return {string} The datatip border color.
 */
DvtTooltipSource.prototype.getDatatipColor = function() {};
/**
 * An object that can be selected.
 * @interface
 */
var DvtSelectable = function() {};

dvt.Obj.createSubclass(DvtSelectable, dvt.Obj);


/**
 * Returns true if this object is selectable.
 * @return {boolean} true if this object is selectable.
 */
DvtSelectable.prototype.isSelectable = function() {};


/**
 * Returns true if this object is selected.
 * @return {boolean} true if this object is selected.
 */
DvtSelectable.prototype.isSelected = function() {};


/**
 * Specifies whether this object is selected.
 * @param {boolean} selected True if this object is selected.
 * @param {boolean} isInitial (optional) True if it is an initial selection.
 * @protected
 */
DvtSelectable.prototype.setSelected = function(selected, isInitial) {};


/**
 * Displays the hover effect.
 */
DvtSelectable.prototype.showHoverEffect = function() {};


/**
 * Hides the hover effect.
 */
DvtSelectable.prototype.hideHoverEffect = function() {};
/**
 * An object that can handle keyboard events delegated to it by a dvt.EventManager
 * @interface
 */
var DvtComponentKeyboardHandler = function() {};


/**
 * Process a keyboard event
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} True if this DvtComponentKeyboardHandler consumed the event
 */
DvtComponentKeyboardHandler.prototype.handleKeyboardEvent = function(event) {};


/**
 * Hide the component's keyboard focus effect.  Used by the dvt.EventManager
 * to hide keyboard focus on one component when another component receives
 * focus via mouse (e.g., keyboard focus is on breadcrumbs but then you mouse
 * click on a treemap node).
 */
DvtComponentKeyboardHandler.prototype.hideKeyboardFocusEffect = function() {};
/**
 * An object that can receive keyboard focus, and thus can be navigated to via the keyboard
 * @interface
 */
var DvtKeyboardNavigable = function() {};

dvt.Obj.createSubclass(DvtKeyboardNavigable, dvt.Obj);


/**
 * Returns the next item to receive keyboard focus
 * @param {dvt.BaseEvent} event
 * @return {Object} The next item to get keyboard focus
 */
DvtKeyboardNavigable.prototype.getNextNavigable = function(event) {};

/**
 * Returns the DOM Element that respresents this keyboard navigable
 * @return {Object} This keyboard navigable's DOM Element
 */
DvtKeyboardNavigable.prototype.getTargetElem = function() {};


/**
 * Returns the bounding box for this navigable displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.
 * @param {dvt.Displayable=} targetCoordinateSpace The displayable defining the target coordinate space
 * @return {dvt.Rectangle}
 */
DvtKeyboardNavigable.prototype.getKeyboardBoundingBox = function(targetCoordinateSpace) {};


/**
 * Show a visual effect to indicate if this DvtKeyboardNavigable has keyboard focus
 */
DvtKeyboardNavigable.prototype.showKeyboardFocusEffect = function() {};


/**
 * Hide the visual effect to indicate if this DvtKeyboardNavigable has keyboard focus
 */
DvtKeyboardNavigable.prototype.hideKeyboardFocusEffect = function() {};


/**
 * Returns true if this navigable is showing its keyboard focus effect
 * @return {Boolean}
 */
DvtKeyboardNavigable.prototype.isShowingKeyboardFocusEffect = function() {};


/**
 * Optional method to implement. Returns the location for where a context menu should appear.
 * @return {dvt.Point}
 */
DvtKeyboardNavigable.prototype.getContextMenuLocation = function() {};

/**
 * Optional method to implement. Returns where the tooltip should appear on keyboard navigation.
 * @return {dvt.Point}
 */
DvtKeyboardNavigable.prototype.getKeyboardTooltipLocation = function() {};
/**
 * An object that can belongs to a category.
 * @interface
 */
var DvtCategoricalObject = function() {};

dvt.Obj.createSubclass(DvtCategoricalObject, dvt.Obj);

/**
 * Returns an array containing all categories to which this object belongs.
 * @return {array} The array of categories.
 */
DvtCategoricalObject.prototype.getCategories = function() {};

/**
 * Optional API for the object to perform its own highlighting. Can be overridden if the highlight effect is not a
 * simple alpha adjustment of the displayables.
 * @param {boolean} bDimmed True if the object should be dimmed.
 * @param {number} alpha The alpha to use for the highlighting.
 */
DvtCategoricalObject.prototype.highlight = function(bDimmed, alpha) {};
/**
 * An object that displays context menus.
 * @interface
 */
var DvtContextMenuSource = function() {};

dvt.Obj.createSubclass(DvtContextMenuSource, dvt.Obj);

/**
 * Returns the x,y coordinate of the upper left hand corner for the context menu, when the context menu
 * is triggered by a keyboard shortcut
 * Optional method to implement.
 * @return {dvt.Point}
 */
DvtContextMenuSource.prototype.getContextMenuLocation = function() {};
/**
 * An object that displays popups.
 * @interface
 */
var DvtPopupSource = function() {};

dvt.Obj.createSubclass(DvtPopupSource, dvt.Obj);


/**
 * Returns the server side id for this object, which is used to set context on
 * the server.
 * @return {string} The server side id for this object.
 */
DvtPopupSource.prototype.getId = function() {};


/**
 * Returns the array of showPopupBehaviors for the object.
 * @return {array} The array of applicable DvtShowPopupBehaviors
 */
DvtPopupSource.prototype.getShowPopupBehaviors = function() {};
/**
 *  Provides automation services for a DVT component.
 *  @param {Object} dvtComponent
 *  @constructor
 */
dvt.Automation = function(dvtComponent) {};

dvt.Obj.createSubclass(dvt.Automation, dvt.Obj);

/**
 * @const
 */
dvt.Automation.TOOLTIP_SUBID = 'tooltip';

/**
 * Returns the subId corresponding to the SVG DOM Element.
 * @param {SVGElement} domElement The SVG DOM Element used in determining the subId
 * @return {String} The corresponding subId
 */
dvt.Automation.prototype.getSubIdForDomElement = function(domElement) {
  var displayable = dvt.Automation._findDisplayable(domElement);
  if (displayable && !(displayable instanceof Array))
    return this.GetSubIdForDomElement(displayable);
  else if (domElement) { // tooltip automation
    if (this.IsTooltipElement(domElement))
      return dvt.Automation.TOOLTIP_SUBID;
  }
  return null;
};


/**
 * Returns the subId corresponding to the dvt.Displayable.
 * @param {dvt.Displayable} displayable The dvt.Displayable used in determining the subId
 * @return {String} The corresponding subId
 * @protected
 */
dvt.Automation.prototype.GetSubIdForDomElement = function(displayable) {
  //subclasses should override
  return null;
};


/**
 * Returns the SVG DOM Element corresponding to the given subId
 * @param {String} subId The subId used to locate a SVG DOM Element
 * @return {SVGElement} The SVG DOM Element
 */
dvt.Automation.prototype.getDomElementForSubId = function(subId) {
  //subclasses should override
  return null;
};


/**
 * Finds the dvt.Displayable for a DOM Element
 * @param {SVGElement} domElement The SVG DOM Element to find a dvt.Displayable for
 * @return {dvt.Displayable} The displayable corresponding to the DOM Element or null
 * @private
 */
dvt.Automation._findDisplayable = function(domElement) {
  while (domElement) {
    // If this object has a displayable, return it
    if (domElement._obj)
      return domElement._obj;
    else // Otherwise look at the parent
      domElement = domElement.parentNode;
  }
  return null;
};


/**
 * Finds the tooltip DOM Element associated with the dvtComponent
 * @param {Object} dvtComponent
 * @param {String} tooltipId (optional) Used when dvtComponent is a dvt.Chart to get datatip or tooltip
 * @return {SVGElement} The DOM Element corresponding to the tooltip, if it is visible, or null
 * @protected
 */
dvt.Automation.prototype.GetTooltipElement = function(dvtComponent, tooltipId) {
  if (dvtComponent) {
    var tooltipElem = dvtComponent.getCtx().getTooltipManager(tooltipId).getTooltipElem();
    return tooltipElem.style.visibility == 'hidden' ? null : tooltipElem;
  }

  return null;
};

/**
 * Returns true if the given DOM element is used for tooltips
 * @param {SVGElement} domElement The SVG DOM Element to inspect
 * @return {boolean} True if the domElement is used for tooltips
 * @protected
 */
dvt.Automation.prototype.IsTooltipElement = function(domElement) {
  var id = domElement.getAttribute('id');
  if (id && id.indexOf(dvt.HtmlTooltipManager._TOOLTIP_DIV_ID) == 0)
    return true;
  return false;
};
/**
 * Simple logical object for custom datatip support.
 * @param {dvt.TooltipManager} tooltipManager
 * @param {function} tooltipFunction The callback function used to render the datatip content
 * @param {string} datatipColor The border color of the datatip.
 * @param {object=} dataContext Object passed into the callback function
 * @class
 * @constructor
 */
dvt.CustomDatatipPeer = function(tooltipManager, tooltipFunction, datatipColor, dataContext) {
  this.Init(tooltipManager, tooltipFunction, datatipColor, dataContext);
};

dvt.Obj.createSubclass(dvt.CustomDatatipPeer, dvt.Obj);

/**
 * @override
 */
dvt.CustomDatatipPeer.prototype.Init = function(tooltipManager, tooltipFunction, datatipColor, dataContext) {
  this._tooltipManager = tooltipManager;
  this._tooltipFunction = tooltipFunction;
  this._datatipColor = datatipColor;
  this._dataContext = dataContext;
};


/**
 * @override
 */
dvt.CustomDatatipPeer.prototype.getDatatip = function(target) {
  return this._tooltipManager.getCustomTooltip(this._tooltipFunction, this._dataContext);
};

/**
 * @override
 */
dvt.CustomDatatipPeer.prototype.getDatatipColor = function(target) {
  return this._datatipColor;
};
/**
 * Simple logical object for tooltip support.
 * @param {string} tooltip The tooltip to display.
 * @param {string} datatip The datatip to display.
 * @param {string} datatipColor The border color of the datatip.
 * @param {object=} params Optional object containing additional parameters for use by component.
 * @class
 * @constructor
 * @implements {DvtTooltipSource}
 */
dvt.SimpleObjPeer = function(tooltip, datatip, datatipColor, params) {
  this.Init(tooltip, datatip, datatipColor, params);
};

dvt.Obj.createSubclass(dvt.SimpleObjPeer, dvt.Obj);


/**
 * @param {string} tooltip The tooltip to display.
 * @param {string} datatip The datatip to display.
 * @param {string} datatipColor The border color of the datatip.
 * @param {object=} params Optional object containing additional parameters for use by component.
 */
dvt.SimpleObjPeer.prototype.Init = function(tooltip, datatip, datatipColor, params) {
  this._tooltip = tooltip;
  this._datatip = datatip;
  this._datatipColor = datatipColor;
  this._params = params;
};


/**
 * Specifies the tooltip for this object.
 * @param {string} tooltip
 */
dvt.SimpleObjPeer.prototype.setTooltip = function(tooltip) {
  this._tooltip = tooltip;
};


/**
 * Specifies the datatip for this object.
 * @param {string} datatip
 */
dvt.SimpleObjPeer.prototype.setDatatip = function(datatip) {
  this._datatip = datatip;
};


/**
 * Specifies the datatip color for this object.
 * @param {string} datatipColor
 */
dvt.SimpleObjPeer.prototype.setDatatipColor = function(datatipColor) {
  this._datatipColor = datatipColor;
};


/**
 * Returns additional parameters for this object, if available.
 * @return {object}
 */
dvt.SimpleObjPeer.prototype.getParams = function() {
  return this._params;
};

//---------------------------------------------------------------------//
// Tooltip Support: DvtTooltipSource impl                              //
//---------------------------------------------------------------------//


/**
 * @override
 */
dvt.SimpleObjPeer.prototype.getTooltip = function(target) {
  return this._tooltip;
};


/**
 * @override
 */
dvt.SimpleObjPeer.prototype.getDatatip = function(target) {
  return this._datatip;
};


/**
 * @override
 */
dvt.SimpleObjPeer.prototype.getDatatipColor = function(target) {
  return this._datatipColor;
};
/**
 * @constructor
 */
dvt.Agent = function() {
};

dvt.Obj.createSubclass(dvt.Agent, dvt.Obj);

/**
 * @const
 */
dvt.Agent.UNKNOWN_VERSION = -1;

/**
 * @const
 */
dvt.Agent.IE_PLATFORM = 'ie';
/**
 * @const
 */
dvt.Agent.GECKO_PLATFORM = 'gecko';
/**
 * @const
 */
dvt.Agent.WEBKIT_PLATFORM = 'webkit';
/**
 * @const
 */
dvt.Agent.UNKNOWN_PLATFORM = 'unknown';

/**
 * @const
 */
dvt.Agent.WINDOWS_OS = 'Windows';
/**
 * @const
 */
dvt.Agent.SOLARIS_OS = 'Solaris';
/**
 * @const
 */
dvt.Agent.MAC_OS = 'Mac';
/**
 * @const
 */
dvt.Agent.UNKNOWN_OS = 'Unknown';

/**
 * @const
 */
dvt.Agent.FOCUS_COLOR_DEFAULT = '#0645AD';
/**
 * @const
 */
dvt.Agent.FOCUS_COLOR_IE = '#090909';


/**
 * Returns true if creation of aria-label attributes can be deferred.  This prevents costly string generation from
 * becoming necessary across the entire data set.  When deferred, the getAriaLabel API should be implemented on
 * the DvtLogicalObject implementation.
 * @return {boolean}
 */
dvt.Agent.deferAriaCreation = function() {
  return !dvt.Agent.isTouchDevice() && !dvt.Agent.isEnvironmentTest();
};


/**
 * Returns the ratio between physical pixels and device independent pixels for the current device.
 * @return {number} the device pixel ratio
 */
dvt.Agent.getDevicePixelRatio = function() {
  dvt.Agent._initialize();
  return dvt.Agent._devicePixelRatio;
};


/**
 * Returns the position of the specified DOM element in page coordinates.
 * @param {object} element
 * @return {dvt.Point}
 */
dvt.Agent.getElementPosition = function(element) {
  if (dvt.Agent.isPlatformIE())
    return dvt.Agent._getElementPositionIE(element);
  else
    return dvt.Agent._getElementPositionDefault(element);
};


/**
 * Returns the platform string.  Valid values are dvt.Agent.***_PLATFORM.
 * @return {string}
 */
dvt.Agent.getPlatform = function() {
  dvt.Agent._initialize();
  return dvt.Agent._platform;
};


/**
 * Returns a guess of the operating system based on the user agent.
 * @return {string}
 */
dvt.Agent.getOS = function() {
  dvt.Agent._initialize();
  return dvt.Agent._os;
};


/**
 * Returns the version of the browser reported by the user agent.
 * @return {number}
 */
dvt.Agent.getVersion = function() {
  dvt.Agent._initialize();
  return dvt.Agent._version;
};


/**
 * Returns true if rendering in Chrome.
 * @return {boolean}
 */
dvt.Agent.isBrowserChrome = function() {
  dvt.Agent._initialize();
  return dvt.Agent._bChrome;
};


/**
 * Returns true if rendering in Safari.
 * @return {boolean}
 */
dvt.Agent.isBrowserSafari = function() {
  return dvt.Agent.isPlatformWebkit() && !dvt.Agent.isBrowserChrome();
};


/**
 * Returns true if rendering in Gecko.
 * @return {boolean}
 */
dvt.Agent.isPlatformGecko = function() {
  return dvt.Agent.getPlatform() == dvt.Agent.GECKO_PLATFORM;
};


/**
 * Returns true if rendering in IE.
 * @return {boolean}
 */
dvt.Agent.isPlatformIE = function() {
  return dvt.Agent.getPlatform() == dvt.Agent.IE_PLATFORM;
};


/**
 * Returns true if rendering in Webkit.
 * @return {boolean}
 */
dvt.Agent.isPlatformWebkit = function() {
  return dvt.Agent.getPlatform() == dvt.Agent.WEBKIT_PLATFORM;
};


/**
 * Returns true if rendering in a right to left locale.
 * @param {dvt.Context=} context If specified, first tries to determine the reading direction from the context.
 * @return {boolean}
 */
dvt.Agent.isRightToLeft = function(context) {
  dvt.Agent._initialize();
  if (context && context.getReadingDirection() != null)
    return context.getReadingDirection() == 'rtl';
  else
    return dvt.Agent._bRtl;
};


/**
 * Returns true if rendering on a touch device.
 * @return {boolean}
 */
dvt.Agent.isTouchDevice = function() {
  dvt.Agent._initialize();
  return dvt.Agent._bTouchDevice;
};


/**
 * Sets the current environment type
 * @param {String} type The environment type.  Currently supports 'batik' and 'test'
 */
dvt.Agent.setEnvironment = function(type) {
  dvt.Agent._environment = type;
};


/**
 * Returns whether the current environment is test
 * @return {boolean}
 */
dvt.Agent.isEnvironmentTest = function() {
  return dvt.Agent._environment == 'test';
};


/**
 * Returns whether the current environment is batik
 * @return {boolean}
 */
dvt.Agent.isEnvironmentBatik = function() {
  return dvt.Agent._environment == 'batik';
};


/**
 * Returns whether the current environment is browser
 * @return {boolean}
 */
dvt.Agent.isEnvironmentBrowser = function() {
  return !dvt.Agent.isEnvironmentTest() && !dvt.Agent.isEnvironmentBatik();
};


/**
 * Sets the whether the current environment is rendering in high contrast mode
 * @param {boolean} bHighContrast Whether to render in high contrast mode
 */
dvt.Agent.setHighContrast = function(bHighContrast) {
  dvt.Agent._highContrast = bHighContrast;
};


/**
 * Returns whether the whether the current environment is rendering in high contrast mode
 * @return {boolean}
 */
dvt.Agent.isHighContrast = function() {
  return dvt.Agent._highContrast === true;
};

/**
 * Works around Firefox bug where displayable isn't rendered correctly for matrix update
 * @param {dvt.Displayable} displayable The displayable to check
 */
dvt.Agent.workaroundFirefoxRepaint = function(displayable) {
  //Fix for 
  if (dvt.Agent.isPlatformGecko()) {
    var parent = displayable.getParent();
    if (parent) {
      var idx = parent.getChildIndex(displayable);
      parent.removeChildAt(idx);
      parent.addChildAt(displayable, idx);
    }
  }
};


/**
 * Initializes the agent.  This caches all the relevant agent parameters and must be called before accessing any of
 * the variables on dvt.Agent.
 * @private
 */
dvt.Agent._initialize = function() {
  // Initialize dvt.Agent if it hasn't been already.
  if (!dvt.Agent._bInitialized) {
    var userAgent = (navigator && navigator.userAgent) ? navigator.userAgent.toLowerCase() : null;

    dvt.Agent._os = dvt.Agent._determineOS(userAgent);
    dvt.Agent._platform = dvt.Agent._determinePlatform(userAgent);
    // Chrome must be initialized before _determineVersion()
    dvt.Agent._bChrome = userAgent && (userAgent.indexOf('chrome/') != -1) && userAgent.indexOf('edge') === -1;
    dvt.Agent._version = dvt.Agent._determineVersion(userAgent, dvt.Agent._platform);

    dvt.Agent._bRtl = (document && document.documentElement) ? document.documentElement.dir == 'rtl' : false;
    dvt.Agent._bTouchDevice = (dvt.Agent._platform == dvt.Agent.WEBKIT_PLATFORM) && userAgent &&
        (userAgent.indexOf('mobile') != -1 || userAgent.indexOf('android') != -1);
    dvt.Agent._devicePixelRatio = (window && window.devicePixelRatio != null) ? window.devicePixelRatio : 1;

    // Don't initialize again
    dvt.Agent._bInitialized = true;
  }
};


/**
 * Determines the operating system. This value should be cached to prevent costly calculations. This value should be
 * treated as a guess, as this code is copied from AdfAgent.guessOS().
 * @param {string} userAgent The lowercase user agent string, if available.
 * @return {string} The dvt.Agent.***_OS constant describing the platform.
 * @private
 */
dvt.Agent._determineOS = function(userAgent)
{
  if (userAgent) {
    if (userAgent.indexOf('win') != -1)
      return dvt.Agent.WINDOWS_OS;
    else if (userAgent.indexOf('mac') != -1)
      return dvt.Agent.MAC_OS;
    else if (userAgent.indexOf('sunos') != -1)
      return dvt.Agent.SOLARIS_OS;
  }

  return dvt.Agent.UNKNOWN_OS;
};


/**
 * Determines the name of the platform. This value should be cached to prevent costly calculations.
 * @param {string} userAgent The lowercase user agent string, if available.
 * @return {string} The dvt.Agent.***_PLATFORM constant describing the platform.
 * @private
 */
dvt.Agent._determinePlatform = function(userAgent)
{
  if (userAgent) {
    if (userAgent.indexOf('opera') != -1) // check opera first, since it mimics other browsers
      return dvt.Agent.UNKNOWN_PLATFORM;
    else if (userAgent.indexOf('trident') != -1 || userAgent.indexOf('msie') != -1 || userAgent.indexOf('edge') != -1)
      return dvt.Agent.IE_PLATFORM;
    else if ((userAgent.indexOf('applewebkit') != -1) || (userAgent.indexOf('safari') != -1))
      return dvt.Agent.WEBKIT_PLATFORM;
    else if (userAgent.indexOf('gecko/') != -1)
      return dvt.Agent.GECKO_PLATFORM;
  }
  return dvt.Agent.UNKNOWN_PLATFORM;
};


/**
 * Determines the version of the platform. This value should be cached to prevent costly calculations.
 * @param {string} userAgent The lowercase user agent string, if available.
 * @param {string} platform The dvt.Agent.***_PLATFORM constant describing the platform.
 * @return {number} The version number.
 * @private
 */
dvt.Agent._determineVersion = function(userAgent, platform)
{
  if (userAgent) {
    if (platform == dvt.Agent.GECKO_PLATFORM)
      return dvt.Agent._parseFloatVersion(userAgent, /rv:(\d+[.]\d+)/);
    else if (platform == dvt.Agent.IE_PLATFORM) {
      var tridentVersion = dvt.Agent._parseFloatVersion(userAgent, /trident\/(\d+[.]\d+)/);
      // Match found, resolve to IE version number, which is trident version + 4
      if (tridentVersion != dvt.Agent.UNKNOWN_VERSION)
        return tridentVersion + 4;
      // Edge
      var edgeVersion = dvt.Agent._parseFloatVersion(userAgent, /edge\/(\d+[.]\d+)/);
      if (edgeVersion != dvt.Agent.UNKNOWN_VERSION)
        return edgeVersion;

      var msieVersion = dvt.Agent._parseFloatVersion(userAgent, /msie (\d+\.\d+);/);
      if (msieVersion != dvt.Agent.UNKNOWN_VERSION)
        return msieVersion;

      return dvt.Agent._parseFloatVersion(userAgent, /msie (\d+\.\d+)b;/);
    }
    else if (platform == dvt.Agent.WEBKIT_PLATFORM) {
      if (dvt.Agent._bChrome) //userAgent has value for webkit version and chrome version, we want the chrome version
        return dvt.Agent._parseFloatVersion(userAgent, /chrome\/(\d+([.]\d+)*)/);
      return dvt.Agent._parseFloatVersion(userAgent, /applewebkit\/(\d+([.]\d+)*)/);
    }
  }

  return dvt.Agent.UNKNOWN_VERSION;
};


/**
 * Parses the version from the specified agent string using the regular expression.
 * @param {string} userAgent The lowercase user agent string.
 * @param {regexp} versionNumberPattern The regular expression used to parse the version number.
 * @return {number}
 * @private
 */
dvt.Agent._parseFloatVersion = function(userAgent, versionNumberPattern)
{
  try {
    var matches = userAgent.match(versionNumberPattern);
    return (matches && matches[1]) ? parseFloat(matches[1]) : dvt.Agent.UNKNOWN_VERSION;
  }
  catch (e) {
    // Technically we should not assume console exists, but it will in all cases where we call this function.
    console.error('dvt.Agent._parseFloatVersion error: ');
    console.error(e);
    return dvt.Agent.UNKNOWN_VERSION;
  }
};


/**
 * Returns the position of an HTML element relative to the document body.
 * @param {object} element The HTML element.
 * @return {dvt.Point}
 * @private
 */
dvt.Agent._getElementPositionDefault = function(element)
{
  // Note: This code was copied from AdfAgent and is not cleaned up for purposes of maintainability and comparison.
  //AdfAssert.assertDomElement(element);
  var boundingRect = element.getBoundingClientRect();
  // top and bottom are not rounded off in Gecko1.9
  // http://www.quirksmode.org/dom/w3c_cssom.html#elementviewm
  var elemTop = Math.round(boundingRect.top);
  var elemLeft = boundingRect.left;
  var docElement = element.ownerDocument.documentElement;
  var body = element.ownerDocument.body;
  // clientLeft and clientTop would be 0 for Gecko1.9
  // https://bugzilla.mozilla.org/show_bug.cgi?id=174397#c34
  // : scrollTop/Left could be defined in either the docElem or the body, so we need to check both
  elemLeft += docElement.scrollLeft || body.scrollLeft;
  elemTop += docElement.scrollTop || body.scrollTop;
  return new dvt.Point(elemLeft, elemTop);
};


/**
 * Returns the position of an HTML element relative to the document body.
 * @param {object} element The HTML element.
 * @return {dvt.Point}
 * @private
 */
dvt.Agent._getElementPositionIE = function(element)
{
  // Note: This code was copied from AdfAgent and is not cleaned up for purposes of maintainability and comparison.
  //AdfAssert.assertDomElement(element);
  var boundingRect = element.getBoundingClientRect();
  var elemTop = boundingRect.top;
  var elemLeft = boundingRect.left;
  var docElement = element.ownerDocument.documentElement;
  var scrollLeft = docElement.scrollLeft;

  // RTL adjustment for IE scrolled view
  //if(AdfPage.PAGE.getLocaleContext().isRightToLeft())
  //  scrollLeft += docElement.clientWidth - docElement.scrollWidth;

  // adjust for the document scroll positions and window borders
  elemLeft -= (docElement.clientLeft - scrollLeft);
  elemTop -= (docElement.clientTop - docElement.scrollTop);
  return new dvt.Point(elemLeft, elemTop);
};

/**
 * Get browser specific focus color.
 * @return {string} A color specification for the focus color
 */
dvt.Agent.getFocusColor = function() {
  dvt.Agent._initialize();
  if (!dvt.Agent._focusColor) {
    var focusColor;
    if (dvt.Agent.isPlatformWebkit() && !dvt.Agent.isEnvironmentTest()) {
      var body = document.getElementsByTagName('body')[0];
      var tempDiv = document.createElement('div');
      body.appendChild(tempDiv);//@HTMLUpdateOK
      tempDiv.style.outline = '-webkit-focus-ring-color';
      focusColor = window.getComputedStyle(tempDiv).getPropertyValue('outline-color');
      body.removeChild(tempDiv);
    }
    else if (dvt.Agent.isPlatformIE())
      focusColor = dvt.Agent.FOCUS_COLOR_IE;
    dvt.Agent._focusColor = focusColor ? focusColor : dvt.Agent.FOCUS_COLOR_DEFAULT;
  }
  return dvt.Agent._focusColor;
};
/**
 * Resource bundle base class.
 * @class
 * @constructor
 */
dvt.Bundle = function() {};
dvt.Bundle['_localizedStrings'] = {};
dvt.Bundle['_defaultStrings'] = {};

dvt.Obj.createSubclass(dvt.Bundle, dvt.Obj);

/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.SUBCOMPONENT_PREFIX = 'DvtSubcomponentBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.AFCOMPONENT_PREFIX = 'DvtAfComponentBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.UTIL_PREFIX = 'DvtUtilBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.CHART_PREFIX = 'DvtChartBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.GAUGE_PREFIX = 'DvtGaugeBundle';

/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.TREEMAP_PREFIX = 'DvtTreemapBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.SUNBURST_PREFIX = 'DvtSunburstBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.NBOX_PREFIX = 'DvtNBoxBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.HIERARCHYVIEWER_PREFIX = 'DvtHierarchyViewerBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.DIAGRAM_PREFIX = 'DvtDiagramBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.TAGCLOUD_PREFIX = 'DvtTagCloudBundle';
/**
 * Prefix
 * @type {string}
*/
dvt.Bundle.TIMELINE_PREFIX = 'DvtTimelineBundle';
/**
 * Adds localized resources into dvt.Bundle. Called by the resource bundle implementations to register localized strings.
 * Example:
 * var DvtChartBundle_CS = {
 *   "DvtChartBundle.LABEL_LEGEND" : "Legend"
 * }
 * dvt.Bundle.addLocalizedStrings(DvtChartBundle_CS);
 * @param {object} jsonObj containing key - value pairs to be added
 */
dvt.Bundle.addLocalizedStrings = function(jsonObj) {
  for (var key in jsonObj) {
    dvt.Bundle['_localizedStrings'][key] = jsonObj[key];
  }
};

/**
 * Adds default resources into dvt.Bundle. Called by the resource bundle implementations to register default strings.
 * @param {string} bundlePrefix The bundle containing the given key
 * @param {object} jsonObj containing key - value pairs to be added
 */
dvt.Bundle.addDefaultStrings = function(bundlePrefix, jsonObj) {
  for (var key in jsonObj) {
    dvt.Bundle['_defaultStrings'][bundlePrefix + '.' + key] = jsonObj[key];
  }
};

/**
 * Substitutes the replacement objects into the specified pattern.
 * @param {string} pattern The pattern string with placeholders.
 * @param {array} replacements The array of replacement strings.
 * @return {string} The resulting string.
 */
dvt.Bundle.format = function(pattern, replacements) {
  return pattern.replace(/\{(\d+)\}/g, function() {return replacements[arguments[1]];});
};

/**
 * Returns a translated string with replacements. If an array of replacement
 * strings is provided, these strings will be substituted into the translated string.
 * @param {string} bundlePrefix The bundle containing the given key
 * @param {string} key The key in the message bundle.
 * @param {array} replacements The array of replacement strings.
 * @return {string} The translated string.
 * @deprecated Use dvt.Bundle.getTranslation instead.
 */
dvt.Bundle.getTranslatedString = function(bundlePrefix, key, replacements) {
  var fullKey = bundlePrefix + '.' + key;
  var ret = dvt.Bundle['_localizedStrings'][fullKey];
  if (!ret)
    ret = dvt.Bundle['_defaultStrings'][fullKey];

  // Substitute the replacements if provided
  if (ret && replacements !== null && replacements !== undefined) {
    if (replacements instanceof Array)
      ret = dvt.Bundle.format(ret, replacements);
    else // Wrap a single object for convenience
      ret = dvt.Bundle.format(ret, [replacements]);
  }

  return ret;
};

/**
 * Returns a translated string with replacements. First searches for the resource in the options object, if one is
 * specified.
 * TODO: The bundlePrefix and key arguments will be removed in 1.1.1 as soon as all components switch over.
 * @param {object} options The options object containing translations.
 * @param {string} optionsKey The key in the options object.
 * @param {string} bundlePrefix The bundle containing the given key
 * @param {string} key The key in the message bundle.
 * @param {array} replacements The array of replacement strings.
 * @return {string} The translated string.
 */
dvt.Bundle.getTranslation = function(options, optionsKey, bundlePrefix, key, replacements) {
  var ret = (options && options['translations']) ? options['translations'][optionsKey] : null;
  if (!ret) {
    var fullKey = bundlePrefix + '.' + key;
    ret = dvt.Bundle['_localizedStrings'][fullKey];
    if (!ret)
      ret = dvt.Bundle['_defaultStrings'][fullKey];
  }

  // Substitute the replacements if provided
  if (ret && replacements !== null && replacements !== undefined) {
    if (replacements instanceof Array)
      ret = dvt.Bundle.format(ret, replacements);
    else // Wrap a single object for convenience
      ret = dvt.Bundle.format(ret, [replacements]);
  }

  return ret;
};
/**
 * Interactivity manager for context menu support.
 * @param {dvt.Context} context The platform specific context object.
 * @param {array} menus The array of menu definitions.
 * @class dvt.ContextMenuHandler
 * @constructor
 */
dvt.ContextMenuHandler = function(context, menus) {
  this._context = context;
  this._menus = menus;
};

dvt.Obj.createSubclass(dvt.ContextMenuHandler, dvt.Obj);

/** @const **/
dvt.ContextMenuHandler.TYPE_BODY_CONTEXT_MENU = 'bodyContextMenu';
/** @const **/
dvt.ContextMenuHandler.TYPE_CONTEXT_MENU = 'contextMenu';
/** @const **/
dvt.ContextMenuHandler.TYPE_MULTI_SELECT_CONTEXT_MENU = 'multiSelectContextMenu';

/** @private @const **/
dvt.ContextMenuHandler._ATTR_MENU_CONTAINER_TYPE = 't';
/** @private @const **/
dvt.ContextMenuHandler._ATTR_MENU_CONTAINER_POPUP_ID = 'id';

/**
 * Displays the context menu with the specified type and id.  Depending on the rendering context,
 * a context menu will either be shown immediately, or a contextMenuEvent will be returned.  If
 * a contextMenuEvent is returned, it should be dispatched through the event callback mechanism.
 * @param {object} event The event that is triggering the context menu.
 * @param {string} menuType The type of context menu being requested, such as bodyContextMenu.
 * @return {object} A context menu event to dispatch or null, depending on the rendering context.
 */
dvt.ContextMenuHandler.prototype.show = function(event, menuType) {
  // Look through all context menu definitions for the right context menu to show
  for (var i = 0; i < this._menus.length; i++) {
    var menu = this._menus[i];
    if (menuType == menu[dvt.ContextMenuHandler._ATTR_MENU_CONTAINER_TYPE]) {
      // Match found.  This implementation will fire a showPopupEvent.
      var popupId = menu[dvt.ContextMenuHandler._ATTR_MENU_CONTAINER_POPUP_ID];
      return dvt.EventFactory.newAdfContextMenuEvent(event.getNativeEvent(), popupId);
    }
  }
  return null;
};
/**
 * Interactivity manager for popup support.
 * @param {dvt.Context} context The platform specific context object.
 * @param {function} callback A function that responds to delayed popup events
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class DvtPopupBehaviorHandler
 * @constructor
 */
var DvtPopupBehaviorHandler = function(context, callback, callbackObj) {
  this._context = context;
  this._callback = callback;
  this._callbackObj = callbackObj;

  // Initialize the hover params
  this._popupPosition = null;   // The most recent position, useful for placing the popup
  this._mouseTarget = null;      // The current hover target
  this._behavior = null;    // The current showPopupBehavior for the hover
  this._hoverPopupShown = false; // true if a hover popup is being shown
  this._hoverTimer = new dvt.Timer(context, 500, this._onHoverDelay, this, 1);
  this._overTimer = new dvt.Timer(context, 500, this._onOverDelay, this, 1);
};

dvt.Obj.createSubclass(DvtPopupBehaviorHandler, dvt.Obj);

// TODO define an interface for the targets of the popup handler functions
// 1. getPopupBounds()
// 2. getId()

/**
 * Processes click and context menu events and fires a adfShowPopup event if a popup should be shown.
 * @param {object} target The target of the mouse event.
 * @param {array} behaviors The array of applicable show popup behaviors.
 * @param {array} triggers The array of trigger types to process
 * @param {dvt.Point} position The position for placing the popup.
 * @param {object} event The mouse event
 * @return {boolean} true if click event processed
 */
DvtPopupBehaviorHandler.prototype.processPopupHelper = function(target, behaviors, triggers, position, event) {
  var consumed = false;
  if (target && behaviors && behaviors.length > 0) {
    for (var i = 0; i < behaviors.length; i++) {
      var behavior = behaviors[i];
      if (behavior && dvt.ArrayUtils.getIndex(triggers, behavior.getTriggerType()) != -1) {
        //: hide an existing popup before showing a new one
        this.HidePopup(event);
        this._behavior = behavior;
        // Create and fire the popup event
        var popupEvent = this._createShowPopupEvent(target, behavior, position);
        dvt.EventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, popupEvent);
        consumed = true;
      }
    }
  }
  return consumed;
};


/**
 * Processes a mouseOver event.
 * @param {object} target The target of the mouse event.
 * @param {array} behaviors The array of applicable show popup behaviors.
 * @param {dvt.Point} position The position for the popup.
 * @param {dvt.Displayable} displayable The dvt.Displayable associated with the logical target of the event.
 * @param {object} event The mouse event
 * @param {string} mouseTriggerType the trigger of the mouse event
 * @return {boolean} true if mouse event processed
 */
DvtPopupBehaviorHandler.prototype.processMousePopup = function(target, behaviors, position, displayable, event, mouseTriggerType) {
  // Same target, no action needed
  if (target === this._mouseTarget)
    return true;

  // Different target, look for applicable showPopupBehavior
  if (target && behaviors && behaviors.length > 0)
  {
    for (var i = 0; i < behaviors.length; i++) {
      var behavior = behaviors[i];
      var behaviorTriggerType = behavior ? behavior.getTriggerType() : null;
      //Mouse over is the mouseTriggerType that activates mouse hover so need to overwrite to
      //over when making the comparison
      if (behaviorTriggerType == dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_HOVER) {
        behaviorTriggerType = dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_OVER;
      }
      if (mouseTriggerType == behaviorTriggerType) {

        //: hide an existing popup before showing a new one
        this.HidePopup(event);

        // Found hover behavior, store the info for use in callback and rollout
        this._mouseTarget = target;
        this._behavior = behavior;
        //: save the displayable so we know when to hide a mousehover popup
        this._hoverDisplayable = displayable;

        this._popupPosition = position;
        // Start the hover timer
        if (mouseTriggerType == dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_HOVER
        || mouseTriggerType == dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_OVER) {
          if (behavior.getTriggerType() == dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_HOVER) {
            this._hoverTimer.start();
          }
          else {
            this._overTimer.start();
          }
        }
        else {
          this._onOverDelay();
        }

        return true;
      }
    }
  }
  return false;
};


/**
 * Processes a mouseOver event and fires a hidePopupEvent if a popup is to be hidden.
 * @param {object} target The target of the mouse event.
 * @param {array} displayableHierarchy The hierarchy of DvtDisplayables associated with the relatedTarget of the
 * @param {object} event The mouse event
 * mouseout event
 */
DvtPopupBehaviorHandler.prototype.processMouseOut = function(target, displayableHierarchy, event) {
  //: if we're mousing out of the whole component, hide the popup
  var bLeavingComponent = false;
  if (displayableHierarchy) {
    bLeavingComponent = (displayableHierarchy.length < 1);
  }
  // Continue only if a hover popup was processed for this target
  if (!this._mouseTarget || !this._behavior || (target !== this._mouseTarget && !bLeavingComponent))
    return;

  //: don't hide the popup if the dvt.Displayable that launched it is still in the
  //hierarchy of DvtDisplayables for the event's relatedTarget, in other words, if we haven't moused out
  //of the launching displayable entirely (for example, when mousing between children of the
  //launching displayable)
  if (displayableHierarchy && this._hoverDisplayable) {
    if (dvt.ArrayUtils.getIndex(displayableHierarchy, this._hoverDisplayable) > -1) {
      return;
    }
  }

  this.HidePopup(event);
};


/**
 * Hides a popup
 * @param {object} event The mouse event
 * @protected
 */
DvtPopupBehaviorHandler.prototype.HidePopup = function(event) {
  if (this._hoverPopupShown) {
    // Popup already shown, hide it
    var popupEvent = dvt.EventFactory.newAdfHidePopupEvent(this._behavior.getPopupId(), event.getNativeEvent().relatedTarget);
    dvt.EventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, popupEvent);
  }
  else {
    // Popup not shown yet, just stop the timer
    this._hoverTimer.stop();
  }

  // Clear out the fields
  this._mouseTarget = null;
  this._behavior = null;
  this._hoverPopupShown = false;
  this._hoverDisplayable = null;
};

/**
 * Processes a mouseMove event.  The most recent position is stored to help position
 * hover popups relative to the mouse.
 * @param {dvt.Point} position The position for the popup.
 */
DvtPopupBehaviorHandler.prototype.processMouseMove = function(position) {
  this._popupPosition = position;
};


/**
 * Helper function used to create the adfShowPopup event.
 * @param {object} target The target of the mouse event.
 * @param {dvt.ShowPopupBehavior} behavior The show popup behavior that is being fired.
 * @param {dvt.Point} position The position for placing the popup.
 * @return {object} The adfShowPopup event, if a popup should be shown.
 * @private
 */
DvtPopupBehaviorHandler.prototype._createShowPopupEvent = function(target, behavior, position) {
  //: only align to the moue when align information is not specified if this._bForceAlignToMouse is true

  // If align and alignId are not defined, position the popup with alignId="endAfter".  The original
  // showPopupBehavior is not modified.
  var spb = behavior;
  var behaviorForBounds = behavior;
  var canAlignToMouse = spb.getAlign() && !spb.getAlignId();
  if (canAlignToMouse) {
    behaviorForBounds = new dvt.ShowPopupBehavior(spb.getPopupId(), spb.getTriggerType(), null, null);
  }

  // Find the bounds that the popup should align to
  var launcherBounds = target.getPopupBounds ? target.getPopupBounds(behaviorForBounds) : null;
  if (canAlignToMouse && !launcherBounds) {
    // If the object doesn't specify a bounds, then align to the mouse
    var pos = this._context.pageToStageCoords(position.x, position.y);
    launcherBounds = new dvt.Rectangle(pos.x, pos.y - 5, 1, 5);
  }
  else if (launcherBounds) {
    //: if we have launcher bounds, then create a new behavior object and set the alignId
    //to null so that the JS peer will recognize that the popup should be aligned to a component
    //rendered by the toolkit and position the helper div accordingly
    spb = new dvt.ShowPopupBehavior(spb.getPopupId(), spb.getTriggerType(), null, spb.getAlign());
  }

  var event = dvt.EventFactory.newAdfShowPopupEvent(spb, launcherBounds, null, spb.getTriggerType());
  // add the component specific context
  dvt.EventManager._addContextInfo(target, event);

  return event;
};


/**
 * Callback function that is called by the timer when a hover popup should be shown.
 * @private
 */
DvtPopupBehaviorHandler.prototype._onHoverDelay = function() {
  if (!this._mouseTarget || !this._behavior)
    return;
  // Show the popup: Create the event and pass to the hover callback
  this._hoverPopupShown = true;
  var event = this._createShowPopupEvent(this._mouseTarget, this._behavior, this._popupPosition);
  dvt.EventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
};

/**
 * Callback function that is called by the timer when a mouse over popup should be shown.
 * @private
 */
DvtPopupBehaviorHandler.prototype._onOverDelay = function() {
  if (!this._mouseTarget || !this._behavior)
    return;
  // Show the popup: Create the event and pass to the hover callback
  var event = this._createShowPopupEvent(this._mouseTarget, this._behavior, this._popupPosition);
  dvt.EventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
};

/**
 * Helper function used to tell if obj has certain popup trigger
 * @param {object} obj The object being checked of triggers
 * @param {array} triggers The array of trigger types being checked
 * @return {boolean} true if obj has trigger popuptype
 */
DvtPopupBehaviorHandler.prototype.hasPopup = function(obj, triggers) {
  if (!obj || !obj.getShowPopupBehaviors) {
    return false;
  }
  var behaviors = obj.getShowPopupBehaviors();
  if (behaviors) {
    for (var i = 0; i < behaviors.length; i++) {
      var behavior = behaviors[i];
      if (behavior && dvt.ArrayUtils.getIndex(triggers, behavior.getTriggerType()) != -1) {
        return true;
      }
    }
  }
  return false;
};
/**
 * Interactivity manager for dvt component client behaviors
 * @param {dvt.Context} context The platform specific context object.
 * @param {function} callback A function that responds to client behavior events
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class dvt.ClientBehaviorHandler
 * @constructor
 */
dvt.ClientBehaviorHandler = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
};

// TODO NAMESPACE: DIAGRAM ONLY

dvt.Obj.createSubclass(dvt.ClientBehaviorHandler, dvt.Obj);

dvt.ClientBehaviorHandler.prototype.Init = function(context, callback, callbackObj) {
  this._context = context;
  this._callback = callback;
  this._callbackObj = callbackObj;
};


/**
 * Processes a click event and fires a dvt.ClientBehaviorEvent if a client behavior was triggered.
 * @param {object} target The target of the mouse event.
 * @param {array} behaviors The array of applicable client behaviors.
 * @return {boolean} true if a client behavior was triggered, false otherwise
 */
dvt.ClientBehaviorHandler.prototype.processClick = function(target, behaviors) {
  var consumed = false;
  if (target && behaviors && behaviors.length > 0)
  {
    for (var i = 0; i < behaviors.length; i++) {
      var behavior = behaviors[i];
      if (behavior && (behavior.getTriggerType() == dvt.ClientBehavior.TRIGGER_TYPE_ACTION ||
          behavior.getTriggerType() == dvt.ClientBehavior.TRIGGER_TYPE_CLICK)) {
        // Create and fire the popup event
        var behaviorEvent = this.CreateClientBehaviorEvent(target, behavior);
        dvt.EventDispatcher.dispatchEvent(this._callback, this._callbackObj, null, behaviorEvent);
        consumed = true;
      }
    }
  }

  return consumed;
};

dvt.ClientBehaviorHandler.prototype.CreateClientBehaviorEvent = function(target, behavior) {
  var behaviorEvent = new dvt.ClientBehaviorEvent(behavior);
  dvt.EventManager._addContextInfo(target, behaviorEvent);
  return behaviorEvent;
};
/**
  * Interactivity manager for selection.
  * @class dvt.SelectionHandler
  * @constructor
  */
dvt.SelectionHandler = function(type) {
  this.Init(type);
};

dvt.Obj.createSubclass(dvt.SelectionHandler, dvt.Obj);

dvt.SelectionHandler.TYPE_SINGLE = 's';
dvt.SelectionHandler.TYPE_MULTIPLE = 'm';

dvt.SelectionHandler.prototype.Init = function(type) {
  this._selection = [];
  this._type = type ? type : dvt.SelectionHandler.TYPE_SINGLE;

  // Some selected id may not correspond to a drawn target because it's outside the viewport.
  this._hiddenSelectedIds = [];
};

dvt.SelectionHandler.prototype.getType = function() {
  return this._type;
};


/**
 * Returns the number of currently selected objects.
 * @return {number}
 */
dvt.SelectionHandler.prototype.getSelectedCount = function() {
  return this._selection.length;
};


/**
 * Returns the current selection.
 * @return {array} The current selection.
 */
dvt.SelectionHandler.prototype.getSelection = function() {
  return this._selection.slice(0);
};


/**
 * Returns the ids for the currently selected objects. Includes the ids of the hidden selected objects.
 * @return {array} The ids for the currently selected objects.
 */
dvt.SelectionHandler.prototype.getSelectedIds = function() {
  var selectedIds = [];
  for (var i = 0; i < this._selection.length; i++) {
    selectedIds.push(this._selection[i].getId());
  }
  return selectedIds.concat(this._hiddenSelectedIds);
};


/**
 * Processes the initially selected objects, updating the state of this handler.
 * @param {array} selectedIds The array of ids for the selected objects.
 * @param {array} targets The array of selectable objects.
 */
dvt.SelectionHandler.prototype.processInitialSelections = function(selectedIds, targets) {
  // Clear current selection state
  this.clearSelection(true);

  // If nothing selected, we are done
  if (!selectedIds || !targets)
    return;

  // Loop through all the selected ids, matching them to the targets
  for (var i = 0; i < selectedIds.length; i++) {
    var hidden = true;
    for (var j = 0; j < targets.length; j++) {
      var targetId = targets[j].getId();
      if (targetId != null && dvt.SelectionHandler._isEquals(selectedIds[i], targetId) && targets[j].isSelectable && targets[j].isSelectable()) {
        // Found a match, continue to next selected id
        this._addToSelection(targets[j], true, true);
        hidden = false;
        break;
      }
    }
    if (hidden)
      this._hiddenSelectedIds.push(selectedIds[i]);
  }
};


/**
 * Processes a click event.
 * @param {DvtSelectable} target
 * @param {boolean} addToExisting true if a key indicating multi-select should be performed was pressed during the click.
 * @return {boolean} true if the selection has changed.
 */
dvt.SelectionHandler.prototype.processClick = function(target, addToExisting) {
  //: if this click is unrelated to selection, then
  //don't change selection at all
  if (target && target.isUnrelatedToSelection && target.isUnrelatedToSelection()) {
    return false;
  }

  // Check whether we are in multi-select mode
  var bMulti = (addToExisting && this._type == dvt.SelectionHandler.TYPE_MULTIPLE);

  //*************************************************
  // Possible cases:
  // 1. Multi-select of selectable target
  // 2. Multi-select of non-selectable target (noop)
  // 3. Single select of selectable target
  // 4. Single select of non-selectable target
  //*************************************************

  var bChanged = false; // Keep track of whether the selection is changed
  if (bMulti)
  {
    if (target && target.isSelectable && target.isSelectable()) {
      // 1. Multi-select of selectable target
      if (target.isSelected()) {
        bChanged = this.removeFromSelection(target);
      }
      else {
        bChanged = this._addToSelection(target, true);
      }
    }
    // Otherwise 2. Multi-select of non-selectable target (noop)
  }
  else // Single Select
  {
    if (target && target.isSelectable && target.isSelectable()) {
      // 3. Single select of selectable target
      bChanged = this._addToSelection(target, false);
    }
    else {
      // 4. Single select of non-selectable target
      bChanged = this.clearSelection();
    }
  }

  // Return whether the selection has changed.
  return bChanged;
};


/**
 * Processes selection event involving a group of target items.
 * @param {array} targets Array of DvtSelectable objects
 * @param {boolean} addToExisting true if a key indicating multi-select should be performed was pressed during the click.
 */
dvt.SelectionHandler.prototype.processGroupSelection = function(targets, addToExisting) {
  if (!addToExisting)
    this.clearSelection();

  var target;
  for (var i = 0; i < targets.length; i++) {
    target = targets[i];

    //: if this click is unrelated to selection, then
    //don't change selection at all
    if (target && target.isUnrelatedToSelection && target.isUnrelatedToSelection()) {
      continue;
    }

    this._addToSelection(target, true);
  }
};


/**
 * Processes a mouseOver event.
 * @param {DvtSelectable} target
 */
dvt.SelectionHandler.prototype.processMouseOver = function(target) {
  if (target && target.isSelectable && target.isSelectable() && target.showHoverEffect) {
    target.showHoverEffect();
  }
};


/**
 * Processes a mouseOut event.
 * @param {DvtSelectable} target
 */
dvt.SelectionHandler.prototype.processMouseOut = function(target) {
  if (target && target.isSelectable && target.isSelectable() && target.hideHoverEffect) {
    target.hideHoverEffect();
  }
};


/**
 * Selects a single object.
 * @param {DvtSelectable} target the object to select
 * @param {boolean} bAddToExisting true if the object should be added to the current selection.
 * @param {boolean} isInitial (optional) True if it is an initial selection.
 * @return {boolean} true if the selection has changed.
 */
dvt.SelectionHandler.prototype._addToSelection = function(target, bAddToExisting, isInitial) {
  // If already selected, return.  This intentionally ignores bAddToExisting.
  if (target.isSelected() || (target.isSelectable && !target.isSelectable())) {
    return false;
  }

  // If not adding to the current selection, deselect all
  if (!bAddToExisting) {
    this.clearSelection(isInitial);
  }

  // Finally, select the object
  target.setSelected(true, isInitial);
  this._selection.push(target);
  return true;
};


/**
 * Deselects a single object in the selection.
 * @param {DvtSelectable} target the object to deselect
 * @return {boolean} true if the selection has changed.
 */
dvt.SelectionHandler.prototype.removeFromSelection = function(target) {
  if (!target.isSelected())
    return false;

  // First deselect the object, then remove it from the selected array
  target.setSelected(false);
  for (var i = 0; i < this._selection.length; i++) {
    if (this._selection[i] == target) {
      this._selection.splice(i, 1);
      break;
    }
  }
  return true;
};


/**
 * Clears the current selection.
 * @param {boolean} isInitial (optional) True if it is an initial selection.
 * @return {boolean} true if the selection has changed.
 */
dvt.SelectionHandler.prototype.clearSelection = function(isInitial) {
  if (this._selection.length <= 0 && this._hiddenSelectedIds.length <= 0)
    return false;

  while (this._selection.length > 0) {
    var obj = this._selection.pop();
    obj.setSelected(false, isInitial);
  }
  this._hiddenSelectedIds.length = 0;
  return true;
};


/**
 * Utility function used to determine if two id objects are equal.
 * @param {object} a
 * @param {object} b
 * @private
 * @return {boolean}
 */
dvt.SelectionHandler._isEquals = function(a, b) {
  if (a == b)
    return true;
  else if (a instanceof String)       // Flash doesn't have a String.equals()
    return false;
  else if (a && a.equals)
    return a.equals(b);
  else
    return false;
};
/**
  * Interactivity manager for keyboard events.
  * @param {dvt.EventManager} manager The owning dvt.EventManager
  * @class dvt.KeyboardHandler
  * @constructor
  */
dvt.KeyboardHandler = function(manager) 
{
  this.Init(manager);
};

dvt.Obj.createSubclass(dvt.KeyboardHandler, dvt.Obj);

// Constants used for calculating penalties when calculating distances between two DvtKeyboardNavigables
// in dvt.KeyboardHandler._calcDistanceAngleWeighted
/** @private */
dvt.KeyboardHandler._OPTIMAL_ANGLE1 = 15 / 180 * Math.PI;
/** @private */
dvt.KeyboardHandler._OPTIMAL_ANGLE2 = 40 / 180 * Math.PI;
/** @private */
dvt.KeyboardHandler._SUBOPTIMAL_ANGLE_PENALTY1 = 2; // multiplier to the distance
/** @private */
dvt.KeyboardHandler._SUBOPTIMAL_ANGLE_PENALTY2 = 6; // multiplier to the distance

/**
 * @param {dvt.EventManager} manager The owning dvt.EventManager
 */
dvt.KeyboardHandler.prototype.Init = function(manager)
{
  this._eventManager = manager;
};

/**
 * Processes key down events.
 * @param {dvt.KeyboardEvent} event
 * @return {DvtKeyboardNavigable} The object that has keyboard focus as a result of the keyboard event. Null if the event
 *                                does not affect which DvtKeyboardNavigable has focus.
 */
dvt.KeyboardHandler.prototype.processKeyDown = function(event) 
{
  var currentNavigable = this._eventManager.getFocus();
  if (currentNavigable && (this.isNavigationEvent(event) || this.isMultiSelectEvent(event)))
  {
    dvt.EventManager.consumeEvent(event);
    var nextNavigable = currentNavigable.getNextNavigable(event);
    if (nextNavigable != currentNavigable) {
      if (nextNavigable)
        this._showPopupHelper(nextNavigable, [dvt.ShowPopupBehavior.TRIGGER_TYPE_FOCUS], event);
      this._showPopupHelper(currentNavigable, [dvt.ShowPopupBehavior.TRIGGER_TYPE_BLUR], event);
    }
    return nextNavigable;
  }
  else if (event.keyCode != dvt.KeyboardEvent.TAB && currentNavigable) {
    this._showPopupHelper(currentNavigable, [dvt.ShowPopupBehavior.TRIGGER_TYPE_KEY_DOWN], event);
  }

  return null;
};

/**
 * Processes key Up and key press events.
 * @param {dvt.KeyboardEvent} event
 * @param {String} triggerType
 */
dvt.KeyboardHandler.prototype.processKeyUp = function(event, triggerType) 
{
  var currentNavigable = this._eventManager.getFocus();

  if (currentNavigable && event.keyCode == dvt.KeyboardEvent.TAB) {//it was a tab
    this._showPopupHelper(currentNavigable, [dvt.ShowPopupBehavior.TRIGGER_TYPE_FOCUS], event);
  }
  else if (currentNavigable && !(this.isNavigationEvent(event) || this.isMultiSelectEvent(event)))
  {
    this._showPopupHelper(currentNavigable, triggerType, event);
  }

};


/**
 * Simple implementation to return a navigable item based on direction and bounding box of current focused item
 * @param {DvtKeyboardNavigable} currentNavigable The DvtKeyboardNavigable item with current focus
 * @param {dvt.KeyboardEvent} event
 * @param {Array} navigableItems An array of items that could receive focus next
 * @param {Boolean} ignoreBounds (optional) Ignore the _isInBounds check when finding the next navigable
 * @return {DvtKeyboardNavigable} The next navigable
 */
dvt.KeyboardHandler.getNextNavigable = function(currentNavigable, event, navigableItems, ignoreBounds) 
{
  var nextNavigable = null;
  var nextNavigableDelta = 0;
  var delta = 0;

  var direction = event.keyCode;

  if (!currentNavigable)
  {
    if (!navigableItems || navigableItems.length < 1)
      return null;
    else
      return navigableItems[0];
  }

  // get the bounds of the current navigable
  var currentBounds = currentNavigable.getKeyboardBoundingBox();
  var candidateBounds;

  for (var i = 0; i < navigableItems.length; i++)
  {
    var navigable = navigableItems[i];

    if (currentNavigable === navigable)
      continue;

    candidateBounds = navigable.getKeyboardBoundingBox();

    if (ignoreBounds || dvt.KeyboardHandler._isInBounds(currentBounds, candidateBounds, direction))
    {
      delta = dvt.KeyboardHandler._computeDelta(currentBounds, candidateBounds, direction);

      if ((((direction == dvt.KeyboardEvent.UP_ARROW) || (direction == dvt.KeyboardEvent.LEFT_ARROW)) && (delta < 0) && (!nextNavigable || (delta > nextNavigableDelta))) ||
          (((direction == dvt.KeyboardEvent.DOWN_ARROW) || (direction == dvt.KeyboardEvent.RIGHT_ARROW)) && (delta > 0) && (!nextNavigable || (delta < nextNavigableDelta)))
      )
      {
        nextNavigable = navigable;
        nextNavigableDelta = delta;
      }
    }
  }
  return nextNavigable ? nextNavigable : currentNavigable;
};

/**
 * Helper function for showing popups
 * @param {DvtKeyboardNavigable} navigable The DvtKeyboardNavigable item to show the popup
 * @param {Array} triggerType An array containing the trigger type
 * @param {object} event The svg event
 * @return {boolean} true if popup is showing
 * @private
 */
dvt.KeyboardHandler.prototype._showPopupHelper = function(navigable, triggerType, event) {
  var context = this._eventManager.getCtx();
  var coords = navigable.getKeyboardBoundingBox(context.getStage()).getCenter();
  var pageCoords = context.stageToPageCoords(coords.x, coords.y);
  var behaviors = navigable.getShowPopupBehaviors ? navigable.getShowPopupBehaviors() : null;
  return this._eventManager.getPopupHandler().processPopupHelper(navigable, behaviors, triggerType, pageCoords, event);
};
/**
 * Returns a default keyboard navigable by selecting the upper left or lower right-most item in the navigableItems
 * array.  Utility method that can be called by classes that implement DvtKeyboardNavigable
 * @param {Array} navigableItems An array of DvtKeyboardNavigables from which to choose the default one to receive focus
 * @return {DvtKeyboardNavigable}
 */
dvt.KeyboardHandler.prototype.getDefaultNavigable = function(navigableItems)
{
  if (!navigableItems || navigableItems.length <= 0)
    return null;

  var defaultNavigable = navigableItems[0];
  var defaultLocation = defaultNavigable.getKeyboardBoundingBox();
  var navigable;
  var navigableLocation;

  for (var i = 1; i < navigableItems.length; i++)
  {
    navigable = navigableItems[i];
    navigableLocation = navigable.getKeyboardBoundingBox();
    // return the top left-most item in non-bidi and top right-most item in bidi
    if ((((navigableLocation.x == defaultLocation.x && navigableLocation.y < defaultLocation.y) ||
        navigableLocation.x < defaultLocation.x) && !dvt.Agent.isRightToLeft(this._eventManager.getCtx())) ||
        (((navigableLocation.x + navigableLocation.w == defaultLocation.x + defaultLocation.w && navigableLocation.y < defaultLocation.y) ||
        navigableLocation.x + navigableLocation.w > defaultLocation.x + defaultLocation.w) && dvt.Agent.isRightToLeft(this._eventManager.getCtx())))
    {
      defaultNavigable = navigable;
      defaultLocation = defaultNavigable.getKeyboardBoundingBox();
    }
  }

  return defaultNavigable;
};


/**
 * Returns true if the event requires us to update the DvtKeyboardNavigable with keyboard focus.  In the base
 * implementation, we return true if the given event is an arrow keystroke.
 * @param {DvtKeybaordEvent} event
 * @return {Boolean}
 */
dvt.KeyboardHandler.prototype.isNavigationEvent = function(event)
{
  var keyCode = event.keyCode;

  switch (keyCode)
  {
    case dvt.KeyboardEvent.UP_ARROW:
    case dvt.KeyboardEvent.DOWN_ARROW:
    case dvt.KeyboardEvent.LEFT_ARROW:
    case dvt.KeyboardEvent.RIGHT_ARROW:
      return true;
    default:
      break;
  }
  return false;
};


/**
 * Returns true if the event requires us to perform a single select
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean}
 */
dvt.KeyboardHandler.prototype.isSelectionEvent = function(event)
{
  return false; // subclasses should override
};


/**
 * Returns true if the event requires us to perform a multi select
 * @param {DvtKeybaordEvent} event
 * @return {Boolean}
 */
dvt.KeyboardHandler.prototype.isMultiSelectEvent = function(event)
{
  return false; // subclasses should override
};


/**
 * Returns true if the keyboard event is the standard keystroke for opening context menus
 * (Ctrl + Alt + M)
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} true if the event is Ctrl+Alt+M, false otherwise
 */
dvt.KeyboardHandler.prototype.isContextMenuEvent = function(event)
{
  return event.keyCode == dvt.KeyboardEvent.M &&
      event.altKey && event.ctrlKey;
};


/**
 * Determines if the candidate bounds line up with the current bounds in the given direction
 * For example, if the direction is up, then the candidate's x-bounds should overlap with the
 * current's x-bounds
 *
 * @param {dvt.Rectangle} currentBounds
 * @param {dvt.Rectangle} candidateBounds
 * @param {Number} direction  One of dvt.KeyboardEvent.UP_ARROW, dvt.KeyboardEvent.DOWN_ARROW,
 *                            dvt.KeyboardEvent.LEFT_ARROW, or dvt.KeyboardEvent.RIGHT_ARROW
 * @return {Boolean} True if the candidate bounds line up with the current bounds, in the given direction
 * @private
 */
dvt.KeyboardHandler._isInBounds = function(currentBounds, candidateBounds, direction) 
{
  if (direction == dvt.KeyboardEvent.UP_ARROW || direction == dvt.KeyboardEvent.DOWN_ARROW)
  {
    // if up/down, check that the current x-bounds overlap with the candidate's x-bounds.
    // by making sure that the left edge of the current is not to the right of the candidate
    // and that the right edge of the current is not to the left of the candidate

    var currentX1 = currentBounds.x;
    var currentX2 = currentX1 + currentBounds.w;
    var candidateX1 = candidateBounds.x;
    var candidateX2 = candidateX1 + candidateBounds.w;

    return !((currentX1 >= candidateX2) || (currentX2 <= candidateX1));
  }
  else if (direction == dvt.KeyboardEvent.LEFT_ARROW || direction == dvt.KeyboardEvent.RIGHT_ARROW)
  {
    // if left/right, check that the current y-bounds overlap with the candidate's y-bounds.
    // by making sure that the top edge of the current is not below the candidate
    // and that the bottom edge of the current is not above the candidate

    var currentY1 = currentBounds.y;
    var currentY2 = currentY1 + currentBounds.h;
    var candidateY1 = candidateBounds.y;
    var candidateY2 = candidateY1 + candidateBounds.h;

    return !((currentY1 >= candidateY2) || (currentY2 <= candidateY1));
  }
};


/**
 * Determines the diffeerence between the centers of the currentBounds and the candidatBounds,
 * in the given direction.  The difference is negative if the candidate is above or to the left
 * of the current, positive if the candidate is below or to the right
 *
 * @param {dvt.Rectangle} currentBounds
 * @param {dvt.Rectangle} candidateBounds
 * @param {Number} direction  One of dvt.KeyboardEvent.UP_ARROW, dvt.KeyboardEvent.DOWN_ARROW,
 *                            dvt.KeyboardEvent.LEFT_ARROW, or dvt.KeyboardEvent.RIGHT_ARROW
 * @return {Number} The difference between the centers of the currentBounds and candidateBounds, in
 *                  the given direction
 * @private
 */

dvt.KeyboardHandler._computeDelta = function(currentBounds, candidateBounds, direction)
{
  var delta = 0;
  var currentX = currentBounds.getCenter().x;
  var currentY = currentBounds.getCenter().y;
  var candidateX = candidateBounds.getCenter().x;
  var candidateY = candidateBounds.getCenter().y;

  if ((direction == dvt.KeyboardEvent.UP_ARROW) || (direction == dvt.KeyboardEvent.DOWN_ARROW))
    delta = candidateY - currentY;
  else if ((direction == dvt.KeyboardEvent.LEFT_ARROW) || (direction == dvt.KeyboardEvent.RIGHT_ARROW))
    delta = candidateX - currentX;

  return delta;
};


/**
 * Returns the next navigable based on the arrow key that was pressed. This method will return the next navigable that
 * is adjacent to the current navigable, in the direction of the arrow key. If there are no adjacent navigables, the
 * closest navigable in the direction of the arrow key is returned.  Distance to the nearest navigable is based on
 * straight line distance between the midpoints of the navigables' keyboard bounding box, multiplied by a penalty
 * factor if the midpoints are too far off the vertical (in the case of up and down) or horizontal (for left and right)
 *
 * @param {DvtKeyboardNavigable} current
 * @param {dvt.KeyboardEvent} event
 * @param {Array} listOfObjects Array of DvtKeyboardNavigable objects
 * @return {DvtKeyboardNavigable}
 */
dvt.KeyboardHandler.getNextAdjacentNavigable = function(current, event, listOfObjects)
{
  var keycode = event.keyCode;

  if (!listOfObjects)
    return null;

  if (!current)
    return listOfObjects[0];

  var nextObject = current; //init to current object
  var nextDistance = Number.MAX_VALUE;

  // If an object is in contact it overrules all other attributes
  // Only another in contact object with better attributes will have higher precedence
  var nextInContact = false;

  for (var i = 0; i < listOfObjects.length; i++)
  {
    var object = listOfObjects[i];

    if (object === current)
      continue;

    if (!dvt.KeyboardHandler._isValidDestination(object, current, keycode))
      continue;

    var inContact = dvt.KeyboardHandler._calcInContact(object, current, keycode);

    if (nextInContact && !inContact)
      continue;

    var distance = dvt.KeyboardHandler._calcDistanceAngleWeighted(object, current, keycode);
    // Make sure incontact flag have highest precedence
    if ((!nextInContact && inContact) ||
        (distance < nextDistance && ((nextInContact && inContact) || !nextInContact)))
    {
      nextDistance = distance;
      nextObject = object;
      nextInContact = inContact;
    }
  }
  return nextObject;
};


/**
 * Determine if two objects are in contact in the specified direction
 *
 * @param {DvtKeyboardNavigable} object
 * @param {DvtKeyboardNavigable} current
 * @param {Number} keycode
 * @return {Boolean}
 * @private
 */
dvt.KeyboardHandler._calcInContact = function(object, current, keycode)
{
  var objRect = object.getKeyboardBoundingBox();
  var curRect = current.getKeyboardBoundingBox();

  switch (keycode)
  {
    case dvt.KeyboardEvent.UP_ARROW:
      return dvt.KeyboardHandler._isVerticallyAligned(objRect, curRect) &&
          (curRect.y <= (objRect.y + objRect.h) || dvt.KeyboardHandler._areEqualWithinTolerance(curRect.y, objRect.y + objRect.h));
    case dvt.KeyboardEvent.DOWN_ARROW:
      return dvt.KeyboardHandler._isVerticallyAligned(objRect, curRect) &&
          (objRect.y <= (curRect.y + curRect.h) || dvt.KeyboardHandler._areEqualWithinTolerance(objRect.y, curRect.y + curRect.h));
    case dvt.KeyboardEvent.RIGHT_ARROW:
      return dvt.KeyboardHandler._isHorizontallyAligned(objRect, curRect) &&
          (objRect.x <= (curRect.x + curRect.w) || dvt.KeyboardHandler._areEqualWithinTolerance(objRect.x, curRect.x + curRect.w));
    case dvt.KeyboardEvent.LEFT_ARROW:
      return dvt.KeyboardHandler._isHorizontallyAligned(objRect, curRect) &&
          (curRect.x <= (objRect.x + objRect.w) || dvt.KeyboardHandler._areEqualWithinTolerance(curRect.x, objRect.x + objRect.w));
    default:
      break;
  }

  return false;
};


/**
 * Returns true if the two input rectangles are lined up vertically
 *
 * @param {dvt.Rectangle} rect1
 * @param {dvt.Rectangle} rect2
 * @return {Boolean}
 * @private
 */
dvt.KeyboardHandler._isVerticallyAligned = function(rect1, rect2)
{
  return ((rect1.x >= rect2.x && rect1.x <= (rect2.x + rect2.w)) ||
          (rect2.x >= rect1.x && rect2.x <= (rect1.x + rect1.w)));
};


/**
 * Returns true if the two input rectangles are lined up horizontally
 *
 * @param {dvt.Rectangle} rect1
 * @param {dvt.Rectangle} rect2
 * @return {Boolean}
 * @private
 */
dvt.KeyboardHandler._isHorizontallyAligned = function(rect1, rect2)
{
  return ((rect1.y >= rect2.y && rect1.y <= (rect2.y + rect2.h)) ||
          (rect2.y >= rect1.y && rect2.y <= (rect1.y + rect1.h)));
};


/**
 * Returns the distance between the centers of the keyboard bounding boxes of the input DvtKeyboardNavigables.
 * Distance is multiplied by a penalty factor if the centers are too far off the vertical (in the case of up and down)
 * or horizontal (for left and right)
 *
 * @param {DvtKeyboardNavigable} object
 * @param {DvtKeyboardNavigable} current
 * @param {Number} keycode
 * @return {Number}
 * @private
 */
dvt.KeyboardHandler._calcDistanceAngleWeighted = function(object, current, keycode)
{
  var objectBB = object.getKeyboardBoundingBox();
  var objCenterX = objectBB.x + objectBB.w / 2;
  var objCenterY = objectBB.y + objectBB.h / 2;

  var currentBB = current.getKeyboardBoundingBox();
  var curCenterX = currentBB.x + currentBB.w / 2;
  var curCenterY = currentBB.y + currentBB.h / 2;

  var x_dist = Math.abs(objCenterX - curCenterX);
  var y_dist = Math.abs(objCenterY - curCenterY);

  var angle = Math.atan2(y_dist, x_dist);

  var distance = Math.sqrt(x_dist * x_dist + y_dist * y_dist);

  // Angle penalty based on direction
  if ((angle > dvt.KeyboardHandler._OPTIMAL_ANGLE1 && (keycode == dvt.KeyboardEvent.RIGHT_ARROW || keycode == dvt.KeyboardEvent.LEFT_ARROW)) ||
      (angle < dvt.Math.HALF_PI - dvt.KeyboardHandler._OPTIMAL_ANGLE1 && (keycode == dvt.KeyboardEvent.UP_ARROW || keycode == dvt.KeyboardEvent.DOWN_ARROW)))
  {
    if ((angle > dvt.KeyboardHandler._OPTIMAL_ANGLE2 && (keycode == dvt.KeyboardEvent.RIGHT_ARROW || keycode == dvt.KeyboardEvent.LEFT_ARROW)) ||
        (angle < dvt.Math.HALF_PI - dvt.KeyboardHandler._OPTIMAL_ANGLE2 && (keycode == dvt.KeyboardEvent.UP_ARROW || keycode == dvt.KeyboardEvent.DOWN_ARROW)))
    {
      distance *= dvt.KeyboardHandler._SUBOPTIMAL_ANGLE_PENALTY2;
    }
    else
    {
      distance *= dvt.KeyboardHandler._SUBOPTIMAL_ANGLE_PENALTY1;
    }
  }

  return distance;
};


/**
  * Determine if a point is valid based on the direction
  * @param {DvtKeyboardNavigable} object
  * @param {DvtKeyboardNavigable} current
  * @param {Number} keycode
  * @return {Boolean}
  * @private
  */
dvt.KeyboardHandler._isValidDestination = function(object, current, keycode)
{
  var objBB = object.getKeyboardBoundingBox();
  var curBB = current.getKeyboardBoundingBox();

  switch (keycode)
  {
    case dvt.KeyboardEvent.UP_ARROW:
      return (objBB.y < curBB.y) || dvt.KeyboardHandler._areEqualWithinTolerance(objBB.y, curBB.y);
    case dvt.KeyboardEvent.DOWN_ARROW:
      return objBB.y > curBB.y || dvt.KeyboardHandler._areEqualWithinTolerance(objBB.y, curBB.y);
    case dvt.KeyboardEvent.RIGHT_ARROW:
      return objBB.x > curBB.x || dvt.KeyboardHandler._areEqualWithinTolerance(objBB.x, curBB.x);
    case dvt.KeyboardEvent.LEFT_ARROW:
      return objBB.x < curBB.x || dvt.KeyboardHandler._areEqualWithinTolerance(objBB.x, curBB.x);
    default:
      break;
  }
  return true;
};


/**
 * Utility method to check if two numbers are equal, within a small tolerance. Used to account for small rounding
 * errors
 *
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean} true if the numbers are within 0.0000001 of each other
 * @private
 */
dvt.KeyboardHandler._areEqualWithinTolerance = function(a, b)
{
  return Math.abs(a - b) <= 0.0000001;
};

/**
 * Handler used for marquee operations.
 * @class
 * @constructor
 * @param {dvt.Container} container Marquee container.
 * @param {dvt.Rectangle} marqueeBounds The area in which the marquee can be initiated and drawn.
 * @param {dvt.Rectangle} glassPaneBounds The area that will be covered by the glass pane when the marquee is active.
 * @param {dvt.Fill} fill The marquee rect fill
 * @param {dvt.Stroke} stroke The marquee rect stroke
 * @param {boolean=} allowHorizResize Whether horizontal resize is allowed. Defaults to true.
 * @param {boolean=} allowVertResize Whether vertical resize is allowed. Defaults to true.
 * @param {dvt.Rectangle=} horizResizeBounds The bounds for initiating a marquee that only resizes horizontally.
 * @param {dvt.Rectangle=} vertResizeBounds The bounds for initiating a marquee that only resizes vertically.
 */
dvt.MarqueeHandler = function(container, marqueeBounds, glassPaneBounds, fill, stroke, 
    allowHorizResize, allowVertResize, horizResizeBounds, vertResizeBounds) {
  this.Init(container, marqueeBounds, glassPaneBounds, fill, stroke, allowHorizResize, allowVertResize,
      horizResizeBounds, vertResizeBounds);
};


dvt.Obj.createSubclass(dvt.MarqueeHandler, dvt.Obj);


/**
 * @param {dvt.Container} container Marquee container.
 * @param {dvt.Rectangle} marqueeBounds The area in which the marquee can be initiated and drawn.
 * @param {dvt.Rectangle} glassPaneBounds The area that will be covered by the glass pane when the marquee is active.
 * @param {dvt.Fill} fill The marquee rect fill
 * @param {dvt.Stroke} stroke The marquee rect stroke
 * @param {boolean=} allowHorizResize Whether horizontal resize is allowed. Defaults to true.
 * @param {boolean=} allowVertResize Whether vertical resize is allowed. Defaults to true.
 * @param {dvt.Rectangle=} horizResizeBounds The bounds for initiating a marquee that only resizes horizontally.
 * @param {dvt.Rectangle=} vertResizeBounds The bounds for initiating a marquee that only resizes vertically.
 */
dvt.MarqueeHandler.prototype.Init = function(container, marqueeBounds, glassPaneBounds, fill, stroke, 
    allowHorizResize, allowVertResize, horizResizeBounds, vertResizeBounds) {
  this._context = container.getCtx();
  this._container = container;
  this._bounds = marqueeBounds;
  this._fill = fill;
  this._stroke = stroke;
  this._allowHoriz = allowHorizResize == null ? true : allowHorizResize;
  this._allowVert = allowVertResize == null ? true : allowVertResize;
  this._horizBounds = horizResizeBounds;
  this._vertBounds = vertResizeBounds;

  // Set up the glass pane
  this._glassPane = new dvt.Rect(this._context, glassPaneBounds.x, glassPaneBounds.y, glassPaneBounds.w, glassPaneBounds.h);
  this._glassPane.setInvisibleFill();

  // Flags
  this._marqueeOn = false;     // whether the marquee has been activated
  this._marqueeDrawn = false;  // whether the marquee has been drawn
  this._resizeHoriz = false;   // whether the marquee is resizeable horizontally
  this._resizeVert = false;    // whether the marquee is resizeable vertically
};


/**
 * Processes drag start.
 * @param {dvt.Point} relPos The event position relative to the stage.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {dvt.MarqueeEvent}
 */
dvt.MarqueeHandler.prototype.processDragStart = function(relPos, ctrlKey) {
  if (!this._marqueeOn) {
    this._origPt = this._container.stageToLocal(relPos); // marquee origin

    // Determine if the marquee is resizeable horizontally and/or vertically:
    // - if origin is inside marqueeBounds, then allow resize in both directions if possible;
    // - if origin is inside vertResizeBounds, then only vert resize is possible;
    // - if origin is inside horizResizeBounds, then only horiz resize is possible;
    // - otherwise, marquee shouldn't be initiated.
    this._resizeHoriz = this._allowHoriz;
    this._resizeVert = this._allowVert;
    if (!this._bounds.containsPoint(this._origPt.x, this._origPt.y)) {
      if (this._vertBounds && this._vertBounds.containsPoint(this._origPt.x, this._origPt.y))
        this._resizeHoriz = false;
      else if (this._horizBounds && this._horizBounds.containsPoint(this._origPt.x, this._origPt.y))
        this._resizeVert = false;
      else
        return null;
    }

    this._marqueeOn = true;
    this._marquee = null;
    return this._createMarqueeEvent(dvt.MarqueeEvent.SUBTYPE_START, ctrlKey);
  }

  return null;
};


/**
 * Processes drag move.
 * @param {dvt.Point} relPos The event position relative to the stage.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {dvt.MarqueeEvent}
 */
dvt.MarqueeHandler.prototype.processDragMove = function(relPos, ctrlKey) {
  if (!this._marqueeOn)
    return null;

  if (!this._marqueeDrawn) {
    this._container.addChild(this._glassPane);

    // Initiate the marquee
    this._marquee = new dvt.Rect(this._context, this._bounds.x, this._bounds.y, this._bounds.w, this._bounds.h);
    if (this._resizeHoriz) {
      this._marquee.setX(this._origPt.x);
      this._marquee.setWidth(0);
    }
    if (this._resizeVert) {
      this._marquee.setY(this._origPt.y);
      this._marquee.setHeight(0);
    }

    this._marquee.setStroke(this._stroke);
    this._marquee.setFill(this._fill);
    this._marquee.setPixelHinting(true);
    this._glassPane.addChild(this._marquee);

    this._marqueeDrawn = true;
  }

  var newPt = this._container.stageToLocal(relPos);

  // Bound the newPt within the marquee bounds
  newPt.x = Math.max(newPt.x, this._bounds.x);
  newPt.x = Math.min(newPt.x, this._bounds.x + this._bounds.w);
  newPt.y = Math.max(newPt.y, this._bounds.y);
  newPt.y = Math.min(newPt.y, this._bounds.y + this._bounds.h);

  // Update marquee x and w
  if (this._resizeHoriz) {
    this._marquee.setWidth(Math.abs(newPt.x - this._origPt.x));
    if (newPt.x < this._origPt.x)
      this._marquee.setX(newPt.x);
    else
      this._marquee.setX(this._origPt.x);
  }

  // Update marquee y and h
  if (this._resizeVert) {
    this._marquee.setHeight(Math.abs(newPt.y - this._origPt.y));
    if (newPt.y < this._origPt.y)
      this._marquee.setY(newPt.y);
    else
      this._marquee.setY(this._origPt.y);
  }

  return this._createMarqueeEvent(dvt.MarqueeEvent.SUBTYPE_MOVE, ctrlKey);
};


/**
 * Processes drag end.
 * @param {dvt.Point} relPos The event position relative to the stage.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {dvt.MarqueeEvent}
 */
dvt.MarqueeHandler.prototype.processDragEnd = function(relPos, ctrlKey) {
  if (this._marqueeOn) {
    this._marqueeOn = false;

    if (this._marqueeDrawn) {
      // Remove the marquee and glass pane
      this._glassPane.removeChild(this._marquee);
      this._container.removeChild(this._glassPane);
      this._marqueeDrawn = false;

      return this._createMarqueeEvent(dvt.MarqueeEvent.SUBTYPE_END, ctrlKey);
    }
  }

  return null;
};


/**
 * Processes drag end.
 * @param {dvt.Point} relPos The event position relative to the stage.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {dvt.MarqueeEvent}
 */
dvt.MarqueeHandler.prototype.cancelMarquee = function() {
  if (this._marqueeOn) {
    this._marqueeOn = false;

    if (this._marqueeDrawn) {
      // Remove the marquee and glass pane
      this._glassPane.removeChild(this._marquee);
      this._container.removeChild(this._glassPane);
      this._marqueeDrawn = false;

      return true;
    }
  }

  return false;
};


/**
 * Creates a marquee event.
 * @param {string} type Event type.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {dvt.MarqueeEvent} The event.
 */
dvt.MarqueeHandler.prototype._createMarqueeEvent = function(type, ctrlKey) {
  var x = null;
  var y = null;
  var w = null;
  var h = null;

  if (this._resizeHoriz) {
    x = this._marquee ? this._marquee.getX() : this._origPt.x;
    w = this._marquee ? this._marquee.getWidth() : 0;
  }
  if (this._resizeVert) {
    y = this._marquee ? this._marquee.getY() : this._origPt.y;
    h = this._marquee ? this._marquee.getHeight() : 0;
  }

  return new dvt.MarqueeEvent(type, x, y, w, h, ctrlKey);
};


/**
 * Returns the appropriate cursor type.
 * @param {dvt.Point} relPos The current cursor position relative to the stage.
 * @return {string} The cursor type.
 */
dvt.MarqueeHandler.prototype.getCursor = function(relPos) {
  var pos = this._container.stageToLocal(relPos);
  var withinBounds = this._bounds.containsPoint(pos.x, pos.y);
  var withinVertBounds = this._vertBounds && this._vertBounds.containsPoint(pos.x, pos.y);
  var withinHorizBounds = this._horizBounds && this._horizBounds.containsPoint(pos.x, pos.y);

  if (withinBounds || withinVertBounds || withinHorizBounds)
    return 'crosshair';
  else
    return 'inherit';
};
/**
 * Handler used for pan and zoom operations.
 * @constructor
 * @param {dvt.Container} container Glass pane container.
 * @param {dvt.Rectangle} panZoomBounds The area in which pan/zoom can be initiated.
 * @param {dvt.Rectangle} glassPaneBounds The area that will be covered by the glass pane during pan.
 * @param {number} zoomRate The rate of mouse wheel zoom.
 */
dvt.PanZoomHandler = function(container, panZoomBounds, glassPaneBounds, zoomRate) {
  this.Init(container, panZoomBounds, glassPaneBounds, zoomRate);
};

dvt.Obj.createSubclass(dvt.PanZoomHandler, dvt.Obj);


/**
 * @param {dvt.Container} container Glass pane container.
 * @param {dvt.Rectangle} panZoomBounds The area in which the pan/zoom can be initiated.
 * @param {dvt.Rectangle} glassPaneBounds The area that will be covered by the glass pane when the marquee is active.
 * @param {number} zoomRate The rate of mouse wheel zoom.
 */
dvt.PanZoomHandler.prototype.Init = function(container, panZoomBounds, glassPaneBounds, zoomRate) {
  this._context = container.getCtx();
  this._container = container;
  this._bounds = panZoomBounds;
  this._zoomRate = zoomRate;

  // Set up the glass pane
  this._glassPane = new dvt.Rect(this._context, glassPaneBounds.x, glassPaneBounds.y, glassPaneBounds.w, glassPaneBounds.h);
  this._glassPane.setInvisibleFill();

  // Flags
  this._panOn = false;           // whether the pan has been initiated
  this._glassPaneDrawn = false;  // whether the glass pane has been drawn
  this._pinchOn = false;         // whether the pinch has been initiated
};


/**
 * Processes drag start.
 * @param {dvt.Point} relPos The event position relative to the stage.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.processDragStart = function(relPos) {
  if (!this._panOn) {
    this._origPt = this._container.stageToLocal(relPos); // drag origin
    this._lastPt = this._origPt;

    // Ignore if the start point is outside the pan/zoom bounds
    if (!this._bounds.containsPoint(this._origPt.x, this._origPt.y))
      return null;

    this._panOn = true;

    return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_PAN_START, 0, 0, 0, 0, 0, 0, 0, 0);
  }

  return null;
};


/**
 * Processes drag move.
 * @param {dvt.Point} relPos The event position relative to the stage.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.processDragMove = function(relPos) {
  if (!this._panOn)
    return null;

  if (!this._glassPaneDrawn) {
    this._container.addChild(this._glassPane);
    this._glassPaneDrawn = true;
  }

  var newPt = this._container.stageToLocal(relPos);
  var deltaX = newPt.x - this._lastPt.x;
  var deltaY = newPt.y - this._lastPt.y;
  var totalDeltaX = newPt.x - this._origPt.x;
  var totalDeltaY = newPt.y - this._origPt.y;
  this._lastPt = newPt;

  return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_PAN_MOVE, -deltaX, -deltaX, -deltaY, -deltaY,
      -totalDeltaX, -totalDeltaX, -totalDeltaY, -totalDeltaY);
};


/**
 * Processes drag end.
 * @param {dvt.Point} relPos The event position relative to the stage.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.processDragEnd = function(relPos) {
  if (this._panOn) {
    this._panOn = false;

    if (this._glassPaneDrawn) {
      // Remove the glass pane
      this._container.removeChild(this._glassPane);
      this._glassPaneDrawn = false;

      var newPt = relPos ? this._container.stageToLocal(relPos) : this._lastPt;
      var deltaX = newPt.x - this._lastPt.x;
      var deltaY = newPt.y - this._lastPt.y;
      var totalDeltaX = newPt.x - this._origPt.x;
      var totalDeltaY = newPt.y - this._origPt.y;
      this._lastPt = null;

      return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_PAN_END, -deltaX, -deltaX, -deltaY, -deltaY,
          -totalDeltaX, -totalDeltaX, -totalDeltaY, -totalDeltaY);
    }
  }

  return null;
};


/**
 * Processes mouse wheel.
 * @param {dvt.Point} relPos The event position relative to the stage.
 * @param {number} delta The mouse wheel delta.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.processMouseWheel = function(relPos, delta) {
  // Ignore if the cursor is outside the pan/zoom bounds
  var startPt = this._container.stageToLocal(relPos);
  if (!this._bounds.containsPoint(startPt.x, startPt.y))
    return null;

  delta *= this._zoomRate;

  // Compute the deltas. It should maintain the cursor pointing at the same item.
  var deltaXMin = delta * (startPt.x - this._bounds.x);
  var deltaXMax = -delta * (this._bounds.x + this._bounds.w - startPt.x);
  var deltaYMin = delta * (startPt.y - this._bounds.y);
  var deltaYMax = -delta * (this._bounds.y + this._bounds.h - startPt.y);

  return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_ZOOM, deltaXMin, deltaXMax, deltaYMin, deltaYMax,
      deltaXMin, deltaXMax, deltaYMin, deltaYMax);
};


/**
 * Processes pinch start.
 * @param {dvt.Point} relPos1 The position of the first finger relative to the stage.
 * @param {dvt.Point} relPos2 The position of the second finger relative to the stage.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.processPinchStart = function(relPos1, relPos2) {
  if (!this._pinchOn) {
    // Save pinch origin
    this._origPt1 = this._container.stageToLocal(relPos1);
    this._origPt2 = this._container.stageToLocal(relPos2);
    this._lastPt1 = this._origPt1;
    this._lastPt2 = this._origPt2;

    // Ignore if the start points are outside the pan/zoom bounds
    if (!this._bounds.containsPoint(this._origPt1.x, this._origPt1.y) || !this._bounds.containsPoint(this._origPt2.x, this._origPt2.y))
      return null;

    this._pinchOn = true;

    return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_PINCH_START, 0, 0, 0, 0, 0, 0, 0, 0);
  }

  return null;
};


/**
 * Processes pinch move.
 * @param {dvt.Point} relPos1 The position of the first finger relative to the stage.
 * @param {dvt.Point} relPos2 The position of the second finger relative to the stage.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.processPinchMove = function(relPos1, relPos2) {
  if (!this._pinchOn)
    return null;

  var newPt1 = this._container.stageToLocal(relPos1);
  var newPt2 = this._container.stageToLocal(relPos2);

  var deltas = this._computePinchDeltas(newPt1, newPt2, this._lastPt1, this._lastPt2);
  var totalDeltas = this._computePinchDeltas(newPt1, newPt2, this._origPt1, this._origPt2);

  this._lastPt1 = newPt1;
  this._lastPt2 = newPt2;

  return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_PINCH_MOVE, deltas.dxMin, deltas.dxMax, deltas.dyMin, deltas.dyMax,
      totalDeltas.dxMin, totalDeltas.dxMax, totalDeltas.dyMin, totalDeltas.dyMax);
};


/**
 * Processes pinch end.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.processPinchEnd = function() {
  if (this._pinchOn) {
    this._pinchOn = false;
    var totalDeltas = this._computePinchDeltas(this._lastPt1, this._lastPt2, this._origPt1, this._origPt2);

    this._lastPt1 = null;
    this._lastPt2 = null;

    return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_PINCH_END, 0, 0, 0, 0,
        totalDeltas.dxMin, totalDeltas.dxMax, totalDeltas.dyMin, totalDeltas.dyMax);
  }

  return null;
};


/**
 * Computes how much the bounds should change based on the two finger movements.
 * @param {dvt.Point} pos1 Current position of the first finger.
 * @param {dvt.Point} pos2 Current position of the second finger.
 * @param {dvt.Point} prevPos1 Previous position of the first finger.
 * @param {dvt.Point} prevPos2 Previous position of the second finger.
 * @return {object} An object containing deltas for the bounds: dxMin, dxMax, dyMin, and dyMax.
 * @private
 */
dvt.PanZoomHandler.prototype._computePinchDeltas = function(pos1, pos2, prevPos1, prevPos2) {
  // Calculate the ratio of the current inter-finger distance to the previous
  var dx = Math.abs(pos1.x - pos2.x);
  var dy = Math.abs(pos1.y - pos2.y);
  var prevDx = Math.abs(prevPos1.x - prevPos2.x);
  var prevDy = Math.abs(prevPos1.y - prevPos2.y);
  // The check dx > dy/2 is to make it easier to zoom in y-direction alone. Otherwise, one might pinch in y-direction,
  // but the slight finger movement in the x-direction will cause the x-axis to zoom as well.
  var zoomX = dx > dy / 2 ? prevDx / dx : 1;
  var zoomY = dy > dx / 2 ? prevDy / dy : 1;

  // Calculate the distance the center of the two fingers has moved
  var cx = (pos1.x + pos2.x) / 2;
  var cy = (pos1.y + pos2.y) / 2;
  var prevCx = (prevPos1.x + prevPos2.x) / 2;
  var prevCy = (prevPos1.y + prevPos2.y) / 2;
  var dcx = cx - prevCx;
  var dcy = cy - prevCy;

  // Perform a zoom
  var dxMin = (1 - zoomX) * (cx - this._bounds.x);
  var dxMax = (zoomX - 1) * (this._bounds.x + this._bounds.w - cx);
  var dyMin = (1 - zoomY) * (cy - this._bounds.y);
  var dyMax = (zoomY - 1) * (this._bounds.y + this._bounds.h - cy);

  // Perform a scroll
  dxMin -= dcx;
  dxMax -= dcx;
  dyMin -= dcy;
  dyMax -= dcy;

  return {dxMin: dxMin, dxMax: dxMax, dyMin: dyMin, dyMax: dyMax};
};

/**
 * Zooms by the specified amount.
 * @param {number} dz A number specifying the zoom ratio, e.g. dz = 2 means zoom in by 200%.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.zoomBy = function(dz) {
  var shiftRatio = (1 / dz - 1) / 2;
  var deltaXMin = -shiftRatio * (this._bounds.w);
  var deltaXMax = shiftRatio * (this._bounds.w);
  var deltaYMin = -shiftRatio * (this._bounds.h);
  var deltaYMax = shiftRatio * (this._bounds.h);

  return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_ZOOM, deltaXMin, deltaXMax, deltaYMin, deltaYMax,
      deltaXMin, deltaXMax, deltaYMin, deltaYMax);
};

/**
 * Pans by the specified amount.
 * @param {number} dx A number from specifying the pan ratio in the x direction, e.g. dx = 0.5 means pan end by 50%.
 * @param {number} dy A number from specifying the pan ratio in the y direction, e.g. dy = 0.5 means pan down by 50%.
 * @return {dvt.PanZoomEvent}
 */
dvt.PanZoomHandler.prototype.panBy = function(dx, dy) {
  var deltaX = dx * this._bounds.w * (dvt.Agent.isRightToLeft(this._context) ? -1 : 1);
  var deltaY = dy * this._bounds.h;

  return new dvt.PanZoomEvent(dvt.PanZoomEvent.SUBTYPE_PAN_END, deltaX, deltaX, deltaY, deltaY,
      deltaX, deltaX, deltaY, deltaY);
};


/**
 * Sets the pan cursor.
 * @param {string} panUpCursor The URI of the cursor image for the non-dragged state.
 * @param {string} panDownCursor The URI of the cursor image for the dragged state.
 */
dvt.PanZoomHandler.prototype.setPanCursor = function(panUpCursor, panDownCursor) {
  // IE doesn't support cursor image with custom positioning
  if (dvt.Agent.isPlatformIE())
    return;

  if (panUpCursor)
    this._panUpCursor = 'url(' + panUpCursor + ') 8 8, auto';
  if (panDownCursor)
    this._panDownCursor = 'url(' + panDownCursor + ') 8 8, auto';
};


/**
 * Returns the appropriate cursor type.
 * @param {dvt.Point=} relPos The current cursor position relative to the stage.
 * @return {string} The cursor type.
 */
dvt.PanZoomHandler.prototype.getCursor = function(relPos) {
  if (relPos == null || this.isWithinBounds(relPos)) {
    if (this._panOn)
      return this._panDownCursor ? this._panDownCursor : 'move';
    else
      return this._panUpCursor ? this._panUpCursor : 'move';
  }
  else
    return 'inherit';
};

/**
 * Returns whether the point is within the bounds of the pan-zoom handler.
 * @param {dvt.Point} relPos The current cursor position relative to the stage.
 * @return {boolean}
 */
dvt.PanZoomHandler.prototype.isWithinBounds = function(relPos) {
  var pos = this._container.stageToLocal(relPos);
  return this._bounds.containsPoint(pos.x, pos.y);
};
/**
 * Base class object for tooltip services.
 * @class dvt.TooltipManager
 * @extends {dvt.Obj}
 * @constructor
 */
dvt.TooltipManager = function() {};

dvt.Obj.createSubclass(dvt.TooltipManager, dvt.Obj);


/**
 * Displays a tooltip with the given parameters.
 * @param {int} x the x position as relative to coordinate space of implementation
 * @param {int} y the y position as relative to coordinate space of implementation
 * @param {string} text the text to show within the tooltip
 * @param {string} borderColor the border color of the tooltip
 */
dvt.TooltipManager.prototype.showDatatip = function(x, y, text, borderColor)
{
  // TODO subclasses should override
};


/**
 * Displays a tooltip.
 * @param {int} x the x position as relative to coordinate space of implementation
 * @param {int} y the y position as relative to coordinate space of implementation
 * @param (string) text The text to display in the tooltip.
 * @param (dvt.Displayable) component The display object to use for tracking mouse movements.
 * @param (boolean) bTrackMouse Optional boolean to specify whether mouse movement should
 *                  also reposition the tooltip.  Default is true.
 * @param {string} borderColor Optional the border color of the tooltip
 *
 * @see hideTooltip()
 * @see showDatatip()
 */
dvt.TooltipManager.prototype.showTooltip = function(x, y, text, component, bTrackMouse, borderColor)
{
  // TODO subclasses should override
};


/**
 * Hides the tooltip
 */
dvt.TooltipManager.prototype.hideTooltip = function()
{
  // TODO subclasses should override
};


/**
 * Interactivity handle for category rollover effects support.
 * Objects must implement DvtLogicalObject and DvtCategoricalObject to be supported by this handler.
 * @param {function} callback A function that responds to component events.
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class dvt.CategoryRolloverHandler
 * @extends {dvt.Obj}
 * @constructor
 */
dvt.CategoryRolloverHandler = function(callback, callbackObj) {
  this._callback = callback;
  this._callbackObj = callbackObj;

  // Assume the source of the event is also the callbackObj. We can add a param if needed.
  this._source = callbackObj;

  /**
   * True if highlight mode is on. This is true anytime after the initial hover delay has passed and the hover timeout
   * has not.
   * @private
   */
  this._bHighlightMode = false;

  /**
   * Callback used to apply highlighting. The delay will vary based on whether this is an initial rollover, subsequent
   * rollover, or rollout.
   * @private
   */
  this._hoverDelayCallback = null;

  /**
   * Callback used to disabled highlight mode. It will be called after a sufficient interval of no highlighting.
   * @see dvt.CategoryRolloverHandler._HOVER_TIMEOUT
   * @private
   */
  this._highlightModeTimeout = null;

  /**
   * Used to override default hover delay value. The delay is used in applying highlighting for subsequent highlights.
   * It's primary function is to reduce jitter when moving across small gaps between data items.
   * @see dvt.CategoryRolloverHandler._HOVER_DELAY
   * @private
   */
  this._hoverDelay = dvt.CategoryRolloverHandler._HOVER_DELAY;
};

dvt.Obj.createSubclass(dvt.CategoryRolloverHandler, dvt.Obj);

/**
 * Default hover delay value
 * @see this._hoverDelayCallback
 * @const
 * @private
 */
dvt.CategoryRolloverHandler._HOVER_DELAY = 50;
/**
 * The delay in disabling highlight mode. This is satisfied when no object is highlighted for this duration.
 * @see this._highlightModeTimeout
 * @const
 * @private
 */
dvt.CategoryRolloverHandler._HOVER_TIMEOUT = 1000;

/**
 * The default fade out opacity.
 * @const
 * @private
 */
dvt.CategoryRolloverHandler._FADE_OUT_OPACITY = 0.35;

/**
 * Processes the specified highlight event for the array of objects.
 * @param {object} event The event that was triggered.
 * @param {array} objs The array of objects containing hide and show targets.
 * @param {number} initialHoverDelay The delay before the initial highlight action.
 * @param {boolean=} bAnyMatched True if an object need only contain any of the categories to be highlighted.
 * @param {number=} customAlpha A custom alpha for the dimmed objects.
 * @deprecated We should update all components to use the highlight API instead.
 */
dvt.CategoryRolloverHandler.prototype.processEvent = function(event, objs, initialHoverDelay, bAnyMatched, customAlpha)
{
  if (!event || !objs || (objs.length == 0))
    return;

  // Cancel any pending highlight operations. We've either moved to a new object or left the current one.
  if (this._hoverDelayCallback) {
    clearTimeout(this._hoverDelayCallback);
    this._hoverDelayCallback = null;
  }

  // Create the callback to perform the appropriate highlighting.
  var type = event['_highlightType'];
  if (type == 'over') {
    // Highlight after the appropriate delay, based on whether we're already in highlight mode.
    var hoverDelay = this._bHighlightMode ? this._hoverDelay : initialHoverDelay;
    this._hoverDelayCallback = setTimeout(this.GetRolloverCallback(event, objs, bAnyMatched, customAlpha), hoverDelay);//@HTMLUpdateOK

    // If the highlight mode timeout has been started, cancel it.
    if (this._highlightModeTimeout) {
      clearInterval(this._highlightModeTimeout);
      this._highlightModeTimeout = null;
    }
  }
  else if (type == 'out' && this._bHighlightMode) {
    // Process rollout if a highlight has occurred.
    this._hoverDelayCallback = setTimeout(this.GetRolloutCallback(event, objs, bAnyMatched, customAlpha), this._hoverDelay);
  }
};

/**
 * Returns the callback to be applied after a rollover.
 * @param {object} event The event that was triggered.
 * @param {array} objs The array of objects containing hide and show targets.
 * @param {boolean=} bAnyMatched True if an object need only contain any of the categories to be highlighted.
 * @param {number=} customAlpha A custom alpha for the dimmed objects.
 * @return {function}
 * @protected
 */
dvt.CategoryRolloverHandler.prototype.GetRolloverCallback = function(event, objs, bAnyMatched, customAlpha) {
  var callback = function() {
    this._bHighlightMode = true;
    dvt.CategoryRolloverHandler.highlight(event['categories'], objs, bAnyMatched, customAlpha);

    // Fire the event to the component's callback if specified.
    if (this._callback)
      this._callback.call(this._callbackObj, event, this._source);
  };
  return dvt.Obj.createCallback(this, callback);
};

/**
 * Returns the callback to be applied after a rollout.
 * @param {object} event The event that was triggered.
 * @param {array} objs The array of objects containing hide and show targets.
 * @param {boolean=} bAnyMatched True if an object need only contain any of the categories to be highlighted.
 * @param {number=} customAlpha A custom alpha for the dimmed objects.
 * @return {function}
 * @protected
 */
dvt.CategoryRolloverHandler.prototype.GetRolloutCallback = function(event, objs, bAnyMatched, customAlpha) {
  var callback = function() {
    dvt.CategoryRolloverHandler.highlight(event['categories'], objs, bAnyMatched, customAlpha);
    this.SetHighlightModeTimeout();

    // Fire the event to the component's callback if specified.
    if (this._callback)
      this._callback.call(this._callbackObj, event, this._source);
  };
  return dvt.Obj.createCallback(this, callback);
};

/**
 * Highlights the objects corresponding to the specified objects.  If no categories are specified, all highlight will
 * be removed.
 * @param {array} categories The array of categories whose data items will be highlighted.
 * @param {array} objs The array of objects containing hide and show targets.
 * @param {boolean=} bAnyMatched True if an object need only contain any of the categories to be highlighted.
 * @param {number=} customAlpha A custom alpha for the dimmed objects.
 */
dvt.CategoryRolloverHandler.highlight = function(categories, objs, bAnyMatched, customAlpha) {
  if (!objs)
    return;

  var dimmedAlpha = !customAlpha ? dvt.CategoryRolloverHandler._FADE_OUT_OPACITY : customAlpha;

  // Loop through the objects and update objects not belonging to the specified category.
  for (var i = 0; i < objs.length; i++) {
    var obj = objs[i];
    if (obj && obj.getCategories) {
      var match = bAnyMatched ? dvt.CategoryRolloverHandler._hasAnyCategory(obj, categories) : dvt.CategoryRolloverHandler._hasAllCategories(obj, categories);
      var bDimmed = categories && categories.length > 0 && !match;
      dvt.CategoryRolloverHandler._highlightObj(obj, bDimmed, dimmedAlpha);
    }
  }
};

/**
 * Helper function to highlight the specified object. Assumes that obj is not null.
 * @param {object} obj The logical object to be highlighted.
 * @param {boolean} bDimmed True if the object should be dimmed.
 * @param {number} dimmedAlpha The alpha for dimmed objects
 * @private
 */
dvt.CategoryRolloverHandler._highlightObj = function(obj, bDimmed, dimmedAlpha) {
  var alpha = bDimmed ? dimmedAlpha : 1;

  // Delegate to the object to perform highlighting if supported. Otherwise adjust the alpha of all displayables.
  if (obj.highlight)
    obj.highlight(bDimmed, alpha);
  else {
    var displayables = obj.getDisplayables();
    dvt.CategoryRolloverHandler._updateAlpha(displayables, alpha);
  }
};

/**
 * Updates the alpha of the displayables to the specified value.
 * @param {array} displayables The array of displayables.
 * @param {number} alpha The new alpha value.
 * @private
 */
dvt.CategoryRolloverHandler._updateAlpha = function(displayables, alpha) {
  if (!displayables)
    return;

  for (var i = 0; i < displayables.length; i++) {
    displayables[i].setAlpha(alpha);
  }
};

/**
 * Returns true if the specified object belongs to one of the specified categories.
 * @param {DvtCategoricalObject} obj
 * @param {array} categories
 * @return {boolean}
 * @private
 */
dvt.CategoryRolloverHandler._hasAnyCategory = function(obj, categories) {
  if (!obj || !obj.getCategories)
    return false;

  return dvt.ArrayUtils.hasAnyItem(obj.getCategories(), categories);
};

/**
 * Returns true if the specified object belongs to all of the specified categories.
 * @param {DvtCategoricalObject} obj
 * @param {array} categories
 * @return {boolean}
 * @private
 */
dvt.CategoryRolloverHandler._hasAllCategories = function(obj, categories) {
  if (!obj || !obj.getCategories)
    return false;

  return dvt.ArrayUtils.hasAllItems(obj.getCategories(), categories);
};

/**
 * Sets highlight mode
 * @param {boolean} bMode True if highlight mode is on
 * @protected
 */
dvt.CategoryRolloverHandler.prototype.SetHighlightMode = function(bMode) {
  this._bHighlightMode = bMode;
};

/**
 * Sets highlight mode timeout
 * @protected
 */
dvt.CategoryRolloverHandler.prototype.SetHighlightModeTimeout = function() {
  // First create the callback to cancel highlight mode after the given timeout.
  var highlightTimeout = dvt.Obj.createCallback(this, function() {this.SetHighlightMode(false);});
  this._highlightModeTimeout = setTimeout(highlightTimeout, dvt.CategoryRolloverHandler._HOVER_TIMEOUT);//@HTMLUpdateOK
};

/**
 * Sets the hover delay value
 * @param {number} hoverDelay The delay in applying highlighting for subsequent highlights. The delay value is in milliseconds.
 */
dvt.CategoryRolloverHandler.prototype.setHoverDelay = function(hoverDelay) {
  this._hoverDelay = hoverDelay;
};
/**
 * Event manager that processes low level events and sends them to the appropriate handlers.
 * @param {dvt.Context} context The platform specific context object.
 * @param {function} callback A function that responds to component events.
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class
 * @implements {DvtComponentKeyboardHandler}
 * @constructor
 */
dvt.EventManager = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
};

dvt.Obj.createSubclass(dvt.EventManager, dvt.Obj);

dvt.EventManager.CLEAR_SELECTION_ACTION_TYPE = 'clearSelectionActionType';

/**
 * Used for touch response touchStart
 * @const
 */
dvt.EventManager.TOUCH_RESPONSE_TOUCH_START = 'touchStart';
/**
 * Used for touch response touchHold
 * @const
 */
dvt.EventManager.TOUCH_RESPONSE_TOUCH_HOLD = 'touchHold';
/**
 * Used for touch response auto
 * @const
 */
dvt.EventManager.TOUCH_RESPONSE_AUTO = 'auto';
/**
 * Used for chrome scrollHeight/Width checking which returns a slightly higher value than actual DOM scrolHeight
 * @const
 * @private
 */
dvt.EventManager._TOUCH_RESPONSE_PADDING_CHECK = 10;
/**
 * @const
 * @private
 */
dvt.EventManager._EVENT_INFO_TOOLTIP_DISPLAYED_KEY = 'tooltipDisplayed';
/**
 * @const
 * @private
 */
dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY = 'currentTarget';
/**
 * @const
 * @private
 */
dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY = 'popupDisplayed';



/**
 * Method called by the constructor to initialize this object
 * @param {dvt.Context} context The platform specific context object.
 * @param {function} callback A function that responds to component events.
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @protected
 */
dvt.EventManager.prototype.Init = function(context, callback, callbackObj) {
  this._context = context;
  this._callback = callback;
  this._callbackObj = callbackObj;
  // Used to keep track of the previous and current touch targets
  this._touchMap = {};

  // Initialize the higher level event handlers.  These handlers are exposed as protected fields
  // so that subclasses can fully customize the behavior of this event manager.
  this._selectionHandler = null;
  this._marqueeHandler = null;
  this.PopupHandler = new DvtPopupBehaviorHandler(context, callback, callbackObj);
  this.ClientBehaviorHandler = this.CreateClientBehaviorHandler(context, callback, callbackObj);
  this.KeyboardHandler = null;

  // Rollover Handler: Used to support the hover delays.
  this.RolloverHandler = this.CreateCategoryRolloverHandler(callback, callbackObj);

  // Tooltips enabled by default
  this.setTooltipsEnabled(true);

  var id = context.getStage().getId();
  if (!id)
    id = 'undefinedId';
  this.CustomTooltipManager = this._context.getCustomTooltipManager();
  this.CustomTooltipManager.addTooltipEventListener(DvtActionTooltipEvent.TOOLTIP_CLOSED_TYPE, this.OnActionTooltipClosed, this);
  this.CustomTooltipManager.addTooltipEventListener(DvtActionTooltipEvent.TOOLTIP_STARTED_TYPE, this.OnActionTooltipStarted, this);

  this.TouchManager = null;
  if (dvt.Agent.isTouchDevice())
    this.TouchManager = new dvt.TouchManager('touchmanager', this._context);

  // The DvtKeyboardNavigable item that currently has keyboard focus
  this._focusedObj = null;

  // flag to indicate if the component should display keyboard focus
  this._shouldDisplayKeyboardFocus = false;

  // List of object types that should receive rollover/rollout events
  this._rolloverTypes = [];

  // An array of event managers that can process keyboard events sent to this
  // event manager, arranged in tab order. This event manager should be in this
  // array, but there may be other event managers as well, such as an event
  // manager for breadcrumbs
  this._keyboardHandlers = [this];

  // index to the _keyboardHandlers array indicating the current handler
  // that receives keyboard events
  this._currentKeyboardHandlerIdx = -1;
};


/**
 * Returns the dvt.Context associated with this event manager.
 * @return {dvt.Context}
 */
dvt.EventManager.prototype.getCtx = function() {
  return this._context;
};


/**
 * Associates the specified displayable with the specified object for this event manager.  This is used by the default
 * implementation of GetLogicalObject.
 * @param {dvt.Displayable} displayable The displayable to associate.
 * @param {object} obj The object to associate with.
 * @param {boolean} bReplace True if the existing logical objects should be replaced.
 */
dvt.EventManager.prototype.associate = function(displayable, obj, bReplace) {
  if (displayable) {
    // Create the logical objects array if not already present
    if (!displayable._logicalObjects || bReplace)
      displayable._logicalObjects = [];

    // Add this logical object and event manager mapping
    displayable._logicalObjects.push({logicalObject: obj, eventManager: this});

    // Tooltip support for XML renderer
    if (!dvt.Agent.isEnvironmentBrowser() && displayable.getImpl().setLogicalObj)
      displayable.getImpl().setLogicalObj(obj);
  }
};


/**
 * Adds event listeners to the specified displayable.
 * @param {dvt.Displayable} displayable The object on which to add the listeners.
 */
dvt.EventManager.prototype.addListeners = function(displayable) {
  if (!displayable)
    return;

  if (dvt.Agent.isTouchDevice()) {
    // Hide any tooltips previously shown
    this.hideTooltip();

    displayable.addEvtListener(dvt.TouchEvent.TOUCHSTART, this.OnTouchStartBubble, false, this);
    displayable.addEvtListener(dvt.TouchEvent.TOUCHMOVE, this.OnTouchMoveBubble, false, this);
    displayable.addEvtListener(dvt.TouchEvent.TOUCHEND, this.OnTouchEndBubble, false, this);

    this.TouchManager.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_START_TYPE, this._preOnComponentTouchHoverStart, this);
    this.TouchManager.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE, this._preOnComponentTouchHoverMove, this);
    this.TouchManager.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_END_TYPE, this._preOnComponentTouchHoverEnd, this);
    this.TouchManager.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, this._preOnComponentTouchHoverOut, this);
    this.TouchManager.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, this._preOnComponentTouchHoverOver, this);

    this.TouchManager.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_CLICK_TYPE, this._preOnComponentTouchClick, this);
    this.TouchManager.addTouchEventListener(dvt.ComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE, this._preOnComponentTouchDblClick, this);

  } else {
    displayable.addEvtListener(dvt.MouseEvent.CLICK, this.PreOnClick, false, this);
    displayable.addEvtListener(dvt.MouseEvent.DBLCLICK, this.PreOnDblClick, false, this);
    displayable.addEvtListener('contextmenu', this.PreOnContextMenu, false, this);
    displayable.addEvtListener(dvt.MouseEvent.MOUSEMOVE, this.PreOnMouseMove, false, this);
    displayable.addEvtListener(dvt.MouseEvent.MOUSEOVER, this.PreOnMouseOver, false, this);
    displayable.addEvtListener(dvt.MouseEvent.MOUSEOUT, this.PreOnMouseOut, false, this);
    displayable.addEvtListener(dvt.MouseEvent.MOUSEDOWN, this.PreOnMouseDown, false, this);
    displayable.addEvtListener(dvt.MouseEvent.MOUSEUP, this.PreOnMouseUp, false, this);
    displayable.addEvtListener(dvt.KeyboardEvent.KEYDOWN, this.OnKeyDown, false, this);
    displayable.addEvtListener(dvt.KeyboardEvent.KEYPRESS, this.OnKeyPress, false, this);
    displayable.addEvtListener(dvt.KeyboardEvent.KEYUP, this.OnKeyUp, false, this);
    displayable.addEvtListener(DvtFocusEvent.FOCUS, this.OnFocus, false, this);
    displayable.addEvtListener(DvtFocusEvent.BLUR, this.OnBlur, false, this);
  }
};


/**
 * Removes event listeners from the specified displayable.
 * @param {dvt.Displayable} displayable The object on which to remove the listeners.
 */
dvt.EventManager.prototype.removeListeners = function(displayable)
{
  if (!displayable)
    return;

  // Hide any tooltips previously shown
  this.hideTooltip();

  if (dvt.Agent.isTouchDevice()) {
    displayable.removeEvtListener(dvt.TouchEvent.TOUCHSTART, this.OnTouchStartBubble, false, this);
    displayable.removeEvtListener(dvt.TouchEvent.TOUCHMOVE, this.OnTouchMoveBubble, false, this);
    displayable.removeEvtListener(dvt.TouchEvent.TOUCHEND, this.OnTouchEndBubble, false, this);

    this.TouchManager.removeTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_START_TYPE, this._preOnComponentTouchHoverStart, this);
    this.TouchManager.removeTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE, this._preOnComponentTouchHoverMove, this);
    this.TouchManager.removeTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_END_TYPE, this._preOnComponentTouchHoverEnd, this);
    this.TouchManager.removeTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, this._preOnComponentTouchHoverOut, this);
    this.TouchManager.removeTouchEventListener(dvt.ComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, this._preOnComponentTouchHoverOver, this);

    this.TouchManager.removeTouchEventListener(dvt.ComponentTouchEvent.TOUCH_CLICK_TYPE, this._preOnComponentTouchClick, this);
    this.TouchManager.removeTouchEventListener(dvt.ComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE, this._preOnComponentTouchDblClick, this);

  } else {
    displayable.removeEvtListener(dvt.MouseEvent.CLICK, this.PreOnClick, false, this);
    displayable.removeEvtListener(dvt.MouseEvent.DBLCLICK, this.PreOnDblClick, false, this);
    displayable.removeEvtListener('contextmenu', this.PreOnContextMenu, false, this);
    displayable.removeEvtListener(dvt.MouseEvent.MOUSEMOVE, this.PreOnMouseMove, false, this);
    displayable.removeEvtListener(dvt.MouseEvent.MOUSEOVER, this.PreOnMouseOver, false, this);
    displayable.removeEvtListener(dvt.MouseEvent.MOUSEOUT, this.PreOnMouseOut, false, this);
    displayable.removeEvtListener(dvt.MouseEvent.MOUSEDOWN, this.PreOnMouseDown, false, this);
    displayable.removeEvtListener(dvt.MouseEvent.MOUSEUP, this.PreOnMouseUp, false, this);
    displayable.removeEvtListener(dvt.KeyboardEvent.KEYDOWN, this.OnKeyDown, false, this);
    displayable.removeEvtListener(dvt.KeyboardEvent.KEYUP, this.OnKeyUp, false, this);
    displayable.removeEvtListener(dvt.KeyboardEvent.KEYPRESS, this.OnKeyPress, false, this);
    displayable.removeEvtListener(DvtFocusEvent.FOCUS, this.OnFocus, false, this);
    displayable.removeEvtListener(DvtFocusEvent.BLUR, this.OnBlur, false, this);
  }

};


/**
 * Releases all resources owned to prevent memory leaks.
 */
dvt.EventManager.prototype.destroy = function()
{
  if (this.CustomTooltipManager)
  {
    this.CustomTooltipManager.removeTooltipEventListener(DvtActionTooltipEvent.TOOLTIP_CLOSED_TYPE, this.OnActionTooltipClosed, this);
    this.CustomTooltipManager.removeTooltipEventListener(DvtActionTooltipEvent.TOOLTIP_STARTED_TYPE, this.OnActionTooltipStarted, this);
  }
};


/**
 * A method called before an event is processed. Sets a touch manager for the event and calls preEventBuble on touch manager object.
 * @param {dvt.TouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.PreEventBubble = function(event) {
  this.TouchManager.preEventBubble(event);
};


/**
 * Sets the selection handler to use with this event manager.
 * @param {dvt.SelectionHandler} handler The selection handler to use.
 */
dvt.EventManager.prototype.setSelectionHandler = function(handler) {
  this._selectionHandler = handler;
};


/**
 * Gets the selection handler to use with this event manager.
 * @param {object} logicalObj Logical object used to retrieve the correct selection handler. Optional parameter used for
 * override subclasses like DvtThematicMapEventManager.
 */
dvt.EventManager.prototype.getSelectionHandler = function(logicalObj) {
  return this._selectionHandler;
};

/**
 * Gets the popup handler to use with this event manager.
 * @return {DvtPopupBehaviorHandler} PopupBehaviorHandler
 */
dvt.EventManager.prototype.getPopupHandler = function() {
  return this.PopupHandler;
};

/**
 * Sets the marquee handler to use with this event manager.
 * @param {dvt.MarqueeHandler} handler The marquee handler to use.
 */
dvt.EventManager.prototype.setMarqueeHandler = function(handler) {
  this._marqueeHandler = handler;
};


/**
 * Sets the drag source to use with this event manager.
 * @param {dvt.DragSource} dragSource The drag source to use
 */
dvt.EventManager.prototype.setDragSource = function(dragSource) {
  this.DragSource = dragSource;
  if (dvt.Agent.isTouchDevice())
    this.DragSource.setTouchManager(this.TouchManager);
};


/**
 * Sets the context menu handler to use with this event manager.
 * @param {dvt.ContextMenuHandler} handler The context menu handler to use.
 */
dvt.EventManager.prototype.setContextMenuHandler = function(handler) {
  this.ContextMenuHandler = handler;
};

/**
 * Sets the keyboard handler to use with this event manager. This method is
 * a no-op if we are rendering the component on a touch device.
 * @param {dvt.KeyboardHandler} handler The keyboard handler to use.
 */
dvt.EventManager.prototype.setKeyboardHandler = function(handler) 
{
  if (!dvt.Agent.isTouchDevice())
    this.KeyboardHandler = handler;
};


/**
 * Returns the keyboard handler used by this event manager
 * @return {dvt.KeyboardHandler}
 */
dvt.EventManager.prototype.getKeyboardHandler = function()
{
  return this.KeyboardHandler;
};


/**
 * Sets the event manager's keyboard focus on the given DvtKeyboardNavigable,
 * and update the keyboard focus visual feedback.
 * @param {DvtKeyboardNavigable} navigable The DvtKeyboardNavigable to receive keyboard focus
 */
dvt.EventManager.prototype.setFocusObj = function(navigable) {
  var curFocus = this.getFocus();
  if (navigable != curFocus) {
    this.setFocus(navigable);
    if (curFocus) {
      curFocus.hideKeyboardFocusEffect();
    }
    if (this.ShowKeyboardFocusByDefault()) {
      navigable.showKeyboardFocusEffect();
    }

    // set this event manager as the one to receive keyboard events
    if (this._currentKeyboardHandlerIdx > -1 &&
        this._currentKeyboardHandlerIdx < this._keyboardHandlers.length) {
      var handler = this._keyboardHandlers[this._currentKeyboardHandlerIdx];
      if (handler != this) { // Only hide focus effect if the keyboard handler has changed
        handler.hideKeyboardFocusEffect();
      }
    }
  }
  //update current keyboard handler when a navigable is in focus
  this.setCurrentKeyboardHandler(this);
};


/**
 * Sets the event manager's keyboard focus on the given DvtKeyboardNavigable
 * @param {DvtKeyboardNavigable} navigable The DvtKeyboardNavigable to receive keyboard focus
 */
dvt.EventManager.prototype.setFocus = function(navigable)
{
  if (this.KeyboardHandler)
    this._focusedObj = navigable;
};


/**
 * Returns the DvtKeyboardNavigable item with the current keyboard focus
 * @return {DvtKeyboardNavigable} The DvtKeyboardNavigable with the current keyboard focus
 */
dvt.EventManager.prototype.getFocus = function()
{
  return this.KeyboardHandler ? this._focusedObj : null;
};


/**
 * Updates the view when the owning component receives focus
 */
dvt.EventManager.prototype.setFocused = function(isFocused)
{
  var navigable = this.getFocus();
  // don't show keyboard focus effect on touch devices
  if (navigable && this.KeyboardHandler)
  {
    if (!isFocused)
    {
      navigable.hideKeyboardFocusEffect();
    }
    else if (this._shouldDisplayKeyboardFocus &&
             this._currentKeyboardHandlerIdx >= 0 &&
             this._currentKeyboardHandlerIdx < this._keyboardHandlers.length &&
             ((this._keyboardHandlers[this._currentKeyboardHandlerIdx] === this))
    )
    {
      // show keyboard focus effect if we receive focus after completing an animation
      // and we had keyboard focus before the animation began
      navigable.showKeyboardFocusEffect();
    }
  }

  if (!isFocused)
    this._shouldDisplayKeyboardFocus = false;
};


/**
 * Returns true if the keyboard focus should be shown by default (when the component has focus), even if the user
 * has not used the keyboard to intearact with the component
 *
 * @return {Boolean}
 */
dvt.EventManager.prototype.ShowKeyboardFocusByDefault = function() 
{
  return false;
};


/**
 * Specifies whether tooltips are enabled.
 * @param {boolean} tooltipsEnabled
 */
dvt.EventManager.prototype.setTooltipsEnabled = function(tooltipsEnabled) {
  this._tooltipsEnabled = tooltipsEnabled;
};


/**
 * Returns true if tooltips are enabled.
 * @param {dvt.Obj=} logicalObj The logical object that is currently being targeted, if one is available.
 * @return {boolean}
 */
dvt.EventManager.prototype.getTooltipsEnabled = function(logicalObj) {
  return this._tooltipsEnabled;
};


/**
 * Returns the logical object corresponding to the specified dvt.Displayable.  All high level event handlers,
 * such as the selection and popup handlers, are designed to react to the logical objects.
 * @param {dvt.Displayable} target The displayable.
 * @param {boolean} ignoreParents (optional) true indicates that parent displayables should not be searched if the
 *                  target doesn't have its own logical object
 * @return {object} The logical object corresponding to the target.
 * @protected
 */
dvt.EventManager.prototype.GetLogicalObject = function(target, ignoreParents) {
  var retObj = this.GetLogicalObjectAndDisplayable(target, ignoreParents);
  if (retObj) {
    return retObj.logicalObject;
  }
  return null;
};


/**
 * Returns the logical object and associated dvt.Displayable corresponding to the specified dvt.Displayable.
 * All high level event handlers, such as the selection and popup handlers, are designed to react to the
 * logical objects.
 * @param {dvt.Displayable} target The displayable.
 * @param {boolean} ignoreParents (optional) true indicates that parent displayables should not be searched if the
 *                  target doesn't have its own logical object
 * @return {object} The logical object and associated dvt.Displayable corresponding to the target.
 * @protected
 */
dvt.EventManager.prototype.GetLogicalObjectAndDisplayable = function(target, ignoreParents) {
  //: the popup handler needs to keep track of the displayable associated with the logical
  //object that launched a mousehover popup in order to dismiss the popup at the right time
  var displayable = target;
  while (displayable) {
    if (displayable._logicalObjects) {
      for (var i = 0; i < displayable._logicalObjects.length; i++) {
        var mapping = displayable._logicalObjects[i];
        if (mapping.eventManager == this) {
          var retObj = {};
          retObj.logicalObject = mapping.logicalObject;
          retObj.displayable = displayable;
          return retObj;
        }
      }
    }
    displayable = ignoreParents ? null : displayable.getParent();
  }
  return null;
};


/**
 * Returns the array of showPopupBehaviors for a specified logical object.
 * @param {object} obj The logical target object.
 * @return {array} The array of applicable DvtShowPopupBehaviors
 * @private
 */
dvt.EventManager.prototype._getShowPopupBehaviors = function(obj) {
  if (obj && obj.getShowPopupBehaviors)
    return obj.getShowPopupBehaviors();
};


/**
 * Returns the array of clientBehaviors for a specified logical object.
 * @param {object} obj The logical target object.
 * @return {array} The array of applicable DvtClientBehaviors
 * @private
 */
dvt.EventManager.prototype._getClientBehaviors = function(obj) {
  if (obj && obj.getClientBehaviors)
    return obj.getClientBehaviors();
};


/**
 * Returns the menu type to display.
 * @param {object} logicalObj Logical object used to retrieve the correct selection handler.
 * @return {object} The menu type to pass into the context menu handler.
 * @protected
 */
dvt.EventManager.prototype.GetContextMenuType = function(logicalObj) {
  // Figure out the selection size, which determines which menu to display
  var selectionHandler = this.getSelectionHandler(logicalObj);
  var selectionSize = selectionHandler ? selectionHandler.getSelection().length : 0;
  if (selectionSize <= 0)
    return dvt.ContextMenuHandler.TYPE_BODY_CONTEXT_MENU;
  else if (selectionSize == 1)
    return dvt.ContextMenuHandler.TYPE_CONTEXT_MENU;
  else
    return dvt.ContextMenuHandler.TYPE_MULTI_SELECT_CONTEXT_MENU;
};

/**
 * Returns the tooltip color for the specified object.
 * @param {object} obj The logical object.
 * @param {number} x The relative x coordinate of the event
 * @param {number} y The relative y coordinate of the event
 */
dvt.EventManager.prototype.GetTooltipColor = function(obj, x, y) {
  if (obj && obj.getDatatipColor)
    return obj.getDatatipColor();
};


/**
 * Fires the specified event through the callback.
 * @param {object} event
 * @param {object} source The component that is the source of the event, if available.
 */
dvt.EventManager.prototype.FireEvent = function(event, source) {
  if (this._callback)
    this._callback.call(this._callbackObj, event, source);
};


/**
 * Fires a selection event with the current selection state.
 * @param {object} logicalObj Logical object used to retrieve the correct selection handler.
 * @private
 */
dvt.EventManager.prototype.fireSelectionEvent = function(logicalObj) {
  var selectionHandler = this.getSelectionHandler(logicalObj);
  if (!selectionHandler)
    return;

  // Get the array of selected ids
  var selectedIds = selectionHandler.getSelectedIds();

  // Create and fire the event
  var selectionEvent = dvt.EventFactory.newSelectionEvent(selectedIds);
  this._callback.call(this._callbackObj, selectionEvent);
};

//*******************************************************************************//
//*********************** Begin Event Listeners *********************************//
//*******************************************************************************//


/**
 * Click event handler that accounts for double clicks
 * @protected
 */
dvt.EventManager.prototype.PreOnClick = function(event) {
  if (this.IsDoubleClickable(event)) {
    if (this._clickTimer && this._clickTimer.isRunning()) {
      var clickEvent = this._savedClickEvent;
      if (event.pageX == clickEvent.pageX && event.pageY == clickEvent.pageY) {
        this._savedClickCount++;
        // Same coords, this is a double click, so ignore second click event
        return;
      }
      else {
        // Different coords, so need to process first event
        this._clickTimer.stop();
        this._onClickTimerEnd();
      }
    }
    this._savedClickEvent = event;
    this._savedClickCount = 1;
    if (!this._clickTimer) {
      this._clickTimer = new dvt.Timer(this._context, 250, this._onClickTimerEnd, this, 1);
    }
    this._clickTimer.reset();
    this._clickTimer.start();
  }
  else {
    this._propagateEvent(dvt.MouseEvent.CLICK, event, this.OnClick);
  }
};

dvt.EventManager.prototype._onClickTimerEnd = function() {
  var clickEvent = this._savedClickEvent;
  this._savedClickEvent = null;
  this._savedClickCount = 0;
  if (clickEvent) {
    this._propagateEvent(dvt.MouseEvent.CLICK, clickEvent, this.OnClick);
  }
};


/**
 * Click event handler.
 * @param {dvt.MouseEvent} event The platform specific mouse event
 * @protected
 */
dvt.EventManager.prototype.OnClick = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  this.OnClickInternal(event);

  this.ProcessSelectionEventHelper(obj, event.ctrlKey);

  // Stop displaying keyboard focus after the user has clicked
  this._shouldDisplayKeyboardFocus = false;

  // Done if there is no object
  if (! obj)
  {
    return;
  }

  //  and  - update the keyboard focus on mouse click
  if (this.KeyboardHandler && obj.getNextNavigable)
  {
    var nextFocus = obj.getNextNavigable(event);
    this.setFocusObj(nextFocus);
  }

  // Popup Support for triggerType="click"
  var consumed = false;
  if (this._hasEventInfo(event)) {
    consumed = this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY);
  }

  if (!consumed) {
    var position = new dvt.Point(event.pageX, event.pageY);
    consumed = this.PopupHandler.processPopupHelper(obj, this._getShowPopupBehaviors(obj), [dvt.ShowPopupBehavior.TRIGGER_TYPE_ACTION, dvt.ShowPopupBehavior.TRIGGER_TYPE_CLICK], position, event);
    if (consumed) {
      this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
    }
  }

  // Client Behavior Support for triggerType="click"
  if (!consumed) {
    var clientBehaviors = this._getClientBehaviors(obj);
    if (clientBehaviors) {
      consumed = this.ClientBehaviorHandler.processClick(obj, clientBehaviors);
    }
  }

  // fire an Action event if logical obj is a command component
  if (! consumed && obj.isCommandComponent && obj.isCommandComponent()) {
    // Create the action event
    var event = dvt.EventFactory.newActionEvent('action', obj.getId());

    // add the component specific context
    dvt.EventManager._addContextInfo(obj, event);

    // fire the action event
    this._callback.call(this._callbackObj, event);
  }
};

dvt.EventManager.prototype.IsDoubleClickable = function(event) {
  var displayable = event.target;
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  while (displayable) {
    var logicalObject = this.GetLogicalObject(displayable, true);
    if (logicalObject) {
      if ((logicalObject.isDoubleClickable && logicalObject.isDoubleClickable()) || this.PopupHandler.hasPopup(obj, [dvt.ShowPopupBehavior.TRIGGER_TYPE_DBL_CLICK])) {
        return true;
      }
      if (!this.IsPropagationEnabled(dvt.MouseEvent.DBLCLICK, null, displayable)) {
        return false;
      }
    }
    displayable = displayable.getParent();
  }
  return false;
};


/**
 * Helper function to process selection events
 * @param {DvtLogicalObject} logicalObj The logical object to process selection on
 * @param {Boolean} isMultiSelect True if we are performing multi-select
 * @private
 */
dvt.EventManager.prototype.ProcessSelectionEventHelper = function(logicalObj, isMultiSelect)
{
  // Selection Support
  var selectionHandler = this.getSelectionHandler(logicalObj);
  if (selectionHandler) {
    var bSelectionChanged = selectionHandler.processClick(logicalObj, isMultiSelect);
    // If the selection has changed, fire an event
    if (bSelectionChanged)
      this.fireSelectionEvent(logicalObj);
  }
};

dvt.EventManager.prototype.PreOnDblClick = function(event) {
  // Check whether we've received 2 clicks before the double click event to prevent falsely triggering a double click
  // on a dvt.Displayable when the target of the first click was different.
  var isDblClickable = this.IsDoubleClickable(event);
  if (isDblClickable && this._savedClickCount === 2 || !isDblClickable)
    this._propagateEvent(dvt.MouseEvent.DBLCLICK, event, this.OnDblClick);
  this._savedClickCount = 0;
};


/**
 * Double click event handler.
 * @protected
 */
dvt.EventManager.prototype.OnDblClick = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  if (this._clickTimer && this._clickTimer.isRunning()) {
    this._clickTimer.stop();
    this._savedClickEvent = null;
  }
  else {
    if (dvt.Agent.isPlatformIE() && dvt.Agent.getVersion() < 11) {
      if (!obj) {
        return;
      }

      if ((!obj.isDoubleClickable || !obj.isDoubleClickable()) && !this.PopupHandler.hasPopup(obj, [dvt.ShowPopupBehavior.TRIGGER_TYPE_DBL_CLICK])) {
        // Need to turn this into a single click for IE which only sends out click,dblclick upon a double-click rather
        // than the click,click,dblclick sent out by other browsers
        this.OnClick(event);
        return;
      }
    }
  }
  this.OnDblClickInternal(event);
  // Done if there is no object
  if (!obj) {
    return;
  }
  // Popup Support for triggerType="dblclick"
  var consumed = false;
  if (this._hasEventInfo(event)) {
    consumed = this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY);
  }
  if (!consumed) {
    var position = new dvt.Point(event.pageX, event.pageY);
    consumed = this.PopupHandler.processPopupHelper(obj, this._getShowPopupBehaviors(obj), [dvt.ShowPopupBehavior.TRIGGER_TYPE_DBL_CLICK], position, event);
    if (consumed) {
      this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
    }
  }
};

dvt.EventManager.prototype.PreOnContextMenu = function(event) {
  this._propagateEvent('contextmenu', event, this.OnContextMenu);
};


/**
 * Context Menu event handler.
 * @protected
 */
dvt.EventManager.prototype.OnContextMenu = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));

  // set keyboard focus on the object we are firing the context menu on
  if (obj && obj.getNextNavigable)
    this.setFocus(obj);

  this._onContextMenuHelper(event, obj);
};


/**
 * Helper method that does the bulk of the context menu handling
 *
 * @param {dvt.MouseEvent} event
 * @param {Object} obj  The logical object on which the mouse event was fired
 */
dvt.EventManager.prototype._onContextMenuHelper = function(event, obj)
{
  this.OnContextMenuInternal(event);
  var popupLaunched = this._processActionPopup(this.GetCurrentTargetForEvent(event), new dvt.Point(event.pageX, event.pageY));
  if (popupLaunched)
    event.preventDefault();

  // Process selection only for selectable objects so that generating context menu on empty area doesn't deselect ()
  if (obj && obj.isSelectable && obj.isSelectable())
    this.ProcessSelectionEventHelper(obj, event.ctrlKey);

  // Context Menu Support
  if (this.ContextMenuHandler) {
    var menuType = this.GetContextMenuType(obj);
    this.ProcessContextMenuHandler(event, menuType);
  }
  else {
    // Popup Support for triggerType="contextMenu"
    this.ProcessContextMenuPopup(event, obj);
  }
};


/**
 * @protected
 * Process the Facet Context Menu Handler
 * @param {DvtEvent} event  Event that invokes context menu
 * @param {String} menuType  Menu type
 * @return {boolean} true if menu items are processed by the handler
 */
dvt.EventManager.prototype.ProcessContextMenuHandler = function(event, menuType) {
  var contextMenuEvent = this.ContextMenuHandler.show(event, menuType);
  if (contextMenuEvent) {
    // Hide the tooltip before displaying the menu
    this._context.getTooltipManager().hideTooltip();

    //: stop a mouseHover popup when a context menu is displayed
    this.PopupHandler.HidePopup(event);

    // Request the context menu be displayed
    this._callback.call(this._callbackObj, contextMenuEvent);
    return true;
  }
  return false;
};


/**
 * Process Popup of trigger type 'contextMenu'
 *
 * @param {dvt.MouseEvent} event  Mouse event
 * @param {Object} obj  The logical object on which the event was fired
 */
dvt.EventManager.prototype.ProcessContextMenuPopup = function(event, obj) {
  var consumed = false;
  if (this._hasEventInfo(event)) {
    consumed = this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY);
  }

  if (!consumed) {
    var behaviors = this._getShowPopupBehaviors(obj);
    if (behaviors) {
      var x, y;
      if (dvt.Agent.isTouchDevice()) {
        var touch = event.touch;
        x = touch.pageX;
        y = touch.pageY;
      } else {
        x = event.pageX;
        y = event.pageY;
      }
      var position = new dvt.Point(x, y);
      consumed = this.PopupHandler.processPopupHelper(obj, behaviors, [dvt.ShowPopupBehavior.TRIGGER_TYPE_CONTEXT_MENU], position, event);
    }

    if (consumed) {
      this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      event.preventDefault();
    }
  }
};


/**
 * Keypress down event handler.  Delegates to DvtComponentKeyboardHandlers
 * until event is consumed.
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} true if this event manager has consumed the event
 * @protected
 */
dvt.EventManager.prototype.OnKeyDown = function(event) 
{
  this._bKeyDown = true;
  var keyCode = event.keyCode;
  var eventConsumed = false;

  var i;
  var increment;

  // if no current event manager is set to receive keyboard focus,
  // start at one end of the array and pass event to each event manager until
  // one event manager consumes the event.  that will be the current event manager
  if (this._currentKeyboardHandlerIdx < 0 ||
      this._currentKeyboardHandlerIdx > this._keyboardHandlers.length)
  {
    // if we get a shift+tab, start from the back of the array
    if (keyCode == dvt.KeyboardEvent.TAB && event.shiftKey)
      i = this._keyboardHandlers.length - 1;
    else
      i = 0;
  }
  else
  {
    i = this._currentKeyboardHandlerIdx;
  }

  // if we get a shift+tab, start from the back of the array and move backward
  if (keyCode == dvt.KeyboardEvent.TAB && event.shiftKey)
    increment = -1;
  else
    increment = 1;

  for (i; (i >= 0 && i < this._keyboardHandlers.length && !eventConsumed); i = i + increment)
  {
    var handler = this._keyboardHandlers[i];
    if (handler === this)
      eventConsumed = this.ProcessKeyboardEvent(event);
    else
      eventConsumed = handler.handleKeyboardEvent(event);

    if (eventConsumed)
      this._currentKeyboardHandlerIdx = i;
  }

  // consume all arrow key events to prevent event being consumed by another component and losing focus
  if (!eventConsumed && (event.keyCode == dvt.KeyboardEvent.UP_ARROW ||
                         event.keyCode == dvt.KeyboardEvent.DOWN_ARROW ||
                         event.keyCode == dvt.KeyboardEvent.LEFT_ARROW ||
                         event.keyCode == dvt.KeyboardEvent.RIGHT_ARROW)) {
    dvt.EventManager.consumeEvent(event);
  }

  //reset current keyboard handler index as focus goes out of component
  if (!eventConsumed && keyCode == dvt.KeyboardEvent.TAB) {
    this._currentKeyboardHandlerIdx = -1;
  }
  return eventConsumed;
};


/**
 * @override
 */
dvt.EventManager.prototype.handleKeyboardEvent = function(event)
{
  return this.OnKeyDown(event);
};


/**
 * @override
 */
dvt.EventManager.prototype.hideKeyboardFocusEffect = function()
{
  var currentNavigable = this.getFocus();

  if (currentNavigable && currentNavigable.isShowingKeyboardFocusEffect())
  {
    currentNavigable.hideKeyboardFocusEffect();
  }
};


/**
 * Keypress down event handler.  Provides basic keyboard navigation and
 * triggering of context menus.
 * @param {dvt.KeyboardEvent} event
 * @return {Boolean} true if this event manager has consumed the event
 * @protected
 */
dvt.EventManager.prototype.ProcessKeyboardEvent = function(event) 
{
  if (!this.KeyboardHandler)
    return false;

  // clear tooltip if one is shown; tooltip can be shown if mouse is used to make a selection
  // and then we use the keyboard to navigate from the mouse-selected item
  this.hideTooltip();

  var currentNavigable = this.getFocus();
  var nextNavigable = null;

  // When tabbing into/out of a DVT component or subcomponent, we need to ensure focus effect is consistently shown/hidden
  if (event.keyCode == dvt.KeyboardEvent.TAB && currentNavigable) {
    if (currentNavigable.isShowingKeyboardFocusEffect()) {
      // Tabbing out of a component
      currentNavigable.hideKeyboardFocusEffect();
      this.ProcessRolloverEvent(event, currentNavigable, false);

      // try to navigate to the next/previous subcomponent
      var nextComponent;
      if (event.shiftKey)
        nextComponent = this._context.previousKeyboardFocus();
      else
        nextComponent = this._context.nextKeyboardFocus();

      if (nextComponent) {
        nextComponent.FireListener(event, false);
        dvt.EventManager.consumeEvent(event);
        return true;
      } else {
        return false; // handle the case where we tab out of a component. don't cancel the event and propagate it onwards
      }
    } else {
      // Tabbing into a component
      this.ShowFocusEffect(event, currentNavigable);
      this.ProcessRolloverEvent(event, currentNavigable, true);
      dvt.EventManager.consumeEvent(event);
      return true;
    }
  }

  if (currentNavigable && this.KeyboardHandler.isContextMenuEvent(event))
  {
    var contextMenuLocation;

    if (currentNavigable.getContextMenuLocation)
    {
      contextMenuLocation = currentNavigable.getContextMenuLocation();
    }
    else
    {
      var bounds = currentNavigable.getKeyboardBoundingBox();
      // adjust location for bidi; use top left corner for bidi, top right corner for non-bidi,
      if (dvt.Agent.isRightToLeft(this._context))
        contextMenuLocation = new dvt.Point(bounds.x, bounds.y);
      else
        contextMenuLocation = new dvt.Point(bounds.x + bounds.w, bounds.y);
    }

    var mouseEvent = dvt.DomEventFactory.generateMouseEventFromKeyboardEvent(event, this._context, dvt.MouseEvent.CLICK,
        this._context.getStage(),
        contextMenuLocation.x, contextMenuLocation.y);

    // OnContextMenu checks for ctrlKey to perform multi-select before showing context menu
    // However, the keystroke combination for showing the context menu is Ctrl+Alt+M
    // CLEAR the ctrlKey field so that multi-select isn't performed, and send OnContextMenu
    // a mouse event that is equivalent to right-clicking on the navigable with keyboard focus
    // With the mouse, a user could Ctrl+right click a navigbale to multi-select it and then bring up the
    // context menu.  In the keyboard case, the user would first have to multi-select and then bring up the
    // context menu, in two separate keystrokes
    mouseEvent.ctrlKey = false;
    this._onContextMenuHelper(mouseEvent, currentNavigable);
    return true;
  }

  nextNavigable = this.KeyboardHandler.processKeyDown(event);

  if (nextNavigable)
  {
    this.setFocus(nextNavigable);

    // the user has transferred focus via the keyboard, start showing keyboard focus effect
    this._shouldDisplayKeyboardFocus = true;
    if (currentNavigable) {
      currentNavigable.hideKeyboardFocusEffect();
      this.ProcessRolloverEvent(event, currentNavigable, false);
    }
    if (this.KeyboardHandler.isSelectionEvent(event))
      this.ProcessSelectionEventHelper(nextNavigable, event.shiftKey);
    else if (this.KeyboardHandler.isMultiSelectEvent(event))
      this.ProcessSelectionEventHelper(nextNavigable, event.ctrlKey);

    this.ShowFocusEffect(event, nextNavigable);
    this.ProcessRolloverEvent(event, nextNavigable, true);

    return true;
  }

  return false;
};

/**
 * Shows the keyboard focus effects wich includes tooltip, for a keyboard navigable object.
 * @param {dvt.KeyboardEvent} event The keyboard event
 * @param {DvtKeyboardNavigable} navigable The keyboard navigable to show focus effect for
 * @protected
 */
dvt.EventManager.prototype.ShowFocusEffect = function(event, navigable) {
  navigable.showKeyboardFocusEffect();
  var coords = navigable.getKeyboardTooltipLocation ? navigable.getKeyboardTooltipLocation() : navigable.getKeyboardBoundingBox(this.getCtx().getStage()).getCenter();
  var pageCoords = this.getCtx().stageToPageCoords(coords.x, coords.y);
  this.ProcessObjectTooltip(event, pageCoords.x, pageCoords.y, navigable, navigable.getTargetElem());
  this.UpdateActiveElement(navigable);
};

/**
 * Keypress up event handler.
 * @param {dvt.KeyboardEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnKeyUp = function(event) {
  this._bKeyDown = false;
  if (this._handleExternalKeyboardFocus === true && event.keyCode == dvt.KeyboardEvent.TAB) {
    this._handleExternalKeyboardFocus = false;
    //  - firing a fake keydown event on keyup to communicate the tab to the newly focused element
    this._callbackObj.dispatchDisplayableEvent(dvt.KeyboardEvent.KEYDOWN, event);
  }
  this.KeyboardHandler.processKeyUp(event, [dvt.ShowPopupBehavior.TRIGGER_TYPE_KEY_UP]);
};

/**
 * Keypress up event handler.
 * @param {dvt.KeyboardEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnKeyPress = function(event) {
  this.KeyboardHandler.processKeyUp(event, [dvt.ShowPopupBehavior.TRIGGER_TYPE_KEY_PRESS]);
};

dvt.EventManager.prototype.PreOnMouseMove = function(event) {
  this._propagateEvent(dvt.MouseEvent.MOUSEMOVE, event, this.OnMouseMove);
};


/**
 * Mouse Move event handler
 * @protected
 *
 * @param {dvt.MouseEvent} event  Mouse move event
 */
dvt.EventManager.prototype.OnMouseMove = function(event) {
  var pageX = event.pageX;
  var pageY = event.pageY;
  var relPos = this._context.pageToStageCoords(pageX, pageY);

  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragMove(relPos, event.ctrlKey);
    if (marqueeEvent)
      this._callback.call(this._callbackObj, marqueeEvent);
  }

  var target = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(target);

  // Return if no object is found
  if (!obj)
    return;

  this.ProcessObjectTooltip(event, pageX, pageY, obj, target);
  var position = new dvt.Point(pageX, pageY);
  // Notify the popup handler of the mouse move
  this.PopupHandler.processMouseMove(position);
  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    // Popup Support for triggerType="mouseMove"
    var logObjAndDisp = this.GetLogicalObjectAndDisplayable(target);
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_MOVE)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }

  // Drag and Drop Support
  if (this.DragSource && !event.dragSourceSet && this.IsDragCandidate(obj)) {
    this.DragSource.setDragCandidate(obj);
    event.dragSourceSet = true;
  }

};

dvt.EventManager.prototype.PreOnMouseOver = function(event) {
  this._propagateEvent(dvt.MouseEvent.MOUSEOVER, event, this.OnMouseOver);
  this._handlePreOverEvent(event);
};

dvt.EventManager.prototype._getDisplayableHierarchy = function(target, filterFunc, filterFuncObj) {
  var hierarchy = [];
  var currentTarget = target;
  while (currentTarget) {
    var bInclude = true;
    if (filterFunc) {
      bInclude = filterFunc.call(filterFuncObj, currentTarget);
    }
    if (bInclude) {
      hierarchy.unshift(currentTarget);
    }
    currentTarget = currentTarget.getParent();
  }
  return hierarchy;
};

dvt.EventManager.prototype._getRolloverHierarchy = function(target) {
  return this._getDisplayableHierarchy(target, this._isRolloverType, this);
};


dvt.EventManager.prototype._isRolloverType = function(target) {
  var logicalObject = this.GetLogicalObject(target, true);
  if (logicalObject) {
    for (var i = 0; i < this._rolloverTypes.length; i++) {
      if (logicalObject instanceof this._rolloverTypes[i]) {
        return true;
      }
    }
  }
  return false;
};

dvt.EventManager.prototype.addRolloverType = function(type) {
  this._rolloverTypes.push(type);
};

dvt.EventManager.prototype.removeRolloverType = function(type) {
  var index = dvt.ArrayUtils.getIndex(this._rolloverTypes, type);
  if (index != -1) {
    this._rolloverTypes.splice(index, 1);
  }
};

dvt.EventManager.prototype.OnRollOver = function(event) {

};


/**
 * Mouse Over event handler
 * @param {dvt.MouseEvent} event Mouse Over event
 * @protected
 */
dvt.EventManager.prototype.OnMouseOver = function(event) {
  var currTargetForEvent = this.GetCurrentTargetForEvent(event);
  var logObjAndDisp = this.GetLogicalObjectAndDisplayable(currTargetForEvent);
  var obj = null;
  if (logObjAndDisp) {
    obj = logObjAndDisp.logicalObject;
  }
  var position = new dvt.Point(event.pageX, event.pageY);

  // Return if no object is found
  if (!obj)
    return;

  // Selection Support
  var selectionHandler = this.getSelectionHandler(obj);
  if (selectionHandler)
    selectionHandler.processMouseOver(obj);

  // Category Rollover Support
  this.ProcessRolloverEvent(event, obj, true);

  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    // Popup Support for triggerType="over" or "hover"
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_OVER)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }

  // Accessibility Support
  this.UpdateActiveElement(obj, currTargetForEvent);
};

dvt.EventManager.prototype.PreOnMouseOut = function(event) {
  this._handlePreOutEvent(dvt.MouseEvent.MOUSEOUT, event, this.OnMouseOut);
};

dvt.EventManager.prototype.OnRollOut = function(event) {

};


/**
 * Mouse Out event handler
 * @param {dvt.MouseEvent} event Mouse Out event
 * @protected
 */
dvt.EventManager.prototype.OnMouseOut = function(event) {
  var target = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(target);

  // Return if no object is found
  if (!obj)
    return;

  var relatedObj = this.GetLogicalObject(event.relatedTarget);
  if (obj == relatedObj)
    return; // not a mouse out if they correspond to the same object

  // Selection Support
  var selectionHandler = this.getSelectionHandler(obj);
  if (selectionHandler)
    selectionHandler.processMouseOut(obj);

  // Category Rollover Support
  this.ProcessRolloverEvent(event, obj, false);

  // : If the mouse has moved off the component, hide the tooltip
  this.hideTooltip();

  // Clear drag source when moving out of component
  if (this.DragSource && !event.dragSourceSet) {
    this.DragSource.setDragCandidate(null);
    event.dragSourceSet = true;
  }
  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    var position = new dvt.Point(event.pageX, event.pageY);
    var logObjAndDisp = this.GetLogicalObjectAndDisplayable(target);
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_OUT)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }
};

dvt.EventManager.prototype.PreOnMouseDown = function(event) {
  this._propagateEvent(dvt.MouseEvent.MOUSEDOWN, event, this.OnMouseDown);
};


/**
 * Mouse Down event handler
 * @protected
 *
 * @param {dvt.MouseEvent} event  Mouse down event
 */
dvt.EventManager.prototype.OnMouseDown = function(event) {
  var isPopup = this.isInActionPopup();
  if (isPopup) {
    this.CustomTooltipManager.closeActionTooltip();
  }

  if (this._marqueeHandler) {
    var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
    var marqueeEvent = this._marqueeHandler.processDragStart(relPos, event.ctrlKey);
    if (marqueeEvent)
      this._callback.call(this._callbackObj, marqueeEvent);
  }

  // Drag and Drop Support
  var target = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(target);
  if (this.DragSource && !event.dragSourceSet && this.IsDragCandidate(obj)) {
    this.DragSource.setDragCandidate(obj);
    event.dragSourceSet = true;
  }
  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    var position = new dvt.Point(event.pageX, event.pageY);
    var logObjAndDisp = this.GetLogicalObjectAndDisplayable(target);
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_DOWN)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }
};

dvt.EventManager.prototype.PreOnMouseUp = function(event) {
  this._propagateEvent(dvt.MouseEvent.MOUSEUP, event, this.OnMouseUp);
};


/**
 * Mouse Up event handler
 * @protected
 *
 * @param {dvt.MouseEvent} event  Mouse Up event
 */
dvt.EventManager.prototype.OnMouseUp = function(event) {
  if (this._marqueeHandler) {
    var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
    var marqueeEvent = this._marqueeHandler.processDragEnd(relPos, event.ctrlKey);
    if (marqueeEvent)
      this._callback.call(this._callbackObj, marqueeEvent);
  }
  var target = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(target);
  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    var position = new dvt.Point(event.pageX, event.pageY);
    var logObjAndDisp = this.GetLogicalObjectAndDisplayable(target);
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_UP)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }
  // no default behavior, subclasses can override
};

/**
 * @private
 * Shows tooltips on touch
 * @param {dvt.ComponentTouchEvent} event  Component touch event
 */
dvt.EventManager.prototype._processTouchTooltip = function(event) {
  var tooltipInfoObj = this.TouchManager.getTooltipInfo();
  var touchIds = tooltipInfoObj['touchIds'];
  var tooltipTarget = tooltipInfoObj['tooltipTarget'];

  // If no hints and another event manager didn't already process the event for a tooltip, hide current tooltip
  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_TOOLTIP_DISPLAYED_KEY) && (touchIds.length == 0 || !tooltipTarget)) {
    this.hideTooltip();
    return;
  }

  var avgPos = this.TouchManager.calcAveragePosition(touchIds);
  var obj = this.GetLogicalObject(tooltipTarget);
  this.ProcessObjectTooltip(event, avgPos.x, avgPos.y, obj, null);
};

/**
 * Touch Start event handler
 * @param {dvt.TouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnTouchStartBubble = function(event) {
  this.PreEventBubble(event);

  if (event.isInitialTouch()) {
    this._popupJustClosed = false;
  }

  // Drag and Drop Support
  if (this.DragSource) {
    var obj = this.GetLogicalObject(event.target);
    if (!event.dragSourceSet && this.IsDragCandidate(obj)) {
      this.DragSource.setDragCandidate(obj);
      event.dragSourceSet = true;
    }
  }

  var isPopup = this.isInActionPopup();
  // Action popups block other types of interactions
  if (isPopup) {
    this.CustomTooltipManager.closeActionTooltip();
    this.TouchManager.resetTouchHold();
  }
  this.HandleImmediateTouchStartInternal(event);
  this.TouchManager.fireLogicalEvents(event);
  this.TouchManager.postEventBubble(event);

  // Handle touch actions
  if (this._isTouchResponseTouchStart()) {
    this._touchResponseHandled = true;
    this.TouchManager.processAssociatedTouchAttempt(event, dvt.EventManager.TOUCH_RESPONSE_TOUCH_START, this._saveTouchStart, this);
  } else {
    this._touchResponseHandled = false;
    this._processTouchTooltip(event);
  }
};


/**
 * Touch Move event handler
 * @param {dvt.TouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnTouchMoveBubble = function(event) {
  this.PreEventBubble(event);

  if (this.TouchManager) {
    this._prevActionClear = false;

    this.HandleImmediateTouchMoveInternal(event);
    this.TouchManager.fireLogicalEvents(event);
    this.TouchManager.postEventBubble(event);

    this._processTouchTooltip(event);
  }
};

/*
 * Timeout needed to put touch end after an attempt to touch & hold
 */
dvt.EventManager.prototype._handleTouchEndTimer = function() {
  for (var i = 0; i < this._touchEndTimer.length; i++) {
    var timerObj = this._touchEndTimer[i];
    timerObj['timer'].stop();
    var event = timerObj['event'];
    if (this.TouchManager) {
      this.HandleImmediateTouchEndInternal(event);
      this.TouchManager.fireLogicalEvents(event);
      this.TouchManager.postEventBubble(event);
    }
  }
  // Clear drag source on touch end timer
  if (this.DragSource && !event.dragSourceSet) {
    this.DragSource.setDragCandidate(null);
    event.dragSourceSet = true;
  }
  this._touchEndTimer = new Array();
};


/**
 * Touch End event handler
 * @param {dvt.TouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnTouchEndBubble = function(event) {
  this.PreEventBubble(event);
  var timer = new dvt.Timer(this._context, 0, this._handleTouchEndTimer, this, 1);
  if (!this._touchEndTimer)
    this._touchEndTimer = new Array();
  this._touchEndTimer.push({'event': event, 'timer': timer});
  timer.start();
};

dvt.EventManager.prototype.HandleImmediateTouchStartInternal = function(event) {
};

dvt.EventManager.prototype.HandleImmediateTouchMoveInternal = function(event) {
};

dvt.EventManager.prototype.HandleImmediateTouchEndInternal = function(event) {
};


/**
 * Touch hover start event handler
 * @private
 * @param {dvt.ComponentTouchEvent} event
 */
dvt.EventManager.prototype._preOnComponentTouchHoverStart = function(event) {
  this._propagateEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_START_TYPE, event, this.OnComponentTouchHoverStart);
};


/**
 * Touch hover start event handler. Subclasses can override.
 * @param {dvt.ComponentTouchEvent} event  Component touch event
 * @protected
 */
dvt.EventManager.prototype.OnComponentTouchHoverStart = function(event) {
  this.HandleTouchHoverStartInternal(event);

  // Handle touch actions if not already handled on touch start
  if (!this._touchResponseHandled) {
    this.HandleTouchActionsStart(event);
  }
};


/**
 * Touch hover move event handler
 * @private
 * @param {dvt.ComponentTouchEvent} event
 */
dvt.EventManager.prototype._preOnComponentTouchHoverMove = function(event) {
  this._propagateEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE, event, this.OnComponentTouchHoverMove);
};


/**
 * Touch hover move event handler. Subclasses can override.
 * @param {dvt.ComponentTouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnComponentTouchHoverMove = function(event) {
  this.HandleTouchHoverMoveInternal(event);

  if (!this._touchResponseHandled) {
    this.HandleTouchActionsMove(event);
  }
};


/**
 * Touch hover end event handler
 * @private
 * @param {dvt.ComponentTouchEvent} event
 */
dvt.EventManager.prototype._preOnComponentTouchHoverEnd = function(event) {
  this._propagateEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_END_TYPE, event, this.OnComponentTouchHoverEnd);
};


/**
 * Touch hover end event handler. Subclasses can override.
 * @param {dvt.ComponentTouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnComponentTouchHoverEnd = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(targetObj);

  this.HandleTouchHoverEndInternal(event);

  this.ProcessTouchContextMenu(event, obj);

  // Fire an event notifying callback object that touch hold release happened. Used by JET for context menus.
  if (this._callbackObj instanceof dvt.BaseComponent) {
    var stageCoord = this.getCtx().getStageAbsolutePosition();
    var x = event.touch.pageX;
    var y = event.touch.pageY;
    if (x <= stageCoord.x + this._callbackObj.getWidth() && x >= stageCoord.x && y <= stageCoord.y + this._callbackObj.getHeight() && y >= stageCoord.y)
      this._callback.call(this._callbackObj, dvt.EventFactory.newTouchHoldReleaseEvent(event.getNativeEvent()));
  }

  if (!this._touchResponseHandled) {
    this.HandleTouchActionsEnd(event);
  }
};


/**
 * Touch hover out event handler
 * @private
 * @param {dvt.ComponentTouchEvent} event
 */
dvt.EventManager.prototype._preOnComponentTouchHoverOut = function(event) {
  this._handlePreOutEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, event, this.OnComponentTouchHoverOut);
};


/**
 * Touch hover out event handler. Subclasses can override.
 * @param {dvt.ComponentTouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnComponentTouchHoverOut = function(event) {
  this.HandleTouchHoverOutInternal(event);

  if (!this._touchResponseHandled) {
    this.HandleTouchActionsOut(event);
  }
};


/**
 * Touch hover over event handler
 * @private
 * @param {dvt.ComponentTouchEvent} event
 */
dvt.EventManager.prototype._preOnComponentTouchHoverOver = function(event) {
  this._propagateEvent(dvt.ComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, event, this.OnComponentTouchHoverOver);
  this._handlePreOverEvent(event);
};


/**
 * Touch hover over event handler. Subclasses can override.
 * @param {dvt.ComponentTouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnComponentTouchHoverOver = function(event) {
  this.HandleTouchHoverOverInternal(event);

  if (!this._touchResponseHandled) {
    this.HandleTouchActionsOver(event);
  }
};


/**
 * Touch double click event handler.
 * @private
 * @param {dvt.ComponentTouchEvent} event
 */
dvt.EventManager.prototype._preOnComponentTouchDblClick = function(event) {
  this._propagateEvent(dvt.ComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE, event, this.OnComponentTouchDblClick);
};


/**
 * Touch double click event handler. Subclasses must override.
 * @param {dvt.ComponentTouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.OnComponentTouchDblClick = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var touch = event.touch;
  var dlo = this.GetLogicalObject(targetObj);
  var position = new dvt.Point(touch.pageX, touch.pageY);
  // Popup Support for triggerType="dblclick"
  var consumed = false;
  if (this._hasEventInfo(event)) {
    consumed = this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY);
  }
  if (!consumed) {
    if (this.PopupHandler.processPopupHelper(dlo, this._getShowPopupBehaviors(dlo), [dvt.ShowPopupBehavior.TRIGGER_TYPE_DBL_CLICK], position, event)) {
      this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
    }
  }
  this.HandleTouchDblClickInternal(event);
};


/**
 * Touch click event handler
 * @private
 * @param {dvt.ComponentTouchEvent} event
 */
dvt.EventManager.prototype._preOnComponentTouchClick = function(event) {
  this._propagateEvent(dvt.ComponentTouchEvent.TOUCH_CLICK_TYPE, event, this.OnComponentTouchClick);
};


/**
 * Touch click event handler. Subclasses can override.
 * @param {dvt.ComponentTouchEvent} event Component Touch event
 * @protected
 */
dvt.EventManager.prototype.OnComponentTouchClick = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var touch = event.touch;
  var dlo = this.GetLogicalObject(targetObj);
  var position = new dvt.Point(touch.pageX, touch.pageY);
  // Popup Support for triggerType="click"
  var consumed = false;
  if (this._hasEventInfo(event)) {
    consumed = this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY);
  }

  if (!consumed) {
    if (this.PopupHandler.processPopupHelper(dlo, this._getShowPopupBehaviors(dlo), [dvt.ShowPopupBehavior.TRIGGER_TYPE_ACTION, dvt.ShowPopupBehavior.TRIGGER_TYPE_CLICK]
        , position, event)) {
      this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      consumed = true;
    }
  }

  if (!consumed) {
    var clientBehaviors = this._getClientBehaviors(dlo);
    if (clientBehaviors) {
      this.ProcessClientBehaviorForTouch(dlo, clientBehaviors);
    }
  }

  var done = this.HandleTouchClickInternal(event);
  if (done)
    return;


  // When touchResponse is touchStart, selection is handled on touchend listener.
  if (!this._isTouchResponseTouchStart())
    this._processTouchSelection(dlo);
  // Prevent selection clearing if popup has just closed
  if (!this._popupJustClosed)
    this._processTouchSelectionClear(dlo);

  if (this.CustomTooltipManager.displayActionPopup()) {
    this.UpdateActionTooltipLaunchedFeedback(targetObj, new dvt.Point(touch.pageX, touch.pageY));
    this.CustomTooltipManager.startActionPopupAtPosition(touch.pageX, touch.pageY, targetObj);
  }

  // fire an Action event if logical obj is a command component
  if (dlo && !consumed && dlo.isCommandComponent && dlo.isCommandComponent()) {
    // Create the action event
    var event = dvt.EventFactory.newActionEvent('action', dlo.getId());

    // add the component specific context
    dvt.EventManager._addContextInfo(dlo, event);

    // fire the action event
    this._callback.call(this._callbackObj, event);
  }

};

/**
 * @param {dvt.Obj} dlo The logical object to process selection on
 * @private
 */
dvt.EventManager.prototype._processTouchSelection = function(dlo) {
  var bSelectionChanged = false;
  var selectionHandler = this.getSelectionHandler(dlo);
  if (selectionHandler && dlo && dlo.isSelectable && dlo.isSelectable()) {
    // Process click immediately
    bSelectionChanged = selectionHandler.processClick(dlo, true);
    // If the selection has changed, fire an event
    if (bSelectionChanged)
      this.fireSelectionEvent(dlo);
  }
  this._prevActionClear = false;
};


/**
 * @param {dvt.Obj} dlo The logical object to process selection clear on
 * @private
 */
dvt.EventManager.prototype._processTouchSelectionClear = function(dlo) {
  var bSelectionChanged = false;
  var selectionHandler = this.getSelectionHandler(dlo);
  if (selectionHandler && (!dlo || !dlo.isSelectable || !dlo.isSelectable())) {
    if (!this._prevActionClear) {
      // Don't ask for clear selection if popup just closed
      var showClearDialog = false;
      // There are two different policies for the clear selection dialog
      // 1) If a tap, show clear selection only for multiple selection when more than 1 is selected
      // 2) If a touch and hold + release, don't attempt a clear or perform a  clear
      if (this.isClearMenuAllowed()) {
        var selType = selectionHandler.getType();
        if (selType == dvt.SelectionHandler.TYPE_MULTIPLE) {
          if (selectionHandler.getSelectedCount() > 1) {
            showClearDialog = true;
          }
        }
      }
      if (showClearDialog) {
        this.addClearAllActionItem();
      } else {
        bSelectionChanged = selectionHandler.processClick(null, false);
        // If the selection has changed, fire an event
        if (bSelectionChanged)
          this.fireSelectionEvent(dlo);
      }
    }
  }
};

dvt.EventManager.prototype.OnActionTooltipClosed = function(event) {
  var targetObj = event.target;

  this._popupJustClosed = true;
  this._isInActionPopup = false;
  var actionPopup = this.CustomTooltipManager.getActionTooltip();

  if (actionPopup.containsMenuId(dvt.EventManager.CLEAR_SELECTION_ACTION_TYPE)) {
    this._prevActionClear = true;
  }
  this.CustomTooltipManager.clearActionTooltip();

  // end start
  this.UpdateActionTooltipClosedFeedback(targetObj);
};

dvt.EventManager.prototype.OnActionTooltipStarted = function(event) {
  this._isInActionPopup = true;
};

//*******************************************************************************//
//************************* End Event Listeners *********************************//
//*******************************************************************************//


dvt.EventManager.prototype._getTooltipInfo = function(target, obj, x, y) {
  var text = null;
  var isDatatip = false;
  if (obj && obj.getDatatip) {
    text = obj.getDatatip(target, x, y);
    if (text)
      isDatatip = true;
  }

  if (!text && obj && obj.getTooltip) {
    text = obj.getTooltip(target, x, y);

  }
  return {'text' : text, 'isDatatip': isDatatip};
};

/**
 * @private
 * Process show tooltip for the mousemove or touch event
 * @param {object} target target object
 * @param {object} obj  logical object
 * @param {number} pageX  event x-coordinate
 * @param {number} pageY  event y-coordinate
 * @return {boolean}  true if tooltip is shown
 */
dvt.EventManager.prototype._processShowTooltip = function(target, obj, pageX, pageY) {
  if (this.getTooltipsEnabled(obj)) {
    var relPos = this._context.pageToStageCoords(pageX, pageY);
    var x = relPos.x;
    var y = relPos.y;

    var tooltipInfo = this._getTooltipInfo(target, obj, x, y);
    var isDatatip = tooltipInfo['isDatatip'];
    var text = tooltipInfo['text'];
    if (text) {
      this.CustomTooltipManager.clearActionTooltip();
      var borderColor = this.GetTooltipColor(obj, x, y);

      var ttm = this._context.getTooltipManager();
      if (isDatatip) {
        ttm.showDatatip(pageX, pageY, text, borderColor);
      } else {
        ttm.showTooltip(pageX, pageY, text, null, true, borderColor);
      }

      this.TooltipLaunched(text, borderColor);
      return true;
    } else {
      this.hideTooltip();
    }
  } else {
    this.hideTooltip();
  }
  return false;
};

dvt.EventManager.prototype.hideTooltip = function() {
  var tooltipManager = this._context.getTooltipManager();
  if (tooltipManager)
    tooltipManager.hideTooltip();

  this.TooltipHidden();
};


/**
 * Process Context Menu for touch devices
 *
 * @param {dvt.MouseEvent} event  Touch event
 * @param {Object} dlo  The logical object on which the touch event was fired
 * @return {boolean} true if menu is displayed on touch
 */
dvt.EventManager.prototype.ProcessTouchContextMenu = function(event, dlo) {

  if (!this.ContextMenuHandler) {
    //If Context Menu Handler is not defined, look for Context Menu popup
    this.ProcessContextMenuPopup(event, dlo);
    return;
  }
  var menuType = this.GetContextMenuType(dlo);

  var allowContextMenu = false;
  if (dlo && dlo.isSelected && dlo.isSelected()) {
    allowContextMenu = true;
  } else {
    if (!dlo || !dlo.isSelectable || !dlo.isSelectable()) {
      menuType = dvt.ContextMenuHandler.TYPE_BODY_CONTEXT_MENU;
    }
    if (menuType == dvt.ContextMenuHandler.TYPE_BODY_CONTEXT_MENU) {
      allowContextMenu = true;
    }
  }
  if (allowContextMenu) {
    // On touch device, server context menu renders the desktop context menu
    return this.ProcessContextMenuHandler(event, menuType);
  }
  return false;
};

dvt.EventManager.prototype._processActionPopup = function(targetObj, position) {
  // Only if action tooltip shown
  if (this.CustomTooltipManager.displayActionPopup()) {
    this.SetupTouchTooltip(targetObj);
    this.UpdateActionPopupShownFeedback(targetObj);
    this.CustomTooltipManager.startActionPopupAtPosition(position.x, position.y, targetObj);
    return true;
  } else {
    this.UpdateActionPopupHiddenFeedback(targetObj);
    return false;
  }
};
/*
 * General  hooks
 */

dvt.EventManager.prototype.TooltipLaunched = function(tooltip, borderColor) {
};

dvt.EventManager.prototype.TooltipHidden = function() {
};

dvt.EventManager.prototype.SetupTouchTooltip = function(targetObj)
{
  var obj = this.GetLogicalObject(targetObj);
  var actionTooltip = this.CustomTooltipManager.getActionTooltip();
  var tooltipBorderColor = actionTooltip.getTooltipBorderColor();
  // If border color wasn't overridden, get it here
  if (tooltipBorderColor == null) {
    var borderColor = this.GetTooltipColor(obj);
    actionTooltip.setTooltipBorderColor(borderColor);
  }
};

/*
 * Mouse-related hooks
 */
dvt.EventManager.prototype.OnContextMenuInternal = function(event) {
};

/**
 * Click function for subclasses to overwrite
 * @param {dvt.MouseEvent} event The platform specific mouse event
 * @protected
 */
dvt.EventManager.prototype.OnClickInternal = function(event) {
};
/**
 *  Double Click function for subclasses to overwrite
 * @param {dvt.MouseEvent} event The platform specific mouse event
 * @protected
 */
dvt.EventManager.prototype.OnDblClickInternal = function(event) {
};

/*
 * Touch-related hooks
 */
dvt.EventManager.prototype.HandleTouchHoverStartInternal = function(event) {
};

dvt.EventManager.prototype.HandleTouchHoverMoveInternal = function(event) {
};

dvt.EventManager.prototype.HandleTouchHoverEndInternal = function(event) {
};

dvt.EventManager.prototype.HandleTouchHoverOverInternal = function(event) {
};

dvt.EventManager.prototype.HandleTouchHoverOutInternal = function(event) {
};

/**
 * Internal Touch click event handler. Subclasses can override.
 * @param {dvt.ComponentTouchEvent} event Component Touch event
 * @return {boolean} true if done handling touch click
 * @protected
 */
dvt.EventManager.prototype.HandleTouchClickInternal = function(event) {
  return false;
};
/**
 * Internal Double Touch click event handler. Subclasses can override.
 * @param {dvt.ComponentTouchEvent} event Component Touch event
 * @protected
 */
dvt.EventManager.prototype.HandleTouchDblClickInternal = function(event) {
};

// Action popup shown for the given target object
dvt.EventManager.prototype.UpdateActionPopupShownFeedback = function(targetObj) {
};

// Action popup hidden for the given target object
dvt.EventManager.prototype.UpdateActionPopupHiddenFeedback = function(targetObj) {
};

dvt.EventManager.prototype.UpdateActionTooltipClosedFeedback = function(targetObj) {
};

dvt.EventManager.prototype.UpdateActionTooltipLaunchedFeedback = function(targetObj, position) {
};

dvt.EventManager.prototype.isInActionPopup = function()
{
  return this._isInActionPopup;
};

/**
 * Returns a localized "Clear Selection" text.
 * @return {string}
 */
dvt.EventManager.prototype.GetClearSelectionText = function() {
  return dvt.Bundle.getTranslatedString(dvt.Bundle.UTIL_PREFIX, 'CLEAR_SELECTION');
};

// Add a clear selection popup menu item
dvt.EventManager.prototype.addClearAllActionItem = function() {
  this.addActionTooltipMenuItem(dvt.EventManager.CLEAR_SELECTION_ACTION_TYPE, this.GetClearSelectionText(), this._actionTooltipClearListener, this);
  var actionTooltip = this.CustomTooltipManager.getActionTooltip();
  // Override color to always be gray
  if (actionTooltip)
    actionTooltip.setTooltipBorderColor(DvtCustomTooltip.DEFAULT_BORDER_COLOR);
};

dvt.EventManager.prototype.isClearMenuAllowed = function()
{
  return true;
};

// Add a menu item to the action tooltip
dvt.EventManager.prototype.addActionTooltipMenuItem = function(id, text, listener, obj)
{
  var actionTooltip = this.CustomTooltipManager.getActionTooltip();
  actionTooltip.addMenuItem(new DvtCustomTooltipItem(this._context, id, text, listener, obj));
};

/*
 * Touch-related listeners
 */
// Performed after tapping a context menu item
dvt.EventManager.prototype.ContextMenuItemListener = function(evt) {
  var menuItem = evt.menuItem;
  var contextMenuEvent = menuItem.getEvent();
  this._callback.call(this._callbackObj, contextMenuEvent);
};

// Performed after tapping the clear selection option in an action popup
dvt.EventManager.prototype._actionTooltipClearListener = function(evt) {
  var targetObj = evt.target;
  var dlo = this.GetLogicalObject(targetObj);
  var bSelectionChanged = this.getSelectionHandler(dlo).processClick(null, false);
  // If the selection has changed, fire an event
  if (bSelectionChanged)
    this.fireSelectionEvent(dlo);
};

// Performed after tapping the select option in an action popup
dvt.EventManager.prototype._actionTooltipSelectListener = function(evt) {
  var targetObj = evt.target;
  var dlo = this.GetLogicalObject(targetObj);
  // Always control click for touch
  var bSelectionChanged = this.getSelectionHandler(dlo).processClick(dlo, true);

  // If the selection has changed, fire an event
  if (bSelectionChanged)
    this.fireSelectionEvent(dlo);
};

/**
 * Consumes an event by calling preventDefault() and stopPropagation() on the event to prevent default browser
 * behavior and prevent other listeners from receiving this event which we always want to do for keyboard events.
 * @param {dvt.BaseEvent} event The event to consume
 */
dvt.EventManager.consumeEvent = function(event) {
  if (event) {
    event.preventDefault();
    //: stop event propagation when the event is consumed
    event.stopPropagation();
  }
};


// add the component specific context to this event, such as the clientRowKey.
dvt.EventManager._addContextInfo = function(target, event) {
  // diagram
  if (target.getContextCallback && target.getContextCallbackObj) {
    var ccb = target.getContextCallback();
    var ccbo = target.getContextCallbackObj();
    if (ccb && ccbo) {
      ccb.call(ccbo, event);
    }
  }
  // graph
  else {
    // store clientRowKey
    event[dvt.BaseComponentEvent.CLIENT_ROW_KEY] = target.getId();
  }
};

dvt.EventManager.prototype.IsPropagationEnabled = function(eventType, event, displayable) {
  return false;
};

/**
 * Get current target of the event
 * @param {dvt.MouseEvent} event  Mouse Event
 * @return {object} event target
 */
dvt.EventManager.prototype.GetCurrentTargetForEvent = function(event) {
  var currentTarget = this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY);
  return currentTarget ? currentTarget : event.target;
};

/**
 * @private
 * Propagate event
 * @param {String} eventType  event type
 * @param {dvt.MouseEvent} event  Mouse Event
 * @param {function} handler  function handler of the event
 */
dvt.EventManager.prototype._propagateEvent = function(eventType, event, handler) {
  var obj = this.GetLogicalObject(event.target);
  if (!obj) {
    // No logical objects anywhere in the hierarchy, call handler directly
    handler.call(this, event);
  }
  else {
    var displayable = event.target;
    try {
      while (displayable) {
        var logicalObject = this.GetLogicalObject(displayable, true);
        if (logicalObject) {
          this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY, displayable);
          handler.call(this, event);
          if (!this.IsPropagationEnabled(eventType, event, displayable)) {
            return;
          }
        }
        displayable = displayable.getParent();
      }
    }
    finally {
      this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY, null);
    }
  }
};

dvt.EventManager.prototype.ConsumesClick = function(logicalObject) {
  return (logicalObject.isSelectable && logicalObject.isSelectable()) ||
         (logicalObject.isClickEventPropagationStopped && logicalObject.isClickEventPropagationStopped()) ||
         this._hasClickPopup(logicalObject) || this._hasClickClientBehavior(logicalObject);
};
/**
 * @private
 * Returns whether an object has a click popup
 * @param {object} logicalObject The logical target object looked at
 * @return {booelan} true of logicalObject has click popup
 */
dvt.EventManager.prototype._hasClickPopup = function(logicalObject) {
  return this.PopupHandler.hasPopup(logicalObject, [dvt.ShowPopupBehavior.TRIGGER_TYPE_ACTION, dvt.ShowPopupBehavior.TRIGGER_TYPE_CLICK]);
};


/**
 * Adds a DvtComponentKeyboardHandler to process keyboard events initially
 * received by this event manager.  Handlers are stored in tab index order and
 * a keyboard event will be passed from one handler to the next until some
 * handler (which might be this event manager itself) consumes the event or
 * all handlers after or before the current handler in the list have
 * had a chance to process the keyboard event.
 *
 * @param {DvtComponentKeyboardHandler} handler
 */
dvt.EventManager.prototype.addComponentKeyboardHandler = function(handler)
{
  if (handler) {
    this._keyboardHandlers.push(handler);
  }
};


/**
 * Adds a DvtComponentKeyboardHandler to process keyboard events initially
 * received by this event manager.  Handlers are stored in tab index order and
 * a keyboard event will be passed from one handler to the next until some
 * handler (which might be this event manager itself) consumes the event or
 * all handlers after or before the current handler in the list have
 * had a chance to process the keyboard event.
 *
 * @param {DvtComponentKeyboardHandler} handler
 * @param {Number} index The tab index at which to add this handler
 *
 */
dvt.EventManager.prototype.addComponentKeyboardHandlerAt = function(handler, index)
{
  // Return immediately if the current index doesn't exist
  if (index > this._keyboardHandlers.length)
    return;
  if (handler) {
    this._keyboardHandlers.splice(index, 0, handler);
    // maintain the pointer to the current keyboard handler
    if (index <= this._currentKeyboardHandlerIdx)
      this._currentKeyboardHandlerIdx++;
  }
};


/**
 * Removes the given DvtComponentKeyboardHandler
 *
 * @param {DvtComponentKeyboardHandler} handler
 *
 */
dvt.EventManager.prototype.removeComponentKeyboardHandler = function(handler)
{
  if (handler) {
    var i = this._findHandler(handler);
    if (i > -1)
    {
      // if the handler to be removed is the current one and it's the
      // first handler on the list, then let the reference to the current handler point
      // to the first element in the handler list after the current handler is removed
      if (this._currentKeyboardHandlerIdx == i && i == 0)
        this._currentKeyboardHandlerIdx = 0;

      // maintain the pointer to the current keyboard handler
      else if (i <= this._currentKeyboardHandlerIdx)
        this._currentKeyboardHandlerIdx--;

      this._keyboardHandlers.splice(i, 1);
    }
  }
};


/**
  * Returns index of specified DvtComponentKeyboardHandler in the internal list,
  * or -1 if not found.
  * @param {DvtComponentKeyboardHandler} handler
  * @return {Number}
  * @private
  */
dvt.EventManager.prototype._findHandler = function(handler)
{
  var idx = -1;
  var length = this._keyboardHandlers.length;

  for (var i = 0; i < length; i++)
  {
    if (this._keyboardHandlers[i] === handler)
      idx = i;
  }

  return idx;
};


/**
 * Updates the pointer to the current keyboard handler
 * @param {DvtComponentKeyboardHandler} handler
 */
dvt.EventManager.prototype.setCurrentKeyboardHandler = function(handler)
{
  var idx = this._findHandler(handler);

  if (idx >= 0)
    this._currentKeyboardHandlerIdx = idx;
};

dvt.EventManager.prototype._hasClickClientBehavior = function(logicalObject) {
  var behaviors = this._getClientBehaviors(logicalObject);
  if (behaviors) {
    for (var i = 0; i < behaviors.length; i++) {
      var behavior = behaviors[i];
      if (behavior && (behavior.getTriggerType() == dvt.ClientBehavior.TRIGGER_TYPE_ACTION ||
                       behavior.getTriggerType() == dvt.ClientBehavior.TRIGGER_TYPE_CLICK)) {
        return true;
      }
    }
  }
  return false;
};

dvt.EventManager.prototype.CreateClientBehaviorHandler = function(context, callback, callbackObj) {
  return new dvt.ClientBehaviorHandler(context, callback, callbackObj);
};


/**
 * Processes the client behavior event for touch device
 *
 * @protected
 * @param {object} obj The target of event.
 * @param {array} clientBehaviors The array of applicable client behaviors.
 * @return {boolean} true if a client behavior was triggered, false otherwise
 */
dvt.EventManager.prototype.ProcessClientBehaviorForTouch = function(obj, clientBehaviors) {
  return this.ClientBehaviorHandler.processClick(obj, clientBehaviors);
};

dvt.EventManager.prototype.IsDragCandidate = function(obj) {
  // subclasses should override
  return true;
};


/**
 * Generates a random ARIA active element ID
 * @return {String}
 * @private
 */
dvt.EventManager._getActiveElementId = function() {
  var ariaIdPrefix = '_dvtActiveElement';
  return ariaIdPrefix + Math.floor(Math.random() * 1000000000);//@RandomNumberOk
};


/**
 * Fires an active element change event in order to add aria-activedescendant attribute to the outer div.
 * This is needed by accessibility client in order to determine active SVG element
 * @param {object} obj The logical object corresponding to the targeted displayable.
 * @param {dvt.Displayable} displayable The displayable being targeted.
 * @protected
 */
dvt.EventManager.prototype.UpdateActiveElement = function(obj, displayable) {
  // Find the displayable if needed
  if (!displayable) {
    if (obj.getDisplayable)
      displayable = obj.getDisplayable();
    else if (obj.getDisplayables)
      displayable = obj.getDisplayables()[0];
    else
      displayable = obj;
  }

  // Don't continue if the displayable is not a valid displayable
  if (!(displayable instanceof dvt.Displayable))
    return;

  // Find the displayable with the ARIA tags, by traversing ancestors if needed.  If the logical object has a deferred
  // aria-label, then it doesn't matter which displayable is used.
  if (obj.getAriaLabel) {
    var ariaLabel = obj.getAriaLabel();
    if (ariaLabel) {
      displayable.setAriaProperty('label', ariaLabel);
    }
  }
  else {
    while (!displayable.getAriaRole() && displayable.getParent()) {
      displayable = displayable.getParent();
    }
  }

  // Return if this displayable is the stage, since it should never be the active element
  if (displayable == this.getCtx().getStage())
    return;

  // Set the new active element
  this.getCtx().setActiveElement(displayable);
};

/**
 * @private
 * Handle pre-mouseover event
 * @param {dvt.MouseEvent} event  Mouse Event
 */
dvt.EventManager.prototype._handlePreOverEvent = function(event) {
  var enteredHierarchy = this._getRolloverHierarchy(event.target);
  var exitedHierarchy = this._getRolloverHierarchy(event.relatedTarget);
  if (enteredHierarchy.length > 0) {
    var enteredObject = enteredHierarchy[enteredHierarchy.length - 1];
    var exitedObject = exitedHierarchy.length == 0 ? null : exitedHierarchy[exitedHierarchy.length - 1];
    if (enteredObject != exitedObject) {
      try {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY, enteredObject);
        this.OnRollOver(event);
      }
      finally {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY, null);
      }
    }
  }
};

/**
 * @private
 * Handle pre-mouseout event
 * @param {String} eventType  Event type
 * @param {dvt.MouseEvent} event  Mouse Event
 * @param {function} handler  Function handler for the event
 */
dvt.EventManager.prototype._handlePreOutEvent = function(eventType, event, handler) {
  var enteredLogicalObject = this.GetLogicalObject(event.relatedTarget);
  var displayable = event.target;
  try {
    // rollout
    var exitedHierarchy = this._getRolloverHierarchy(event.target);
    var enteredHierarchy = this._getRolloverHierarchy(event.relatedTarget);
    if (exitedHierarchy.length > 0) {
      var exitedObject = exitedHierarchy[exitedHierarchy.length - 1];
      var enteredObject = enteredHierarchy.length == 0 ? null : enteredHierarchy[enteredHierarchy.length - 1];
      if (exitedObject != enteredObject) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY, exitedObject);
        this.OnRollOut(event);
      }
    }

    var obj = this.GetLogicalObject(displayable);
    if (!obj) {
      // No logical objects anywhere in the hierarchy, call handler directly
      handler.call(this, event);
    }
    else {
      // mouseout

      //: pass the hierarchy of DvtDisplayables for the relatedTarget to the popup
      //handler so that it can determine whether it needs to dismiss a mousehover popup
      //(NOTE: do this in PreOnMouseOut so that it only happens once, instead of in OnMouseOut,
      //which gets called multiple times in the loop below)

      // Popup Support for triggerType="hover"
      this.PopupHandler.processMouseOut(obj, this._getDisplayableHierarchy(event.relatedTarget), event);

      while (displayable) {
        var logicalObject = this.GetLogicalObject(displayable, true);
        if (logicalObject) {
          if (enteredLogicalObject === logicalObject) {
            // Do not mouse out of the new displayable (or its parents)
            break;
          }
          this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY, displayable);
          handler.call(this, event);
          if (!this.IsPropagationEnabled(eventType, event, displayable)) {
            break;
          }
        }
        displayable = displayable.getParent();
      }
    }
  }
  finally {
    this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_CURRENT_TARGET_KEY, null);

    // Clear the cached stage position on mouse out.  The cache makes it significantly cheaper to access the stage
    // position, but it must only be used when the DOM position of the component is not changing.  We make this
    // assumption whenever the user is directly interacting with the component (via mouse or touch).
    if (!(event.relatedTarget instanceof dvt.Displayable))
      this._context.clearStageAbsolutePosition();
  }
};


/**
 * Gets a touch manager object
 * @return {dvt.TouchManager} touch manager object
 */
dvt.EventManager.prototype.getTouchManager = function() {
  return this.TouchManager;
};


/**
 * Ends a drag without specifying the final mouse/touch coordinate.
 * Used to end touch drag and to end a drag that happens outside the component area (called by AdfDhtmlDvtToolkitPeer).
 * @return {dvt.BaseComponentEvent} An event, if fired.
 */
dvt.EventManager.prototype.endDrag = function() {
  return null; // subclasses should override
};

/**
 * @private
 * Check if the event has information
 * @param {DvtEvent} event  Dvt Event object
 * @return {boolean}  true if the event has information
 */
dvt.EventManager.prototype._hasEventInfo = function(event) {
  if (event == null)
    return false;

  var nativeEvt = event.getNativeEvent();
  if (nativeEvt._eventInfo)
    return true;

  return false;
};

/**
 * @protected
 * Get event information for the passed key
 * @param {DvtEvent} event  Dvt Event object
 * @param {string} key  event info key
 * @return {object}  event info value
 */
dvt.EventManager.prototype.GetEventInfo = function(event, key) {
  if (!this._hasEventInfo(event) || key == null)
    return null;

  //get the value from event info
  var eventInfo;
  if (!this.StoreInfoByEventType(key)) {
    eventInfo = event.getNativeEvent()._eventInfo;
  } else {
    var type = event.type ? event.type : event.getType();
    eventInfo = event.getNativeEvent()._eventInfo[type];
  }
  return eventInfo ? eventInfo[key] : null;
};

/**
 * @protected
 * Set event information
 * @param {DvtEvent} event  Dvt Event object
 * @param {string} key  event info key
 * @param {object} value  event info value
 */
dvt.EventManager.prototype.SetEventInfo = function(event, key, value) {
  if (event == null || key == null)
    return;

  var nativeEvt = event.getNativeEvent();
  if (!nativeEvt._eventInfo)
    nativeEvt._eventInfo = {};

  if (!this.StoreInfoByEventType(key)) {
    nativeEvt._eventInfo[key] = value;
  } else {
    var typeName = event.type ? event.type : event.getType();
    if (!nativeEvt._eventInfo[typeName])
      nativeEvt._eventInfo[typeName] = {};
    //set the value in event info
    nativeEvt._eventInfo[typeName][key] = value;
  }
};

/**
 * @protected
 * Checks if the event info should be stored on native event using event type
 * @param {string} key  event info key
 * @return {boolean} true to use event type in addition to the key to store event info
 */
dvt.EventManager.prototype.StoreInfoByEventType = function(key) {
  if (key == dvt.EventManager._EVENT_INFO_TOOLTIP_DISPLAYED_KEY) {
    return false;
  }
  return true;
};


/**
 * Process object tooltip
 * @param {dvt.MouseEvent|dvt.KeyboardEvent|dvt.ComponentTouchEvent} event  Mouse, keyboard or touch event
 * @param {number} relPosX  x position relative to the page
 * @param {number} relPosY  y position relative to the page
 * @param {object} obj  logical object
 * @param {object} targetObj  Target object
 * @protected
 */
dvt.EventManager.prototype.ProcessObjectTooltip = function(event, relPosX, relPosY, obj, targetObj) {
  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_TOOLTIP_DISPLAYED_KEY)) {
    if (this._processShowTooltip(targetObj, obj, relPosX, relPosY))
      this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_TOOLTIP_DISPLAYED_KEY, true);
  }
};


/**
 * Resets the flag for external focus event. The flag is could be set when component gain the focus by mouse click or keyboard tabbing.
 * The flag is used by key up event and it is reset on timer to ensure that Eevnt manager does not keep stale flag.
 * @private
 */
dvt.EventManager.prototype._resetExternalKeyboardFocus = function() {
  this._handleExternalKeyboardFocus = false;
};

/**
 * Focus event handler.
 * @param {DvtFocusEvent} event focus event
 * @protected
 */
dvt.EventManager.prototype.OnFocus = function(event) {
  // - when user tabs into a component, the component does not get "keydown" event, since the keydown happened outside of the component.
  //Then the focus is transfered to the component and the component gets the "focus" and the "keyup" events.
  //As the result of the skipped "keydown" event, the first focus is set on the outer div, but the keyboard focus is not set/shown on the navigable object.
  //As a fix for this bug the _handleExternalKeyboardFocus flag is going to be used. When we detect that "keydown" is skipped, the flag is set to true.
  //Then if the focus was set by keyboard tabbing, the flag will be checked by the KeyUp event - the fake "keydown" is going to be generated in order to set the keyboard focus.
  //Otherwise the flag will be reset by the timer.
  this._handleExternalKeyboardFocus = false;

  if (!this._bKeyDown && !event.isPropagationStopped()) {
    this._handleExternalKeyboardFocus = true;
    if (!this._keyboardFocusTimer) {
      this._keyboardFocusTimer = new dvt.Timer(this._context, 200, this._resetExternalKeyboardFocus, this, 1);
    }
    this._keyboardFocusTimer.reset();
    this._keyboardFocusTimer.start();
    event.stopPropagation();
  }
};


/**
 * Blur event handler.
 * @param {DvtFocusEvent} event focus event
 * @protected
 */
dvt.EventManager.prototype.OnBlur = function(event) {
  //clean up the keyboard focus
  this._bKeyDown = false;
  var currentNavigable = this.getFocus();
  if (currentNavigable && currentNavigable.isShowingKeyboardFocusEffect()) {
    currentNavigable.hideKeyboardFocusEffect();
  }
};

/**
 * Processes a rollover action on the specified logical object.
 * @param {dvt.BaseEvent} event The event that caused the rollover.
 * @param {DvtLogicalObject} obj The logical object that was the target of the event.
 * @param {boolean} bOver True if this is a rollover, false if this is a rollout.
 */
dvt.EventManager.prototype.ProcessRolloverEvent = function(event, obj, bOver) {
  // subclasses must override if hoverBehavior is supported
};

/**
 * Creates category rollover handler
 * @param {function} callback A function that responds to component events.
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @return {dvt.CategoryRolloverHandler} category rollover handler
 */
dvt.EventManager.prototype.CreateCategoryRolloverHandler = function(callback, callbackObj) {
  return new dvt.CategoryRolloverHandler(callback, callbackObj);
};

/**
 * Returns the touch response for the component
 * @return {string}
 * @protected
 */
dvt.EventManager.prototype.GetTouchResponse = function() {
  return dvt.EventManager.TOUCH_RESPONSE_TOUCH_START;
};

/**
 * Returns true if touch response should be on touchStart event
 * @return {boolean}
 * @private
 */
dvt.EventManager.prototype._isTouchResponseTouchStart = function() {
  var touchResponse = this.GetTouchResponse();
  if (touchResponse === dvt.EventManager.TOUCH_RESPONSE_TOUCH_START)
    return true;
  else if (touchResponse === dvt.EventManager.TOUCH_RESPONSE_TOUCH_HOLD)
    return false;
  else {
    // start with the parent of the container div
    var root = this.getCtx().getSvgDocument().parentElement.parentElement;
    while (root && root.nodeName !== 'HTML') {
      var style = window.getComputedStyle(root);
      if (style.overflow !== 'hidden' &&
          ((root.scrollWidth > root.clientWidth + dvt.EventManager._TOUCH_RESPONSE_PADDING_CHECK && style['overflow-x'] !== 'hidden') ||
          (root.scrollHeight > root.clientHeight + dvt.EventManager._TOUCH_RESPONSE_PADDING_CHECK && style['overflow-y'] !== 'hidden'))) {
        return false;
      }
      root = root.parentElement;
    }
    return true;
  }
};

/**
 * Handles touch start actions like marquee select, tooltips, and category rollover.
 * @param {dvt.TouchEvent} event Touch event to handle
 * @param {dvt.Touch} touch Touch object for the event
 * @private
 */
dvt.EventManager.prototype._saveTouchStart = function(event, touch) {
  var touchIds = this.TouchManager.getTouchIdsForObj(dvt.EventManager.TOUCH_RESPONSE_TOUCH_START);
  if (touchIds.length <= 1) {
    // Use HOVER_TOUCH_KEY so that tooltips aren't canceled when touch hold is triggered in dvt.TouchManager
    this.TouchManager.saveProcessedTouch(touch.identifier, dvt.TouchManager.HOVER_TOUCH_KEY, null, dvt.TouchManager.HOVER_TOUCH_KEY, dvt.TouchManager.HOVER_TOUCH_KEY, this.HandleTouchActionsMove, this.HandleTouchActionsEnd, this);
    this.HandleTouchActionsStart(event);
  }
};

/**
 * Handles touch start and touch hold actions like marquee select, tooltips, and category rollover.
 * @param {dvt.TouchEvent|dvt.ComponentTouchEvent} event
 * @protected
 */
dvt.EventManager.prototype.HandleTouchActionsStart = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(targetObj);
  var touch = event instanceof dvt.ComponentTouchEvent ? event.touch : event.touches[0];
  var touchX = touch.pageX;
  var touchY = touch.pageY;

  // Logic copied from dvt.TouchManager._onTouchHoldHover
  if (!(event instanceof dvt.ComponentTouchEvent)) {
    if (!this._touchMap[touch.identifier])
      this._touchMap[touch.identifier] = {};

    this._touchMap[touch.identifier][dvt.TouchManager.PREV_HOVER_OBJ] = null;
    if (obj)
      this.HandleTouchActionsOver(event);
    this._touchMap[touch.identifier][dvt.TouchManager.PREV_HOVER_OBJ] = obj;
  }

  // Chart marquee selection
  if (this._marqueeHandler) {
    var relPos = this._context.pageToStageCoords(touchX, touchY);
    var marqueeEvent = this._marqueeHandler.processDragStart(relPos);
    if (marqueeEvent) {
      event.preventDefault();
      this._callback.call(this._callbackObj, marqueeEvent);
    }
  }

  // Category rollover support
  if (obj)
    this.ProcessRolloverEvent(event, obj, true);

  // Tooltips
  this._processTouchTooltip(event);

  this._prevActionClear = false;

  // Popups
  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    var position = new dvt.Point(touchX, touchY);
    var targetObj = this.GetCurrentTargetForEvent(event);
    var logObjAndDisp = this.GetLogicalObjectAndDisplayable(targetObj);
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_DOWN)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }
};

/**
 * Handles touch move actions.
 * @param {dvt.TouchEvent|dvt.ComponentTouchEvent} event Touch event to handle
 * @protected
*/
dvt.EventManager.prototype.HandleTouchActionsMove = function(event) {
  var touch = event instanceof dvt.ComponentTouchEvent ? event.touch : event.touches[0];

  var targetObj;
  var obj;
  if (!(event instanceof dvt.ComponentTouchEvent)) {
    // Cancel the browser default behavior to pan.
    event.preventDefault();

    // The target for a touch event is always the touchstart target. dvt.TouchManager already handles updating the
    // target based on the current x/y coordinates, but we need to handle it as well if we are dealing with the browser
    // touch events.
    targetObj = dvt.SvgDocumentUtils.elementFromTouch(touch);
    obj = this.GetLogicalObject(targetObj);
    var prevObj = this._touchMap[touch.identifier][dvt.TouchManager.PREV_HOVER_OBJ];
    if (prevObj != obj) {
      // Handle hover out/over events. Logic copied from dvt.TouchManager._onTouchHoldHover
      if (prevObj) {
        var target;
        if (prevObj.getDisplayable)
          target = prevObj.getDisplayable();
        else if (prevObj.getDisplayables)
          target = prevObj.getDisplayables()[0];

        if (target) {
          event.target = target;
          this.HandleTouchActionsOut(event, touch);
        }
      }

      event.target = targetObj;
      if (obj)
        this.HandleTouchActionsOver(event);
    }

    this._touchMap[touch.identifier][dvt.TouchManager.PREV_HOVER_OBJ] = obj;
  } else {
    targetObj = this.GetCurrentTargetForEvent(event);
    obj = this.GetLogicalObject(targetObj);
  }

  var touchX = touch.pageX;
  var touchY = touch.pageY;
  var relPos = this._context.pageToStageCoords(touchX, touchY);

  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragMove(relPos, event.ctrlKey);
    if (marqueeEvent) {
      event.preventDefault();
      this._callback.call(this._callbackObj, marqueeEvent);
    }
  }

  // Category rollover support
  if (obj)
    this.ProcessRolloverEvent(event, obj, true);

  var position = new dvt.Point(touch.pageX, touch.pageY);
  // Notify the popup handler of the mouse move
  this.PopupHandler.processMouseMove(position);

  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    var logObjAndDisp = this.GetLogicalObjectAndDisplayable(targetObj);
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_MOVE)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }
};


/**
 * Handles touch end actions.
 * @param {dvt.TouchEvent|dvt.ComponentTouchEvent} event Touch event to handle
 * @param {dvt.Touch=} touch Touch object for the event
 * @protected
 */
dvt.EventManager.prototype.HandleTouchActionsEnd = function(event, touch) {
  var targetObj;
  var obj;

  // Logic copied from dvt.TouchManager._onTouchHoldHover
  if (!(event instanceof dvt.ComponentTouchEvent)) {
    // Cancel the browser default behavior to pan.
    event.preventDefault();

    // The target for a touch event is always the touchstart target. dvt.TouchManager already handles updating the
    // target based on the current x/y coordinates, but we need to handle it as well if we are dealing with the browser
    // touch events.
    targetObj = dvt.SvgDocumentUtils.elementFromTouch(touch);
    obj = this.GetLogicalObject(targetObj);

    var target;
    if (obj) {
      if (obj.getDisplayable)
        target = obj.getDisplayable();
      else if (obj.getDisplayables)
        target = obj.getDisplayables()[0];
    }

    if (target) {
      event.target = target;
      this.HandleTouchActionsOut(event, touch);
    }

    this._touchMap[touch.identifier][dvt.TouchManager.PREV_HOVER_OBJ] = null;
  } else {
    // dvt.ComponentTouchEvent should use its stored touch, else at this point touch event has been passed in and removed from event
    targetObj = this.GetCurrentTargetForEvent(event);
    obj = this.GetLogicalObject(targetObj);
    touch = event.touch;
  }

  var touchX = touch.pageX;
  var touchY = touch.pageY;
  var relPos = this._context.pageToStageCoords(touchX, touchY);

  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragEnd(relPos, event.ctrlKey);
    if (marqueeEvent) {
      event.preventDefault();
      this._callback.call(this._callbackObj, marqueeEvent);
    }
  }

  this._processTouchSelection(obj);

  this._processActionPopup(targetObj, new dvt.Point(touchX, touchY));

  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    var position = new dvt.Point(touchX, touchY);
    var logObjAndDisp = this.GetLogicalObjectAndDisplayable(targetObj);
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_UP)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }
};

/**
 * Handles touch over actions.
 * @param {dvt.TouchEvent|dvt.ComponentTouchEvent} event Touch event to handle
 * @protected
*/
dvt.EventManager.prototype.HandleTouchActionsOver = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(targetObj);

  var touch = event instanceof dvt.ComponentTouchEvent ? event.touch : event.touches[0];
  var position = new dvt.Point(touch.pageX, touch.pageY);

  // Category Rollover Support
  if (obj)
    this.ProcessRolloverEvent(event, obj, true);

  var selectionHandler = this.getSelectionHandler(obj);
  if (selectionHandler)
    selectionHandler.processMouseOver(obj);

  // Popup Support for triggerType="hover"
  var logObjAndDisp = this.GetLogicalObjectAndDisplayable(targetObj);
  if (logObjAndDisp) {
    if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_OVER)) {
      this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
    }
  }
};

/**
 * Handles touch move actions.
 * @param {dvt.TouchEvent|dvt.ComponentTouchEvent} event Touch event to handle
 * @param {dvt.Touch=} touch Touch object for the event
 * @protected
*/
dvt.EventManager.prototype.HandleTouchActionsOut = function(event, touch) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(targetObj);

  // dvt.ComponentTouchEvent should use its stored touch, else at this point touch event has been passed in and removed from event
  if (event instanceof dvt.ComponentTouchEvent)
    touch = event.touch;

  // Category Rollover Support
  if (obj)
    this.ProcessRolloverEvent(event, obj, false);

  var selectionHandler = this.getSelectionHandler(obj);
  if (selectionHandler)
    selectionHandler.processMouseOut(obj);

  if (!this.GetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY)) {
    var position = new dvt.Point(touch.pageX, touch.pageY);
    var logObjAndDisp = this.GetLogicalObjectAndDisplayable(targetObj);
    if (logObjAndDisp) {
      if (this.PopupHandler.processMousePopup(obj, this._getShowPopupBehaviors(obj), position, logObjAndDisp.displayable, event, dvt.ShowPopupBehavior.TRIGGER_TYPE_MOUSE_OUT)) {
        this.SetEventInfo(event, dvt.EventManager._EVENT_INFO_POPUP_DISPLAYED_KEY, true);
      }
    }
  }
};
/**
 * Interactivity manager for custom tooltips and menus.  The two can be visually combined.
 * @class DvtCustomTooltipManager
 * @constructor
 */
var DvtCustomTooltipManager = function(context, id) {
  this.Init(context, id);
};

dvt.Obj.createSubclass(DvtCustomTooltipManager, dvt.Obj);

DvtCustomTooltipManager.prototype.Init = function(context, id) {
  this._context = context;
  this._id = id;
  this._actionTooltip = new DvtCustomTooltip(this._context, this._id + 'ActionPopup');
};

/*
 * For rendering a rich tooltip
 */
DvtCustomTooltipManager.prototype.GetRichTooltipManager = function() {
  if (!this._RichTooltipManager) {
    var tooltipId = this._id + 'Tooltip';
    // TODO: may want to change tooltip managers to have their own impl
    this._RichTooltipManager = this._context.getImplFactory().newRichTooltipManager(tooltipId);
    this._RichTooltipManager.InitializeTooltipElem();

    // Attach listeners to action tooltip displayable
    var tooltipContext = this._RichTooltipManager.GetStoredContext();
    if (tooltipContext) {
      var eh = new DvtCustomTooltipEventHandler(tooltipContext, this, null, null);
      eh.addListeners(this._actionTooltip);
    }
  }
  return this._RichTooltipManager;
};

// Clear settings on old action tooltip
DvtCustomTooltipManager.prototype.clearActionTooltip = function() {
  if (this._actionTooltip)
    this._actionTooltip.clearContent();
};

// Retrieve current action tooltip
DvtCustomTooltipManager.prototype.getActionTooltip = function() {
  return this._actionTooltip;
};

// Hide a tooltip that is currently showing
DvtCustomTooltipManager.prototype.hideTooltip = function() {
  this.clearActionTooltip();
  if (this._RichTooltipManager)
    this._RichTooltipManager.hideTooltip();
};

// Closes an action tooltip that was left on screen
DvtCustomTooltipManager.prototype.closeActionTooltip = function() {
  var closedEvent = new DvtActionTooltipEvent(DvtActionTooltipEvent.TOOLTIP_CLOSED_TYPE, this._actionPopupObj);
  this.FireListener(closedEvent);
  this._actionPopupObj = null;
  this.hideTooltip();
};

DvtCustomTooltipManager.prototype.showDatatip = function(x, y, text, borderColor) {
  var actionTooltip = this.getActionTooltip();
  text = DvtCustomTooltipManager._formatTextString(text);
  actionTooltip.setTooltipText(text);
  if (borderColor != null)
    actionTooltip.setTooltipBorderColor(borderColor);
  this.GetRichTooltipManager().showRichElement(x, y, actionTooltip, true);
};

DvtCustomTooltipManager.prototype.showTextAtPosition = function(x, y, text, borderColor, useOffset, popupClass) {
  var actionTooltip = this.getActionTooltip();
  text = DvtCustomTooltipManager._formatTextString(text);
  actionTooltip.setTooltipText(text);
  if (borderColor != null)
    actionTooltip.setTooltipBorderColor(borderColor);
  this.GetRichTooltipManager().showRichElement(x, y, actionTooltip, useOffset);
};

DvtCustomTooltipManager.prototype.displayActionPopup = function() {
  var actionTooltip = this.getActionTooltip();
  // If no action tooltip initialized with actions (not just tooltips), don't show one
  if (!actionTooltip || !actionTooltip.hasMenuItems())
    return false;
  return true;
};

DvtCustomTooltipManager.prototype.startActionPopupAtPosition = function(pageX, pageY, targetObj, alignment) {
  var actionTooltip = this.getActionTooltip();
  if (!actionTooltip)
    return;

  this.GetRichTooltipManager().showRichElementAtPosition(pageX, pageY, actionTooltip, true, false);

  // Clear the text
  var startEvent = new DvtActionTooltipEvent(DvtActionTooltipEvent.TOOLTIP_STARTED_TYPE, targetObj);
  this.FireListener(startEvent);

  this._actionPopupObj = targetObj;

};


/**
 * Adds an event listener.
 **/
DvtCustomTooltipManager.prototype.addTooltipEventListener = function(type, listener, obj) {
  // Store a reference to the listener
  var listenersArray = this._getListeners(type, true);
  listenersArray.push(listener);
  listenersArray.push(obj);
};


/**
 * Removes an event listener.
 **/
DvtCustomTooltipManager.prototype.removeTooltipEventListener = function(type, listener, obj) {
  // Remove the listener
  var listenersArray = this._getListeners(type, false);
  if (listenersArray !== null) {
    for (var i = 0; i < listenersArray.length; i += 2) {
      if (listenersArray[i] === listener &&
          listenersArray[i + 1] === obj) {
        listenersArray.splice(i, 2);
        break;
      }
    }
  }
};


/**
 * Returns the listeners of the given event type
 **/
DvtCustomTooltipManager.prototype._getListeners = function(type, createNew) {
  // First find the object where the listener arrays are stored
  if (!this._listenerObj) {
    if (createNew) {
      this._listenerObj = {
      };
    }
    else {
      return null;
    }
  }

  // Then find the array for this event type, creating if necessary
  var eventKey = type;
  var listenersArray = this._listenerObj[eventKey];
  if (!listenersArray && createNew) {
    listenersArray = [];
    this._listenerObj[eventKey] = listenersArray;
  }

  return listenersArray;
};


/**
 * Notifies all applicable event listeners of the given event.
 **/
DvtCustomTooltipManager.prototype.FireListener = function(event) {
  var listenersArray = this._getListeners(event.getType(), false);
  if (listenersArray) {
    for (var i = 0; i < listenersArray.length; i += 2) {
      var obj = listenersArray[i + 1];
      listenersArray[i].call(obj, event);
    }
  }
};

/**
 * Returns a formatted version of the tooltip.
 * @param {string} tooltip
 * @return {string}
 * @private
 */
DvtCustomTooltipManager._formatTextString = function(tooltip)
{
  var fullText = '';
  if (!tooltip)
    return fullText;

  tooltip = tooltip.replace(/\n/g, '<br>'); // replace logical newlines sequences
  var tooltipTextArray = tooltip.split('<br>');
  if (tooltipTextArray) {
    var shortArray = new Array();
    for (var i = 0; i < tooltipTextArray.length; i++) {
      var txt = tooltipTextArray[i];
      if (txt != null && txt != '') {
        shortArray.push(txt);
      }
    }
    for (var i = 0; i < shortArray.length; i++) {
      fullText += shortArray[i];
      if (i < shortArray.length - 1) {
        fullText += '\n';
      }
    }
  }
  return fullText;
};
// Custom tooltip event handler
/**
 * @constructor
 */
var DvtCustomTooltipEventHandler = function(context, customTooltipManager, callback, callbackObj)
{
  this._customTooltipManager = customTooltipManager;
  this.Init(context, callback, callbackObj);

};

dvt.Obj.createSubclass(DvtCustomTooltipEventHandler, dvt.EventManager);

DvtCustomTooltipEventHandler.prototype.OnClickInternal = function(event) {
  var target = event.target;
  this._handleMenuClick(target);
};

DvtCustomTooltipEventHandler.prototype.HandleImmediateTouchStartInternal = function(event, touch) {
  event.blockTouchHold();
  this._handleMenuClick(event.target);
};

DvtCustomTooltipEventHandler.prototype.HandleTouchClickInternal = function(evt) {
  var target = evt.target;
  this._handleMenuClick(target);
};

DvtCustomTooltipEventHandler.prototype._handleMenuClick = function(targetObj) {
  var actionObj = this._customTooltipManager._actionPopupObj;
  var menuItem = targetObj._menu;
  if (menuItem) {
    var fireAction = true;
    if (menuItem instanceof DvtContextMenuTooltipItem && menuItem._menuItem.isDisabled()) {
      fireAction = false;
    }
    if (fireAction) {
      // Close before menu item event fired since listener may need restored component visual state
      this._customTooltipManager.closeActionTooltip();
      menuItem.FireActionTooltipItem(actionObj);
    }
  }
};
/*--------------------------------------------------------------------*/
/*   DvtCustomTooltip              Action tooltip Component           */
/*--------------------------------------------------------------------*/
/**
  * @constructor
  *  Action tooltip component.
  *  @extends {dvt.Obj}
  *  @class DvtCustomTooltip  Creates an action tooltip component.
  */
var DvtCustomTooltip = function(context, id)
{
  this._Init(context, id);
};

dvt.Obj.createSubclass(DvtCustomTooltip, dvt.Container);

DvtCustomTooltip.DEFAULT_BORDER_COLOR = 'gray';
DvtCustomTooltip.DEFAULT_BACKGROUND_COLOR = '#ffffff';

DvtCustomTooltip.TOOLTIP_ONLY = 'tooltipOnly';
DvtCustomTooltip.MENU_ONLY = 'menuOnly';
DvtCustomTooltip.MENU_AND_TOOLTIP = 'menuAndTooltip';
DvtCustomTooltip.EMPTY = 'empty';

DvtCustomTooltip.MENU_PADDING_LEFT = 21;
DvtCustomTooltip.MENU_PADDING_RIGHT = 10;

DvtCustomTooltip.prototype._Init = function(context, id)
{

  this._context = context;
  if (! this.getImpl()) {
    this.setImpl(context.getImplFactory().newContainer('customTT'));
  }
  DvtCustomTooltip.superclass.Init.call(this, context);

  this._tooltipText = null;
  this._tooltipBorderColor = null;
  this._menuFontSize = 11;
  this._tooltipFill = new dvt.SolidFill(DvtCustomTooltip.DEFAULT_BACKGROUND_COLOR);
  this._fontSize = 11; // TODO: This shouldn't be hard coded, but this maintains the existing behavior
  this._includePointer = false;//true;
  this._pointerLocation = new dvt.Point(0, 0);
};

DvtCustomTooltip.prototype.setIncludePointer = function(includePointer)
{
  this._includePointer = includePointer;
};

DvtCustomTooltip.prototype.getRootDisplayable = function()
{
  return this;
};

DvtCustomTooltip.prototype.UpdateTooltipSize = function(width, height)
{
  this._displayWidth = width;
  this._displayHeight = height;
};

DvtCustomTooltip.prototype.getDisplayWidth = function() {
  return this._displayWidth;
};

DvtCustomTooltip.prototype.getDisplayHeight = function() {
  return this._displayHeight;
};

DvtCustomTooltip.prototype.clearContent = function() {
  this.clearMenuItems();
  this.setTooltipBorderColor(null);
  this.setTooltipText(null);
};

DvtCustomTooltip.prototype.setMenuFontSize = function(font) {
  this._menuFontSize = font;
};

DvtCustomTooltip.prototype.setTooltipBorderColor = function(color) {
  this._tooltipBorderColor = color;
};

DvtCustomTooltip.prototype.getTooltipBorderColor = function() {
  return this._tooltipBorderColor;
};

DvtCustomTooltip.prototype.setTooltipFill = function(tooltipFill) {
  this._tooltipFill = tooltipFill;
};

DvtCustomTooltip.prototype.setTooltipText = function(text) {
  this._tooltipText = text;
};

DvtCustomTooltip.prototype.getTooltipText = function() {
  return this._tooltipText;
};

DvtCustomTooltip.prototype.addMenuItem = function(menuItem) {
  this.getMenuItems().push(menuItem);
};

DvtCustomTooltip.prototype.hasMenuItems = function() {
  var menuItems = this.getMenuItems();
  return menuItems && menuItems.length > 0;
};

DvtCustomTooltip.prototype.clearMenuItems = function() {
  if (this._menuItems) {
    this._menuItems = [];
  }
};

DvtCustomTooltip.prototype.getMenuItems = function() {
  if (!this._menuItems)
    this._menuItems = new Array();
  return this._menuItems;
};

DvtCustomTooltip.prototype.containsMenuId = function(id) {
  var menuItems = this.getMenuItems();
  for (var i = 0; i < menuItems.length; i++) {
    var menuItem = menuItems[i];
    if (menuItem.getId() == id) {
      return true;
    }
  }
  return false;
};

DvtCustomTooltip.prototype.getTooltipType = function() {
  var hasMenuItems = this.hasMenuItems();
  if (hasMenuItems) {
    return DvtCustomTooltip.MENU_ONLY;
  }
  return DvtCustomTooltip.EMPTY;
};


/**
 * Renders this action tooltip.
 */
DvtCustomTooltip.prototype.Render = function() {

  var parent = this.getRootDisplayable();
  //parent.setPixelHinting(true);
  // First clear old drawables
  parent.removeChildren();

  var type = this.getTooltipType();
  if (type == DvtCustomTooltip.EMPTY) {
    return;
  }

  // Constants
  var padding = 4;
  var menuItemPadding = 5;
  var tooltipBorderWidth = 2;

  if (this._includePointer) {
    tooltipBorderWidth = 3;
    padding = 10;
  }

  // Temp variables
  var hasMenuItems = this.hasMenuItems();
  var topTextY = padding + tooltipBorderWidth / 2;
  var runningHeight = 0;
  var maxWidth = 0;

  if (type == DvtCustomTooltip.TOOLTIP_ONLY) {
    parent.setAlpha(0.9);
  } else {
    parent.setAlpha(1);
  }

  var textItems = new Array();
  var textWidths = new Array();

  if (type == DvtCustomTooltip.MENU_AND_TOOLTIP) {
    runningHeight += menuItemPadding;
  } else if (type == DvtCustomTooltip.MENU_ONLY) {
    runningHeight += menuItemPadding / 2;
  }

  if (hasMenuItems) {


    var menuItems = this.getMenuItems();
    for (var i = 0; i < menuItems.length; i++) {
      var menuItem = menuItems[i];

      var text = new dvt.OutputText(this._context, menuItem.getText(), 0, 0, null);
      text.alignBottom();
      text.setFontSize(this._menuFontSize);

      if (menuItem instanceof DvtContextMenuTooltipItem) {
        if (menuItem._menuItem.isDisabled()) {
          text.setAlpha(0.5);
        }
      }

      text._menu = menuItem;

      var dimensions = text.measureDimensions();
      dimensions.y = topTextY + runningHeight;
      var textWidth = dimensions.w;
      textWidths.push(dimensions);
      maxWidth = Math.max(textWidth + DvtCustomTooltip.MENU_PADDING_LEFT + DvtCustomTooltip.MENU_PADDING_RIGHT, maxWidth);
      text.setY(dimensions.y);
      runningHeight += dimensions.h;

      if (i < menuItems.length - 1) {
        runningHeight += menuItemPadding;
      }

      textItems.push(text);
      text.alignLeft();
      text.alignTop();
    }

  }
  if (type == DvtCustomTooltip.MENU_ONLY || type == DvtCustomTooltip.MENU_AND_TOOLTIP) {
    runningHeight += menuItemPadding / 2;
  }

  var contentWidth = maxWidth + 2 * padding;
  var tooltipWidth = contentWidth + tooltipBorderWidth;
  var tooltipHeight = topTextY + runningHeight + padding + tooltipBorderWidth / 2;

  if (this._cursorText)
    this._cursorText.setTranslateX(padding + tooltipBorderWidth / 2);

  var pointerWidth = 12;
  var isRightPointer = (this._pointerLocation.x > tooltipWidth);
  var pointerOffsetX = -this._pointerLocation.x;
  var pointerOffsetY = this._pointerLocation.y;

  if (this._includePointer) {

    if (tooltipHeight / 2 < pointerWidth)
      pointerWidth = tooltipHeight / 3;

    var newTooltipHeight = tooltipHeight + tooltipBorderWidth;
    newTooltipHeight = Math.max(pointerOffsetY + tooltipBorderWidth, newTooltipHeight);
    var transX;
    if (isRightPointer) {
      this.UpdateTooltipSize(this._pointerLocation.x, newTooltipHeight);
      transX = tooltipBorderWidth / 2;
    } else {
      this.UpdateTooltipSize(tooltipWidth + pointerOffsetX + tooltipBorderWidth, newTooltipHeight);
      transX = tooltipBorderWidth / 2 + pointerOffsetX;
    }
    parent.setTranslate(transX, tooltipBorderWidth / 2);
  } else {
    this.UpdateTooltipSize(tooltipWidth + tooltipBorderWidth, tooltipHeight + tooltipBorderWidth);
    parent.setTranslate(tooltipBorderWidth / 2, tooltipBorderWidth / 2);
  }


  // Add background panels
  var backgroundPanel = new dvt.Rect(this._context, 0, 0, tooltipWidth, tooltipHeight);
  if (this._includePointer) {

    var radius = 5;
    var beginArrowY = tooltipHeight / 2;

    if (isRightPointer) {
      //this._pointerStartOffset;
      var p1 = new dvt.Point(0, 0);
      var p2 = new dvt.Point(tooltipWidth, 0);
      var p3 = new dvt.Point(tooltipWidth, beginArrowY);
      var p4 = new dvt.Point(this._pointerLocation.x, pointerOffsetY);
      var p5 = new dvt.Point(tooltipWidth, beginArrowY + pointerWidth);
      var p6 = new dvt.Point(tooltipWidth, tooltipHeight);
      var p7 = new dvt.Point(0, tooltipHeight);

      var cmd = dvt.PathUtils.moveTo(p1.x + radius, p1.y) +
                dvt.PathUtils.lineTo(p2.x - radius, p2.y) +
                dvt.PathUtils.arcTo(radius, radius, Math.PI / 2, 1, p2.x, p2.y + radius) +
                dvt.PathUtils.lineTo(p3.x, p3.y) +
                dvt.PathUtils.lineTo(p4.x, p4.y) +
                dvt.PathUtils.lineTo(p5.x, p5.y) +
                dvt.PathUtils.lineTo(p6.x, p6.y - radius) +
                dvt.PathUtils.arcTo(radius, radius, Math.PI / 2, 1, p6.x - radius, p6.y) +
                dvt.PathUtils.lineTo(p7.x + radius, p7.y) +
                dvt.PathUtils.arcTo(radius, radius, Math.PI / 2, 1, p7.x, p7.y - radius) +
                dvt.PathUtils.lineTo(0, radius) +
                dvt.PathUtils.arcTo(radius, radius, Math.PI / 2, 1, radius, 0) +
                dvt.PathUtils.closePath();
      backgroundPanel = new dvt.Path(this._context, cmd, null);
    } else {
      //this._pointerStartOffset;
      var p1 = new dvt.Point(0, 0);
      var p2 = new dvt.Point(tooltipWidth, 0);
      var p3 = new dvt.Point(tooltipWidth, tooltipHeight);
      var p4 = new dvt.Point(0, tooltipHeight);
      var p5 = new dvt.Point(0, beginArrowY + pointerWidth);
      var p6 = new dvt.Point(-pointerOffsetX, pointerOffsetY);
      var p7 = new dvt.Point(0, beginArrowY);

      var cmd = dvt.PathUtils.moveTo(p1.x + radius, p1.y) +
                dvt.PathUtils.lineTo(p2.x - radius, p2.y) +
                dvt.PathUtils.arcTo(radius, radius, Math.PI / 2, 1, p2.x, p2.y + radius) +
                dvt.PathUtils.lineTo(p3.x, p3.y - radius) +
                dvt.PathUtils.arcTo(radius, radius, Math.PI / 2, 1, p3.x - radius, p3.y) +
                dvt.PathUtils.lineTo(p4.x + radius, p4.y) +
                dvt.PathUtils.arcTo(radius, radius, Math.PI / 2, 1, p4.x, p4.y - radius) +
                dvt.PathUtils.lineTo(p5.x, p5.y) +
                dvt.PathUtils.lineTo(p6.x, p6.y) +
                dvt.PathUtils.lineTo(p7.x, p7.y) +
                dvt.PathUtils.lineTo(0, radius) +
                dvt.PathUtils.arcTo(radius, radius, Math.PI / 2, 1, radius, 0) +
                dvt.PathUtils.closePath();
      backgroundPanel = new dvt.Path(this._context, cmd, null);
    }
  }

  backgroundPanel.setSolidStroke('rgb(229,232,238)');

  if (!this._tooltipFill)
    this._tooltipFill = new dvt.SolidFill(DvtCustomTooltip.DEFAULT_BACKGROUND_COLOR);
  backgroundPanel.setFill(this._tooltipFill);
  parent.addChildAt(backgroundPanel, 0);

  var dividerWidth = contentWidth * 0.95;
  var dividerX = (tooltipWidth - dividerWidth) / 2;
  // Add text items
  for (var i = 0; i < textItems.length; i++) {
    var textItem = textItems[i];
    parent.addChild(textItem);
    var textWidth = textWidths[i].w;
    if (textItem._menu) {
      // Menus have target areas
      var hitAreaRect = new dvt.Rectangle(0, textWidths[i].y - menuItemPadding / 2, tooltipWidth, textWidths[i].h + menuItemPadding);
      var hitTarget = new dvt.Rect(this._context, hitAreaRect.x, hitAreaRect.y, hitAreaRect.w, hitAreaRect.h);
      hitTarget.setInvisibleFill();

      hitTarget._menu = textItem._menu;
      parent.addChild(hitTarget);

      if (i > 0) {
        var menuItemObj = textItem._menu._menuItem;

        var prevItem = textItems[i - 1];

        if (prevItem._menu instanceof DvtContextMenuTooltipItem) {
          //Separators between context menu items
          if (menuItemObj.hasSeparatorBefore()) {
            var fill = new dvt.SolidFill('gray', 0.5);
            this.renderDivider(parent, dividerX, textWidths[i].y - menuItemPadding / 2, dividerWidth, fill);
          }
        } else {
          // First context menu item, show a division between this and built in actions
          //var fill = new dvt.SolidFill("gray", 1);
          //this.renderDivider(parent, dividerX, textWidths[i].y - menuItemPadding/2, dividerWidth, fill);
        }
      }
    }
    textItem.setTranslateX(DvtCustomTooltip.MENU_PADDING_LEFT);
  }
};

DvtCustomTooltip.prototype.renderDivider = function(parent, x, y, width, fill) {
  var divider = new dvt.Rect(this._context, x, y, width, 1);
  divider.setFill(fill);
  parent.addChild(divider);
};



/*--------------------------------------------------------------------*/
/*   DvtCustomTooltipItem              Action tooltip item            */
/*--------------------------------------------------------------------*/
/**
  *  Logical action tooltip item.  No dependency on drawables
  *  @extends {dvt.Obj}
  *  @class DvtCustomTooltipItem  Creates an action tooltip item.
  *  @constructor
  */
var DvtCustomTooltipItem = function(context, id, text, listener, listenerObj)
{
  this.Init(context, id, text, listener, listenerObj);
};

dvt.Obj.createSubclass(DvtCustomTooltipItem, dvt.Obj);

DvtCustomTooltipItem.prototype.Init = function(context, id, text, listener, listenerObj) {
  this._context = context;
  this._id = id;
  this._text = text;
  this._listener = listener;
  this._listenerObj = listenerObj;
};

DvtCustomTooltipItem.prototype.getId = function() {
  return this._id;
};

DvtCustomTooltipItem.prototype.getText = function() {
  return this._text;
};

DvtCustomTooltipItem.prototype.FireActionTooltipItem = function(target) {
  if (this._listenerObj && this._listener) {
    var evt = new Object();
    evt.target = target;
    evt.menuItem = this._menuItem;
    this._menuItemTimer = new dvt.Timer(this._context, 1, this._handleMenuTimer, this);
    // store event on timer temporarily
    this._menuItemTimer.evt = evt;
    this._menuItemTimer.start();
  }
};

// Timer handler for menu item listener
DvtCustomTooltipItem.prototype._handleMenuTimer = function() {
  if (this._menuItemTimer) {
    this._menuItemTimer.stop();
  }
  this._listener.call(this._listenerObj, this._menuItemTimer.evt);
};



/**
 * @constructor
 */
var DvtContextMenuTooltipItem = function(context, id, listener, listenerObj, menuItem)
{
  this.Init(context, id, listener, listenerObj, menuItem);
};

dvt.Obj.createSubclass(DvtContextMenuTooltipItem, DvtCustomTooltipItem);

DvtContextMenuTooltipItem.prototype.Init = function(context, id, listener, listenerObj, menuItem) {
  DvtContextMenuTooltipItem.superclass.Init.call(this, context, id, menuItem.getText(), listener, listenerObj);
  this._menuItem = menuItem;
};
/**
 * Abstract class for XML parser.
 * @extends {dvt.Obj}
 * @class dvt.XmlParser
 * @constructor
 *
 * @param {dvt.Context}  context  platform specific context object
 */
dvt.XmlParser = function(context) {
  if (!this._impl) {
    this._impl = context.getImplFactory().newParser();
  }
};

dvt.Obj.createSubclass(dvt.XmlParser, dvt.Obj);


/**
 * Parses the XML string and returns the root node.
 * @param {string} xmlString the XML string to parse
 * @return {dvt.XmlNode} the root node of the XML document
 */
dvt.XmlParser.prototype.parse = function(xmlString) {
  if (this._impl && this._impl.parse) {
    return this._impl.parse(xmlString);
  }

  return null;
};
/**
 * Abstract class for XML node.  Subclasses should override to provide support
 * for different platforms.
 * @extends {dvt.Obj}
 * @class dvt.XmlNode
 * @constructor
 */
dvt.XmlNode = function() {};

dvt.Obj.createSubclass(dvt.XmlNode, dvt.Obj);


/**
 * Returns the value for the given attribute in this XML node.
 * @param {string} attr the attribute to look for
 * @return {string} the value of the attribute, if available
 */
dvt.XmlNode.prototype.getAttr = function(attr) {
  return null; // subclasses should override
};


/**
 * Returns an Array containing the child elements of this node.  Only nodes that
 * are XML elements are returned.  Text nodes are ignored.
 * @return {array} an Array containing all child elements of this node.
 */
dvt.XmlNode.prototype.getChildNodes = function() {
  return new Array(); // subclasses shoudl override
};


/**
 * Returns the child element of this node. Only nodes that
 * are XML elements are returned.  Text nodes are ignored.
 * @return {dvt.XmlNode} the first child element
 */
dvt.XmlNode.prototype.getChild = function(i) {
  var children = this.getChildNodes();
  if (children != null && children.length > i)
    return children[i];
  else
    return null;
};


/**
 * Returns the first child element of this node. Only nodes that
 * are XML elements are returned.  Text nodes are ignored.
 * @return {dvt.XmlNode} the first child element
 */
dvt.XmlNode.prototype.getFirstChild = function() {
  return this.getChild(0);
};


/**
 * Returns the name of this node.
 * @return {string} the name of the node
 */
dvt.XmlNode.prototype.getName = function() {
  return null; //subclasses should override
};


/**
 * Returns the attributes of this node as an array of
 * {name:, value:} pairs.
 * @return {array} the attributes of the node
 */
dvt.XmlNode.prototype.getAttributes = function() {
  return null; //subclasses should override
};


/**
 * Returns an Array containing the children of this node.
 * @return {array} an Array containing all child elements and text nodes of this node.
 */
dvt.XmlNode.prototype.getAllChildNodes = function() {
  return new Array(); // subclasses shoudl override
};


/**
 * Returns the value of this node.
 * @return {string} the value of the node
 */
dvt.XmlNode.prototype.getNodeValue = function() {
  return null; //subclasses should override
};


/**
 * Returns the textContent of this node.
 * @return {string} the textContent of the node
 */
dvt.XmlNode.prototype.getTextContent = function() {
  return null; //subclasses should override
};


/**
 * Returns a node list of all child element nodes whose tagName match the speccified name.
 * @return {string} the name of the node
 */
dvt.XmlNode.prototype.getElementsByTagName = function(name) {
  return null; //subclasses should override
};

/**
 * @param {dvt.Context} context
 * @param {string} domElementId
 * @constructor
 * @extends {dvt.TooltipManager}
 * @class dvt.HtmlTooltipManager
 */
dvt.HtmlTooltipManager = function(context, domElementId) {
  this.Init(context, domElementId);
};

dvt.Obj.createSubclass(dvt.HtmlTooltipManager, dvt.TooltipManager);

/** @private @const */
dvt.HtmlTooltipManager._TOOLTIP_DIV_ID = '_dvtTooltip';

/** @private @const */
dvt.HtmlTooltipManager._SHOW_DELAY = 500;  // in ms

/** @private @const */
dvt.HtmlTooltipManager._BORDER_COLOR = '#9ba2b0';
/** @private @const */
dvt.HtmlTooltipManager._FONT_COLOR = '#383a47';

/** @private @const */
dvt.HtmlTooltipManager._VIEWPORT_BUFFER = 15;

/**
 * @param {dvt.Context} context
 * @param {string} domElementId
 */
dvt.HtmlTooltipManager.prototype.Init = function(context, domElementId) 
{
  this._context = context;

  // if a dom element is specified, it will override the default tooltip div
  this._domElementId = (domElementId ? domElementId : dvt.HtmlTooltipManager._TOOLTIP_DIV_ID);
  this._isTooltip = true;
};


/**
 * Displays a datatip.
 * @param {number} x The pageX coordinate at which to display the datatip.
 * @param {number} y The pageY coordinate at which to display the datatip.
 * @param {string} text The string to show in the datatip.
 * @param {string} borderColor The border color for the datatip.
 * @param {boolean=} useOffset false to prevent offsets from being applied. Offsets will be applied otherwise.
 */
dvt.HtmlTooltipManager.prototype.showDatatip = function(x, y, text, borderColor, useOffset)
{
  // If useOffset not specified, then apply offsets
  if (useOffset == null)
    useOffset = true;

  this._isTooltip = false;
  this._showTextAtPosition(x, y, text, borderColor, useOffset, this._context.getDatatipStyleClass());
};


/**
 * Helper to display a datatip or tooltip.
 * @param {number} x The pageX coordinate at which to display the tooltip.
 * @param {number} y The pageY coordinate at which to display the tooltip.
 * @param {string} text The string to show in the tooltip.
 * @param {string} borderColor The border color for the tooltip.
 * @param {boolean} useOffset True if offsets should be applied to the coordinates.
 * @param {string} popupClass The style class to use for the outer tooltip div.
 * @private
 */
dvt.HtmlTooltipManager.prototype._showTextAtPosition = function(x, y, text, borderColor, useOffset, popupClass)
{
  var tooltipElem;
  var outerElem = this.getTooltipElem();

  // Make replacements on the text string as needed
  if (typeof text == 'string') {
    // Clear out the previous tooltip to make room for the new one. This is done in getCustomTooltip for the custom case
    while (outerElem.hasChildNodes())
      outerElem.removeChild(outerElem.firstChild);

    // For security, turn HTML brackets into strings to disable tags.
    text = text.replace(/(<|&#60;)/g, '&lt;');
    text = text.replace(/(>|&#62;)/g, '&gt;');

    // Support a subset of HTML tags, including bold, italic, and table tags.
    text = dvt.HtmlTooltipManager._restoreTag(text, 'b');
    text = dvt.HtmlTooltipManager._restoreTag(text, 'i');
    text = dvt.HtmlTooltipManager._restoreTag(text, 'table');
    text = dvt.HtmlTooltipManager._restoreTag(text, 'tr');
    text = dvt.HtmlTooltipManager._restoreTag(text, 'td');

    // Replace logical newlines sequences
    text = text.replace(/\n/g, '<br>');
    text = text.replace(/\\n/g, '<br>');
    text = text.replace(/&#92;n/g, '<br>');
    text = dvt.HtmlTooltipManager._restoreTag(text, 'br');

    // Create the tooltip element
    tooltipElem = document.createElement('span');
    tooltipElem.style.visibility = 'inherit';
    tooltipElem.style.width = null;
    tooltipElem.style.height = null;

    // Set the text
    tooltipElem.innerHTML = text;//@HtmlUpdateOk
  }
  // true means that we are not to modify the tooltip contents
  else if (text != true)
    tooltipElem = text; // the text is an element to be appended directly

  // Apply default class and border color on the outer element only if the user hasn't specified them ( + 21150376)
  if (!this._isCustomClassName)
    outerElem.className = popupClass;
  this._isCustomClassName = false;

  if (!borderColor)
    borderColor = dvt.HtmlTooltipManager._BORDER_COLOR;

  if (!this._isCustomBorderColor)
    outerElem.style.borderColor = borderColor;
  this._isCustomBorderColor = false;

  // Position the outer element
  outerElem.style.position = 'absolute';
  outerElem.style.zIndex = 2147483647;

  if (tooltipElem != null)  // only add content if the elem has not already been populated
    outerElem.appendChild(tooltipElem);//@HTMLUpdateOK

  this.PostElement(outerElem, x, y, true, useOffset);
};


/**
 * Performs a bunch of processing for an assembled tooltip or datatip.
 * @param {object} tooltip The outer DOM element of the tooltip.
 * @param {number} x The pageX coordinate at which to display the tooltip.
 * @param {number} y The pageY coordinate at which to display the tooltip.
 * @param {boolean} noEvents True if this tooltip should not recieve mouse events.
 * @param {boolean} useOffset True if this tooltip should be offset from the x and y coordinates.
 * @protected
 */
dvt.HtmlTooltipManager.prototype.PostElement = function(tooltip, x, y, noEvents, useOffset) {
  // Block mouse events if the tip is not interactive
  tooltip.style['pointer-events'] = noEvents ? 'none' : 'auto';

  // Clear the width and height, and reset the position to 0,0. This allows positionTip to get the accurate tooltip size
  tooltip.style.width = null;
  tooltip.style.height = null;
  tooltip.style.left = '0px';
  tooltip.style.top = '0px';

  // Add offsets to the tip position as needed
  if (useOffset) {
    var offsets = this._getOffsets(tooltip);
    this.positionTip(x + offsets.x, y + offsets.y, x, y);
  }
  else
    this.positionTip(x, y, x, y);

  // Make the tooltip visible
  tooltip.style.visibility = 'visible';

  // Invoke the tooltip attached callback if one is available.
  var callback = this._context.getTooltipAttachedCallback();
  if (callback)
    callback(tooltip);
};


/**
 * @override
 */
dvt.HtmlTooltipManager.prototype.hideTooltip = function()
{
  this.clearTooltip();
  this._tooltipDisplayed = false;
  this._timerIsRunning = false;

  var tooltip = document.getElementById(this._domElementId);
  if (tooltip) {
    tooltip.style.visibility = 'hidden';
    tooltip.style.overflow = null;
    tooltip.style.width = '0px';
    tooltip.style.height = '0px';
    if (!dvt.Agent.isRightToLeft(this._context))
      tooltip.style.left = '0px';
    else
      tooltip.style.left = tooltip.style.right;
    tooltip.style.top = '0px';
  }
};


/**
 * Retrieves the outer DOM element of the tooltip.
 * @return {object}
 * @protected
 */
dvt.HtmlTooltipManager.prototype.getTooltipElem = function() {
  // Retrieve the tooltip element and create if it doesn't exist.
  var tooltip = document.getElementById(this._domElementId);
  if (!tooltip)
    tooltip = this.InitializeTooltipElem();

  return tooltip;
};


/**
 * Initializes the outer DOM element of the tooltip.
 * @return {object} The outer DOM element.
 * @protected
 */
dvt.HtmlTooltipManager.prototype.InitializeTooltipElem = function() {
  var tooltip = document.createElement('div');
  tooltip.id = this._domElementId;
  tooltip.style.visibility = 'hidden';
  document.body.appendChild(tooltip);//@HTMLUpdateOK
  this.InitContent(tooltip);
  return tooltip;
};


/**
 * TODO JSDoc
 * @param {string} tooltip
 * @protected
 */
dvt.HtmlTooltipManager.prototype.InitContent = function(tooltip) {
};


/**
 * @override
 */
dvt.HtmlTooltipManager.prototype.showTooltip = function(x, y, text, shape, bTrackMouse, borderColor)
{
  if (!text || text.length == 0)
    return;

  this._x = x;
  this._y = y;
  this._text = text;

  //TODO: trackMouse is not working!
  this._trackMouse = bTrackMouse;

  if (this._timerIsRunning)
    return;

  var tooltipElem = document.createElement('span');
  tooltipElem.className = 'OraDVTTooltipText';
  tooltipElem.innerHTML = text;//@HtmlUpdateOK
  tooltipElem.style.color = dvt.HtmlTooltipManager._FONT_COLOR;

  if (!borderColor) {
    borderColor = dvt.HtmlTooltipManager._BORDER_COLOR;
  }
  var outerElem = this.getTooltipElem();
  outerElem.style.borderColor = borderColor;

  if (dvt.Agent.isTouchDevice() || (this._tooltipDisplayed && this._trackMouse)) {
    this._displayTooltip(this._x, this._y, this._text, this._borderColor);
  } else {
    // Tooltips fade-in and remove themselves after a delay.
    this._timerIsRunning = true;
    this._showTimerId = window.setTimeout(dvt.Obj.createCallback(this, this._handleShowTimer), dvt.HtmlTooltipManager._SHOW_DELAY);//@HTMLUpdateOK
  }
};


/**
 * Clears the currently displayed tooltip.
 */
dvt.HtmlTooltipManager.prototype.clearTooltip = function()
{
  if (this._showTimerId) {
    window.clearTimeout(this._showTimerId);

    this._showTimerId = undefined;
    this._x = undefined;
    this._y = undefined;
    this._text = undefined;

    this._trackMouse = undefined;
  }
  if (this._hideTimerId) {
    window.clearTimeout(this._hideTimerId);
    this._hideTimerId = undefined;
  }
};


/**
 * TODO JSDoc
 * @param {object} event
 * @private
 */
dvt.HtmlTooltipManager.prototype._handleShowTimer = function(event)
{
  this._timerIsRunning = false;
  this._displayTooltip(this._x, this._y, this._text, this._borderColor);
  this._tooltipDisplayed = true;
};


/**
 * TODO JSDoc
 * @param {number} x
 * @param {number} y
 * @param {string} text
 * @param {string} borderColor
 * @private
 */
dvt.HtmlTooltipManager.prototype._displayTooltip = function(x, y, text, borderColor) 
{
  this._isTooltip = true;
  this._showTextAtPosition(x, y, text, borderColor, true, this._context.getTooltipStyleClass());
};


/**
 * TODO JSDoc
 * TODO This should return dvt.Dimension, not dvt.Point
 * @param {string} tooltip
 * @private
 * @return {dvt.Point}
 */
dvt.HtmlTooltipManager.prototype._getOffsets = function(tooltip)
{
  var tooltipBounds = this.getTooltipBounds(tooltip);
  if (dvt.Agent.isTouchDevice()) {
    return new dvt.Point(0 - tooltipBounds.w / 2, -30 - tooltipBounds.h);
  }
  else {
    var yOffset = -8 - tooltipBounds.h;
    var xOffset = 8;
    if (this._isTooltip) {
      yOffset = 22;
      xOffset = 0;
    }
    var bBidi = dvt.Agent.isRightToLeft(this._context);
    if (bBidi) {
      xOffset = -xOffset - tooltipBounds.w;
    }

    return new dvt.Point(xOffset, yOffset);
  }
};


/**
 * Returns an approximation of the tooltip bounds.
 * @return {dvt.Rectangle}
 */
dvt.HtmlTooltipManager.prototype.getTooltipBounds = function()
{
  var tooltip = this.getTooltipElem();

  // Fix for 17898759: The offset height can be incorrect if the tooltip div inherits from the HTML body.  Set to auto
  // temporarily to prevent this.
  tooltip.style.height = 'auto';
  return new dvt.Rectangle(parseInt(tooltip.style.left), parseInt(tooltip.style.top), tooltip.offsetWidth, tooltip.offsetHeight);
};


/**
 * Positions the tip based on the mouse position in relation to the tooltip size.
 * @param {number} x The coordinate at which to display the tooltip with offsets.
 * @param {number} y The coordinate at which to display the tooltip with offsets.
 */
dvt.HtmlTooltipManager.prototype.positionTip = function(x, y)
{
  var tooltip = this.getTooltipElem();
  var tooltipDimensions = this.getTooltipBounds();
  var tooltipWidth = tooltipDimensions.w;
  var tooltipHeight = tooltipDimensions.h;

  // Calculate the bounds of the browser viewport, within which we'll position the tooltip
  var viewportBounds = new dvt.Rectangle(window.pageXOffset + dvt.HtmlTooltipManager._VIEWPORT_BUFFER,
      window.pageYOffset + dvt.HtmlTooltipManager._VIEWPORT_BUFFER,
      window.innerWidth - 2 * dvt.HtmlTooltipManager._VIEWPORT_BUFFER,
      window.innerHeight - 2 * dvt.HtmlTooltipManager._VIEWPORT_BUFFER);

  // X Position
  var tooltipX = x;
  if (x + tooltipWidth > viewportBounds.x + viewportBounds.w)
    tooltipX = viewportBounds.x + viewportBounds.w - tooltipWidth;
  if (tooltipX < viewportBounds.x)
    tooltipX = viewportBounds.x;


  // If page is scrolled, force a width on the tooltip so that it doesn't crunch at the edges. Workaround for browser issue.
  if (Math.abs(viewportBounds.x) > dvt.HtmlTooltipManager._VIEWPORT_BUFFER) {
    tooltip.style.width = Math.min(tooltip.clientWidth, viewportBounds.x + viewportBounds.w - tooltipX) + 'px';
    y += (tooltipHeight - tooltip.offsetHeight); // update y location
    tooltipHeight = tooltip.offsetHeight; // update height
    tooltip.style.overflow = 'hidden';
  }

  // Y Position
  var tooltipY = y;
  if (y + tooltipHeight > viewportBounds.y + viewportBounds.h)
    tooltipY = viewportBounds.y + viewportBounds.h - tooltipHeight;
  if (tooltipY < viewportBounds.y)
    tooltipY = viewportBounds.y;

  // Apply the calculated positions
  tooltip.style.left = tooltipX + 'px';
  tooltip.style.top = tooltipY + 'px';
};


/**
 * Returns a custom tooltip based on the tooltip function and the data context.
 * @param {function} tooltipFunc
 * @param {object} dataContext
 * @return {object} The custom tooltip, which is either a string or a DOM element.
 */
dvt.HtmlTooltipManager.prototype.getCustomTooltip = function(tooltipFunc, dataContext) {
  var tooltipElem = this.getTooltipElem();

  // Clearing out the previous tooltip content in case the app wants to modify the tooltip element themselves
  while (tooltipElem.hasChildNodes())
    tooltipElem.removeChild(tooltipElem.firstChild);

  dataContext['parentElement'] = tooltipElem;

  // reset class and border color each time so that we can tell if the user specifies custom ones ( + 21150376)
  tooltipElem.className = '';
  tooltipElem.style.borderColor = '';

  var tooltip = tooltipFunc(dataContext);

  // if custom class or border color are specified, set flags so we don't override them with the default values
  if (tooltipElem.className)
    this._isCustomClassName = true;

  if (tooltipElem.style.borderColor)
    this._isCustomBorderColor = true;

  // If the tooltipElem has been populated by the app and a null returned, don't overwrite it.
  if (!tooltip && tooltipElem.hasChildNodes())
    return true;

  return tooltip;
};


/**
 * Restores a supported HTML tag.
 * All HTML brackets are converted into &gt; and &lt; for security reasons, to prevent people from adding unsupported
 * elements. This method restores the brackets for the supported element only.
 * @param {string} text The HTML string.
 * @param {string} tag The tag name to be restored.
 * @return {string} The updated HTML string.
 * @private
 */
dvt.HtmlTooltipManager._restoreTag = function(text, tag) {
  // Match the following: <tag...>, </tag...>, and <tag.../>
  var regExp = new RegExp('&lt;(\/?)' + tag + '([^&]*)(\/?)&gt;', 'g');
  return text.replace(regExp, '<$1' + tag + '$2$3>');
};


/**
 * Creates an HTML start tag with the specified tag name and inline style.
 * @param {string} tag Tag name.
 * @param {dvt.CSSStyle} style CSS style to be added as the inline style.
 * @return {string} The HTML start tag.
 */
dvt.HtmlTooltipManager.createStartTag = function(tag, style) {
  return ('<' + tag + ' style=\"' + style.toString() + '\">');
};
/**
 * Utility class for providing keyboard listeners to add to HTML divs
 * @class dvt.HtmlKeyboardListenerUtils
 */
dvt.HtmlKeyboardListenerUtils = function() {};

dvt.Obj.createSubclass(dvt.HtmlKeyboardListenerUtils, dvt.Obj);


//: for editable DvtText, ignore events from the HTML textArea
/**
 * Field to look for on event target to see if events from that target should be ignored.
 */
dvt.HtmlKeyboardListenerUtils.ATTR_IGNORE_EVENTS_FROM_TARGET = '_dvtIgnoreEventsFromTarget';


/**
 * @param {Boolean} useCapture True if the listener is to be used in the event capture phase,
 *                             false if the listener is to be used in the event bubble phase
 * @return {function} A function that can be used as an event listener during the bubble or capture phase
 */
dvt.HtmlKeyboardListenerUtils.getListener = function(useCapture)
{
  if (useCapture)
    return dvt.HtmlKeyboardListenerUtils._captureListener;
  else
    return dvt.HtmlKeyboardListenerUtils._bubbleListener;
};


/**
 * The event listener that is called by the implementation object's bubble phase listeners.
 * This function will wrap the event and delegate to the real event listeners.
 * @param {object} event the DOM event object
 * @this {object} the platform object actively processing the event object with an event listener
 * @private
 */
dvt.HtmlKeyboardListenerUtils._bubbleListener = function(event)
{
  //: for editable DvtText, ignore events from the HTML textArea
  if (dvt.HtmlKeyboardListenerUtils._checkIgnoreTarget(event)) {
    return;
  }

  var dvtEvent;
  if (this._currentObj) { // fire to the current listener only
    dvtEvent = dvt.DomEventFactory.newEvent(event, this._currentObj.getObj().getCtx());
    this._currentObj.getObj().FireListener(dvtEvent, false);
  }
  else if (this._obj && this._obj instanceof Array) { // fire to all listeners
    var i;
    var svgObj;
    var length = this._obj.length;
    for (i = 0; i < length; i++) {
      svgObj = this._obj[i];
      dvtEvent = dvt.DomEventFactory.newEvent(event, svgObj.getObj().getCtx());
      svgObj.getObj().FireListener(dvtEvent, false);
    }
  }
};


/**
 * The event listener that is called by the implementation object's capture phase listeners.
 * This function will wrap the event and delegate to the real event listeners.
 * @param {object} event the DOM event object
 * @this {object} the platform object actively processing the event object with an event listener
 * @private
 */
dvt.HtmlKeyboardListenerUtils._captureListener = function(event)
{
  //: for editable DvtText, ignore events from the HTML textArea
  if (dvt.HtmlKeyboardListenerUtils._checkIgnoreTarget(event)) {
    return;
  }

  var dvtEvent;
  if (this._currentObj) { // fire to the current listener only
    dvtEvent = dvt.DomEventFactory.newEvent(event, this._currentObj.getObj().getCtx());
    this._currentObj.getObj().FireListener(dvtEvent, true);
  }
  if (this._obj && this._obj instanceof Array) { // fire to all listeners
    var i;
    var svgObj;
    var length = this._obj.length;
    for (i = 0; i < length; i++) {
      svgObj = this._obj[i];
      dvtEvent = dvt.DomEventFactory.newEvent(event, svgObj.getObj().getCtx());
      svgObj.getObj().FireListener(dvtEvent, true);
    }
  }
};


/**
 * Check whether the event should be ignored by the toolkit.
 * @param {object} event the DOM event object
 * @return {boolean}
 * @private
 */
dvt.HtmlKeyboardListenerUtils._checkIgnoreTarget = function(event) {
  //: for editable DvtText, ignore events from the HTML textArea
  if (event && event.target && event.target[dvt.HtmlKeyboardListenerUtils.ATTR_IGNORE_EVENTS_FROM_TARGET]) {
    return true;
  }
  return false;
};
/**
 * Wrapper class providing XML parsing functionality using the DOM.
 * @class DvtDomXmlParser
 * @extends {dvt.XmlParser}
 * @constructor
 */
var DvtDomXmlParser = function() {
  this._parser = new DOMParser();
};

dvt.Obj.createSubclass(DvtDomXmlParser, dvt.Obj);


/**
 * Parses the XML string and returns the root node.
 * @param {string} xmlString the XML string to parse
 * @return {dvt.DomXmlNode} the root node of the XML document
 */
DvtDomXmlParser.prototype.parse = function(xmlString) {
  var xmlDoc = this._parser.parseFromString(xmlString, 'text/xml');
  var root = xmlDoc.documentElement;
  return new dvt.DomXmlNode(root);
};
/**
 * Wrapper class providing access to DOM XML Nodes.
 * @extends {dvt.XmlNode}
 * @class dvt.DomXmlNode
 * @constructor
 * @param {Node} node the DOM Node object
 */
dvt.DomXmlNode = function(node) {
  this._node = node;
};

// Make dvt.DomXmlNode a subclass of dvt.XmlNode
dvt.Obj.createSubclass(dvt.DomXmlNode, dvt.XmlNode);


/**
 * @override
 */
dvt.DomXmlNode.prototype.getAttr = function(attr) {
  return this._node.getAttribute(attr);
};


/**
 * @override
 */
dvt.DomXmlNode.prototype.getChildNodes = function() {
  var ret = new Array();

  // Loop through the children of this node.
  // Note: Using nextSibling because w3schools.com says it's faster than
  //       childNodes for looping through the children.
  var child = this._node.firstChild;
  while (child != null) {
    if (child.nodeType == 1) // Element
      ret.push(new dvt.DomXmlNode(child));

    child = child.nextSibling;
  }

  return ret;
};


/**
  * @override
  */
dvt.DomXmlNode.prototype.getName = function() {
  return this._node.nodeName;
};


/**
  * @override
  */
dvt.DomXmlNode.prototype.getAttributes = function() {
  var array = [];
  var numAttrs = this._node.attributes.length;
  for (var i = 0; i < numAttrs; i++)
  {
    var attr = this._node.attributes[i];
    if (attr.name && typeof attr.value != 'undefined' && attr.value != null)
    {
      array.push({name: attr.name, value: attr.value});
    }
  }
  return array;
};


/**
 * @override
 * @return {array} an Array containing all child elements and text nodes of this node.
 */
dvt.DomXmlNode.prototype.getAllChildNodes = function() {
  var ret = new Array();

  // Loop through the children of this node.
  // Note: Using nextSibling because w3schools.com says it's faster than
  //       childNodes for looping through the children.
  var child = this._node.firstChild;
  while (child != null) {
    ret.push(new dvt.DomXmlNode(child));
    child = child.nextSibling;
  }

  return ret;
};


/**
  * @override
  */
dvt.DomXmlNode.prototype.getNodeValue = function() {
  return this._node.nodeValue;
};


/**
  * @override
  */
dvt.DomXmlNode.prototype.getTextContent = function() {
  return this._node.textContent;
};


/**
  * @override
  */
dvt.DomXmlNode.prototype.getElementsByTagName = function(name) {
  var ret = [];
  var nodes = this._node.getElementsByTagName(name);
  if (nodes) {
    for (var i = 0; i < nodes.length; i++) {
      ret.push(new dvt.DomXmlNode(nodes[i]));
    }
  }
  return ret;
};

/**
 * Factory class for component events to be fired to framework layers. Any changes to existing event payloads requires
 * search and update in the shared JS and all framework layers.
 */
dvt.EventFactory = new Object();

dvt.Obj.createSubclass(dvt.EventFactory, dvt.Obj);

/**
 * Creates and returns an event object with the specified type. All events are represented as JSON objects.
 * @param {string} type The event type.
 * @param {string=} id The id of the event target, if applicable.
 * @return {object}
 */
dvt.EventFactory.newEvent = function(type, id) {
  var ret = {'type': type};

  // Add the id if one was specified
  if (id)
    ret['id'] = id;

  return ret;
};

/**
 * A generic option change event. This should be considered whenever a new event is added. The JET layer will
 * handle this event by updating the specified key in the options. If the specified key is private, such as '_key', then
 * the options will be updated without triggering an option change event.
 * @param {string} key The name of the option to set.
 * @param {Object} value The value to set for the option.
 * @param {Object} optionMetadata (optional) The option metadata for the event.
 * @return {object}
 */
dvt.EventFactory.newOptionChangeEvent = function(key, value, optionMetadata) {
  var ret = dvt.EventFactory.newEvent('optionChange');
  ret['key'] = key;
  ret['value'] = value;
  ret['optionMetadata'] = optionMetadata;
  return ret;
};

/**
 * A generic property change event for ADF. The ADF layer will handle this event by setting the specified key on the
 * client component. The component peers can override this default behavior. Events impacting JET should use the
 * optionChange event instead. Properties will be stored on a 'properties' object on the event.
 * @param {string=} key Optional key for a property change.
 * @param {object=} value Optional value for a property change.
 * @return {object}
 */
dvt.EventFactory.newAdfPropertyChangeEvent = function(key, value) {
  // TODO: This should be moved into the ADF specific events section once the NBox JET usages are updated.
  var ret = dvt.EventFactory.newEvent('adfPropertyChange');
  ret['properties'] = {};

  if (key != null)
    ret['properties'][key] = value;

  return ret;
};

//***************************** ADF Specific Events **************************/

/**
 * @param {object} nativeEvent The native event that triggered the context menu.
 * @param {string} menuId The client id of the context menu that is being requested.
 * @return {object}
 */
dvt.EventFactory.newAdfContextMenuEvent = function(nativeEvent, menuId) {
  var ret = dvt.EventFactory.newEvent('adfContextMenu');
  ret['nativeEvent'] = nativeEvent;
  ret['menuId'] = menuId;
  return ret;
};

/**
 * @param {string} popupId The id of the popup to be hidden.
 * @param {object} relatedTarget The related target of the event that triggered the hide popup event.
 * @return {object}
 */
dvt.EventFactory.newAdfHidePopupEvent = function(popupId, relatedTarget) {
  var ret = dvt.EventFactory.newEvent('adfHidePopup');
  ret['popupId'] = popupId;
  ret['relatedTarget'] = relatedTarget;
  return ret;
};

/**
 * @param {int} level the level of this log event
 * @param {string} message the message to be logged
 * @return {object}
 */
dvt.EventFactory.newAdfLogEvent = function(level, message) {
  var ret = dvt.EventFactory.newEvent('adfLog');
  ret['level'] = level;
  ret['message'] = message;
  return ret;
};

/**
 * @param {dvt.ShowPopupBehavior} showPopupBehavior The showPopupBehavior that was triggered.
 * @param {dvt.Rectangle} launcherBounds The bounding box of the object that triggered the popup,
 *                                      relative to the component's top left coordinates.
 * @param {string} launcherId The component that launched the popup.  This may be different
 *                            than the component that owns the showPopupBehavior.
 * @param {string} triggerType The event that triggered the show popup action.
 * @return {object}
 */
dvt.EventFactory.newAdfShowPopupEvent = function(showPopupBehavior, launcherBounds, launcherId, triggerType) {
  var ret = dvt.EventFactory.newEvent('adfShowPopup');
  ret['showPopupBehavior'] = showPopupBehavior;
  ret['launcherBounds'] = launcherBounds;
  ret['launcherId'] = launcherId;
  ret['triggerType'] = triggerType;
  return ret;
};

//***************************** Common Events ********************************/

/**
 * @param {string} subType
 * @param {string} commandId
 * @param {string} clientId
 * @return {object}
 */
dvt.EventFactory.newActionEvent = function(subType, commandId, clientId) {
  // TODO: Aside from diagram, subtype is only used for setAnchor.
  var ret = dvt.EventFactory.newEvent('action');
  ret['commandId'] = commandId;
  ret['clientId'] = clientId;
  ret['subType'] = subType;
  return ret;
};

/**
 * @param {string} category
 * @param {array} hiddenCategories The array of all currently hidden categories
 * @return {object}
 */
dvt.EventFactory.newCategoryHideEvent = function(category, hiddenCategories) {
  var ret = dvt.EventFactory.newEvent('categoryHide');
  ret['category'] = category;
  ret['hiddenCategories'] = hiddenCategories;
  return ret;
};

/**
 * @param {string} category
 * @param {array} hiddenCategories The array of all currently hidden categories
 * @return {object}
 */
dvt.EventFactory.newCategoryShowEvent = function(category, hiddenCategories) {
  var ret = dvt.EventFactory.newEvent('categoryShow');
  ret['category'] = category;
  ret['hiddenCategories'] = hiddenCategories;
  return ret;
};

/**
 * @param {object} categories The category or array of categories that are the target of the event.
 * @param {boolean} bOver
 * @return {object}
 */
dvt.EventFactory.newCategoryHighlightEvent = function(categories, bOver) {
  var ret = dvt.EventFactory.newEvent('categoryHighlight');

  // Private property for use within the toolkit.
  ret['_highlightType'] = bOver ? 'over' : 'out';

  // Ensure that the categories is an array for easy uptake
  categories = categories || [];
  ret['categories'] = !(categories instanceof Array) ? [categories] : categories;

  // Create the option change event
  return ret;
};

/**
 * @param {string} id The id of the target.
 * @return {object}
 */
dvt.EventFactory.newDrillEvent = function(id) {
  return dvt.EventFactory.newEvent('drill', id);
};

/**
 * @return {object}
 */
dvt.EventFactory.newReadyEvent = function() {
  return dvt.EventFactory.newEvent('ready');
};

/**
 * @param {array} selection
 * @return {object}
 */
dvt.EventFactory.newSelectionEvent = function(selection) {
  var ret = dvt.EventFactory.newEvent('selection');
  ret['selection'] = selection;
  return ret;
};

/**
 * @param {object} nativeEvent
 * @return {object}
 */
dvt.EventFactory.newTouchHoldReleaseEvent = function(nativeEvent) {
  var ret = dvt.EventFactory.newEvent('touchHoldRelease');
  ret['nativeEvent'] = nativeEvent;
  return ret;
};

/**
 * @param {number} oldValue
 * @param {number} newValue
 * @param {boolean} bComplete true if the interaction is complete.
 * @return {object}
 */
dvt.EventFactory.newValueChangeEvent = function(oldValue, newValue, bComplete) {
  var ret = dvt.EventFactory.newEvent('valueChange');
  ret['oldValue'] = oldValue;
  ret['newValue'] = newValue;
  ret['complete'] = bComplete;
  return ret;
};

//************************ Component Specific Events *************************/

/**
 * @param {string} id The id of the target.
 * @param {string} series The series of the target.
 * @param {string} group The group of the target.
 * @return {object}
 */
dvt.EventFactory.newChartDrillEvent = function(id, series, group) {
  var ret = dvt.EventFactory.newDrillEvent(id);
  ret['series'] = series;
  ret['group'] = group;
  return ret;
};

/**
 * @param {array} selection The array of currently selected ids for the component.
 * @param {boolean} bComplete true if the interaction is complete.
 * @param {number=} xMin The xMin of the marquee bounds (only applies to marquee selection).
 * @param {number=} xMax The xMax of the marquee bounds (only applies to marquee selection).
 * @param {string=} startGroup The first group that is included in the bounds (only applies to marquee selection).
 * @param {string=} endGroup The last group that is included in the bounds (only applies to marquee selection).
 * @param {number=} yMin The yMin of the marquee bounds (only applies to marquee selection).
 * @param {number=} yMax The yMax of the marquee bounds (only applies to marquee selection).
 * @param {number=} y2Min The y2Min of the marquee bounds (only applies to marquee selection).
 * @param {number=} y2Max The y2Max of the marquee bounds (only applies to marquee selection).
 * @return {object}
 */
dvt.EventFactory.newChartSelectionEvent = function(selection, bComplete, xMin, xMax, startGroup, endGroup, yMin, yMax, y2Min, y2Max) {
  var ret = dvt.EventFactory.newSelectionEvent(selection);
  ret['complete'] = bComplete;
  ret['xMin'] = xMin;
  ret['xMax'] = xMax;
  ret['startGroup'] = startGroup;
  ret['endGroup'] = endGroup;
  ret['yMin'] = yMin;
  ret['yMax'] = yMax;
  ret['y2Min'] = y2Min;
  ret['y2Max'] = y2Max;
  return ret;
};

/**
 * @param {boolean} bComplete true if the interaction is complete.
 * @param {number=} xMin The xMin of the viewport.
 * @param {number=} xMax The xMax of the viewport.
 * @param {string=} startGroup The first group that is included in the viewport.
 * @param {string=} endGroup The last group that is included in the viewport.
 * @param {number=} yMin The yMin of the viewport.
 * @param {number=} yMax The yMax of the viewport.
 * @return {object}
 */
dvt.EventFactory.newChartViewportChangeEvent = function(bComplete, xMin, xMax, startGroup, endGroup, yMin, yMax) {
  var ret = dvt.EventFactory.newEvent('viewportChange');
  ret['complete'] = bComplete;
  ret['xMin'] = xMin;
  ret['xMax'] = xMax;
  ret['startGroup'] = startGroup;
  ret['endGroup'] = endGroup;
  ret['yMin'] = yMin;
  ret['yMax'] = yMax;
  return ret;
};

/**
 * @param {string} id The id of the node.
 * @return {object}
 */
dvt.EventFactory.newSunburstCollapseEvent = function(id) {
  return dvt.EventFactory.newEvent('collapse', id);
};

/**
 * @param {string} id The id of the node.
 * @return {object}
 */
dvt.EventFactory.newSunburstExpandEvent = function(id) {
  return dvt.EventFactory.newEvent('expand', id);
};

/**
 * @param {number} startAngle The start angle of the sunburst, in degrees.
 * @param {boolean} bComplete true if the interaction is complete.
 * @return {object}
 */
dvt.EventFactory.newSunburstRotationEvent = function(startAngle, bComplete) {
  var ret = dvt.EventFactory.newEvent('rotation');
  ret['complete'] = bComplete;

  // Adjust the angle so that it's always between 0 and 360
  ret['startAngle'] = startAngle % 360;
  return ret;
};

/**
 * @param {number} panX
 * @param {number} panY
 * @param {number} zoom
 * @return {object}
 **/
dvt.EventFactory.newThematicMapViewportChangeEvent = function(panX, panY, zoom) {
  var ret = dvt.EventFactory.newEvent('viewportChange');
  ret['panX'] = panX;
  ret['panY'] = panY;
  ret['zoom'] = zoom;
  return ret;
};

/**
 * @param {number} viewportStart The start value of the viewport.
 * @param {number} viewportEnd The end value of the viewport.
 * @param {string} minorAxisScale The scale value of the minor axis.
 * @return {object}
 **/
dvt.EventFactory.newTimelineViewportChangeEvent = function(viewportStart, viewportEnd, minorAxisScale) {
  var ret = dvt.EventFactory.newEvent('viewportChange');
  ret['viewportStart'] = viewportStart;
  ret['viewportEnd'] = viewportEnd;
  ret['minorAxisScale'] = minorAxisScale;
  return ret;
};

/**
 * @param {string} id The id of the currently isolated node.
 * @return {object}
 */
dvt.EventFactory.newTreemapIsolateEvent = function(id) {
  return dvt.EventFactory.newEvent('isolate', id);
};
/**
 * A component client behavior event.
 * @param {dvt.ClientBehavior} clientHeavior The clientBehavior that was triggered.
 *
 * @class
 * @constructor
 */
dvt.ClientBehaviorEvent = function(clientBehavior) {
  this.Init(dvt.ClientBehaviorEvent.TYPE);
  this._clientBehavior = clientBehavior;
};

dvt.Obj.createSubclass(dvt.ClientBehaviorEvent, dvt.BaseComponentEvent);

// TODO NAMESPACE: THIS MAY ONLY BE USED IN ADF DIAGRAM

/**
 * @const
 */
dvt.ClientBehaviorEvent.TYPE = 'clientBehavior';


/**
 * Returns the clientBehavior that was triggered.
 * @return {dvt.ClientBehavior} The clientBehavior that was triggered.
 */
dvt.ClientBehaviorEvent.prototype.getClientBehavior = function() {
  return this._clientBehavior;
};
/**
 * A pan event.
 * @param {string}  subType  subtype of the event; one of the constants
 *        defined in this class
 * @param {number}  newX  new x-coord
 * @param {number}  newY  new y-coord
 * @param {number}  oldX  old x-coord
 * @param {number}  oldY  old y-coord
 * @param {dvt.Animator}  animator  optional animator used to animate the zoom
 * @class
 * @constructor
 */
dvt.PanEvent = function(subType, newX, newY, oldX, oldY, animator) {
  this.Init(dvt.PanEvent.TYPE);
  this.type = this.getType();
  this._subtype = subType;
  this._newX = newX;
  this._newY = newY;
  this._oldX = oldX;
  this._oldY = oldY;
  this._animator = animator;
};

dvt.Obj.createSubclass(dvt.PanEvent, dvt.BaseComponentEvent);

dvt.PanEvent.TYPE = 'dvtPan';

dvt.PanEvent.SUBTYPE_DRAG_PAN_BEGIN = 'dragPanBegin';
dvt.PanEvent.SUBTYPE_DRAG_PAN_END = 'dragPanEnd';
dvt.PanEvent.SUBTYPE_PANNED = 'panned';
dvt.PanEvent.SUBTYPE_PANNING = 'panning';
dvt.PanEvent.SUBTYPE_ELASTIC_ANIM_BEGIN = 'elasticAnimBegin';
dvt.PanEvent.SUBTYPE_ELASTIC_ANIM_END = 'elasticAnimEnd';


/**
 *
 */
dvt.PanEvent.prototype.getSubType = function() {
  return this._subtype;
};


/**
 *
 */
dvt.PanEvent.prototype.getNewX = function() {
  return this._newX;
};


/**
 *
 */
dvt.PanEvent.prototype.getNewY = function() {
  return this._newY;
};


/**
 *
 */
dvt.PanEvent.prototype.getOldX = function() {
  return this._oldX;
};


/**
 *
 */
dvt.PanEvent.prototype.getOldY = function() {
  return this._oldY;
};


/**
 *
 */
dvt.PanEvent.prototype.getAnimator = function() {
  return this._animator;
};
/**
 * A zoom event.
 * @param {string}  subType  subtype of the event; one of the constants
 *        defined in this class
 * @param {number}  newZoom  new zoom factor
 * @param {number}  oldZoom  old zoom factor
 * @param {dvt.Animator}  animator  optional animator used to animate the zoom
 * @param {dvt.Rectangle}  zoomToFitBounds  bounds to use for zoom-to-fit
 * @param {dvt.Point}  centerPoint  center of zoom
 * @param {number}  tx  the horizontal translation applied after the zoom
 * @param {number}  ty  the vertical translation applied after the zoom
 * @class
 * @constructor
 */
dvt.ZoomEvent = function(subType, newZoom, oldZoom, animator, zoomToFitBounds, centerPoint, tx, ty) {
  this.Init(dvt.ZoomEvent.TYPE);
  this.type = this.getType();
  this._subtype = subType;
  this._newZoom = newZoom;
  this._oldZoom = oldZoom;
  this._animator = animator;
  this._zoomToFitBounds = zoomToFitBounds;
  this._centerPoint = centerPoint;
  this._tx = tx;
  this._ty = ty;
};

dvt.Obj.createSubclass(dvt.ZoomEvent, dvt.BaseComponentEvent);

dvt.ZoomEvent.TYPE = 'dvtZoom';


/**
 * Zoomed event - component might need to rerender on this event
 * @const
 */
dvt.ZoomEvent.SUBTYPE_ZOOMED = 'zoomed';


/**
 * Zooming event - used to notify a component of zooming event
 * @const
 */
dvt.ZoomEvent.SUBTYPE_ZOOMING = 'zooming';


/**
 * ZoomEnd event - it is the end of the zoom event. The difference between "zoomed" and "zoomEnd" is on touch device.
 * A component gets "zoomed" events for appropriate "touchmove" events. When all touches are released on "touchend"  the component will get "zoomEnd" notification.
 * @const
 */
dvt.ZoomEvent.SUBTYPE_ZOOM_END = 'zoomEnd';
dvt.ZoomEvent.SUBTYPE_DRAG_ZOOM_BEGIN = 'dragZoomBegin';
dvt.ZoomEvent.SUBTYPE_DRAG_ZOOM_END = 'dragZoomEnd';
dvt.ZoomEvent.SUBTYPE_ZOOM_AND_CENTER = 'zoomAndCenter';
dvt.ZoomEvent.SUBTYPE_ZOOM_TO_FIT_CALC_BOUNDS = 'zoomToFitCalcBounds';
dvt.ZoomEvent.SUBTYPE_ZOOM_TO_FIT_BEGIN = 'zoomToFitBegin';
dvt.ZoomEvent.SUBTYPE_ZOOM_TO_FIT_END = 'zoomToFitEnd';
dvt.ZoomEvent.SUBTYPE_ELASTIC_ANIM_BEGIN = 'elasticAnimBegin';
dvt.ZoomEvent.SUBTYPE_ELASTIC_ANIM_END = 'elasticAnimEnd';


/**
 * Subtype representing a zoom event fired before the SUBTYPE_ZOOMING event to give components a chance adjust the
 * pan constraints
 *
 * @const
 */
dvt.ZoomEvent.SUBTYPE_ADJUST_PAN_CONSTRAINTS = 'adjustPanConstraints';


/**
 *
 */
dvt.ZoomEvent.prototype.getSubType = function() {
  return this._subtype;
};


/**
 *
 */
dvt.ZoomEvent.prototype.getNewZoom = function() {
  return this._newZoom;
};


/**
 *
 */
dvt.ZoomEvent.prototype.getOldZoom = function() {
  return this._oldZoom;
};


/**
 *
 */
dvt.ZoomEvent.prototype.getAnimator = function() {
  return this._animator;
};


/**
 *
 */
dvt.ZoomEvent.prototype.setZoomToFitBounds = function(bounds) {
  this._zoomToFitBounds = bounds;
};


/**
 *
 */
dvt.ZoomEvent.prototype.getZoomToFitBounds = function() {
  return this._zoomToFitBounds;
};


/**
 *
 */
dvt.ZoomEvent.prototype.getCenterPoint = function() {
  return this._centerPoint;
};


/**
 * Gets the horizontal translation applied after the zoom
 *
 * @return {number} the horizontal translation applied after the zoom
 */
dvt.ZoomEvent.prototype.getTx = function() {
  return this._tx;
};


/**
 * Gets the vertical translation applied after the zoom
 *
 * @return {number} the vertical translation applied after the zoom
 */
dvt.ZoomEvent.prototype.getTy = function() {
  return this._ty;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Utilities for dispatching events.
 * @class
 */
dvt.EventDispatcher = {};

dvt.Obj.createSubclass(dvt.EventDispatcher, dvt.Obj);

/**
 * Dispatches the event to the callback function.
 * @param {object} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object context for the callback function
 * @param {object} component The component firing the event
 * @param {object} event The event to be dispatched.
 * @protected
 */
dvt.EventDispatcher.dispatchEvent = function(callback, callbackObj, component, event) {
  if (callback && callback.call)
    callback.call(callbackObj, event, component);
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.

/**
 * @class
 */
dvt.ToolkitUtils = {};

dvt.Obj.createSubclass(dvt.ToolkitUtils, dvt.Obj);
/** @const **/
dvt.ToolkitUtils.SVG_NS = 'http://www.w3.org/2000/svg';
/** @const **/
dvt.ToolkitUtils.XLINK_NS = 'http://www.w3.org/1999/xlink';


/**
 * Creates and returns a new SVG document with the specified id.
 * @param {string} id The id for the new SVG document.
 * @return {object} A new SVG document.
 */
dvt.ToolkitUtils.createSvgDocument = function(id) {
  var svg = document.createElementNS(dvt.ToolkitUtils.SVG_NS, 'svg');

  if (id != null)
    dvt.ToolkitUtils.setAttrNullNS(svg, 'id', id);

  dvt.ToolkitUtils.setAttrNullNS(svg, 'width', '100%');
  dvt.ToolkitUtils.setAttrNullNS(svg, 'height', '100%');

  //  - IE allows tabbing into svg element
  if (dvt.Agent.isPlatformIE())
    dvt.ToolkitUtils.setAttrNullNS(svg, 'focusable', 'false');
  return svg;
};


/**
 * Returns the drag feedback for the specified objects.
 * @param {object} displayables The dvt.Displayable or array of DvtDisplayables to display for drag feedback.
 * @param {dvt.Displayable} targetCoordinateSpace The displayable defining the coordinate space of the resulting bounds.  The
 *                                               parent coordinate space is used if none is provided.
 * @return {object} An object containing drag feedback information.
 */
dvt.ToolkitUtils.getDragFeedback = function(displayables, targetCoordinateSpace) {
  // Wrap in an array if not already wrapped.
  if (!(displayables instanceof Array)) {
    displayables = [displayables];
  }
  var bounds = dvt.DragAndDropUtils.getDragFeedbackBounds(displayables, targetCoordinateSpace);
  var svg = dvt.ToolkitUtils._getDragFeedbackSVG(displayables, bounds);

  var feedback = new Object();
  feedback.width = bounds.w + dvt.DragSource.DRAG_FEEDBACK_MARGIN * 2;
  feedback.height = bounds.h + dvt.DragSource.DRAG_FEEDBACK_MARGIN * 2;
  if (svg)
    feedback.svg = svg;

  return feedback;
};


/**
 * Returns an svg string representing the drag over feedback.
 * @param {object} displayables The dvt.Displayable or array of DvtDisplayables to display for drag feedback.
 * @param {dvt.Rectangle} bounds The bounds for the drag feedback displayables, used to translate the feedback to 0.
 * @return {string} and svg string representing the drag over feedback
 * @private
 */
dvt.ToolkitUtils._getDragFeedbackSVG = function(displayables, bounds) {
  // : A new svg document must be created programmatically and appended to the wrapping div later on.
  //  This is necessary for Safari 5.0 and earlier, as well as iOS.  innerHTML should not be used.
  var svgElem = dvt.ToolkitUtils.createSvgDocument('dnd');

  // Create a group element to apply the top level translate to show the drag feedback at (0, 0)
  var tx = dvt.DragSource.DRAG_FEEDBACK_MARGIN - bounds.x;
  var ty = dvt.DragSource.DRAG_FEEDBACK_MARGIN - bounds.y;
  var translate = 'translate(' + tx + ',' + ty + ')';
  var container = dvt.SvgShapeUtils.createElement('g');
  dvt.ToolkitUtils.setAttrNullNS(container, 'transform', translate);
  dvt.ToolkitUtils.appendChildElem(svgElem, container);

  // Loop through and add the displayables
  for (var i = 0; i < displayables.length; i++) {

    var src = displayables[i];
    // Clone the selected node and add
    var elem = src.getImpl().getElem();
    var clone = elem.cloneNode(true);

    // Remove filters if present, since these effects overflow the bounds and look broken
    if (dvt.ToolkitUtils.getAttrNullNS(clone, 'filter'))
      dvt.ToolkitUtils.setAttrNullNS(clone, 'filter', null);

    var cloneContainer = dvt.SvgShapeUtils.createElement('g');
    dvt.ToolkitUtils.appendChildElem(container, cloneContainer);
    var pathToStage = src.getPathToStage();
    var mat = null;
    for (var j = 1; j < pathToStage.length; j++) {
      if (!mat)
        mat = pathToStage[j].getMatrix();
      else {
        mat = mat.clone();
        mat.concat(pathToStage[j].getMatrix());
      }
    }
    if (mat) {
      var sMat = 'matrix(' + mat.getA() + ',' + mat.getC() + ',' + mat.getB() + ',' + mat.getD() + ',' + mat.getTx() + ',' + mat.getTy() + ')';
      dvt.ToolkitUtils.setAttrNullNS(cloneContainer, 'transform', sMat);
    }
    dvt.ToolkitUtils.appendChildElem(cloneContainer, clone);
  }

  return svgElem;
};


/**
 * Add an event listener to a DOM element.
 * @param {object} elem DOM element
 * @param {string} type type of event
 * @param {function} listener the listener function
 * @param {boolean} useCapture true if the listener operates in the capture phase, false otherwise
 */
dvt.ToolkitUtils.addDomEventListener = function(elem, type, listener, useCapture) {
  if (elem && elem.addEventListener) {
    elem.addEventListener(type, listener, useCapture);
  }
};


/**
 * Remove an event listener from a DOM element.
 * @param {object} elem DOM element
 * @param {string} type type of event
 * @param {function} listener the listener function
 * @param {boolean} useCapture true if the listener operates in the capture phase, false otherwise
 */
dvt.ToolkitUtils.removeDomEventListener = function(elem, type, listener, useCapture) {
  if (elem && elem.removeEventListener) {
    elem.removeEventListener(type, listener, useCapture);
  }
};


/**
 * Wrapper for appendChild method
 * @param {object} parent DOM element
 * @param {object} child DOM element added to parent
 * @return {object} the appended element (child)
 */
dvt.ToolkitUtils.appendChildElem = function(parent, child) {
  return parent.appendChild(child);//@HTMLUpdateOk
};


/**
 * Wrapper for getAttributeNS method
 * @param {object} elem DOM element
 * @param {string} namespace Namespace to use
 * @param {string} name Attribute name to get
 * @return {string} Value associated with given name
 */
dvt.ToolkitUtils.getAttrNS = function(elem, namespace, name) {
  return elem.getAttributeNS(namespace, name);
};


/**
 * Wrapper for getAttributeNS method
 * @param {object} elem DOM element
 * @param {string} name Attribute name to get
 * @return {string} Value associated with given name
 */
dvt.ToolkitUtils.getAttrNullNS = function(elem, name) {
  return elem.getAttributeNS(null, name);
};


/**
 * Wrapper for hasAttributeNS method
 * @param {object} elem DOM element
 * @param {string} namespace The namespace of the attribute.
 * @param {string} name the name of the attribute.
 * @return {boolean} true if the element has the specified attribute.
 */
dvt.ToolkitUtils.hasAttrNS = function(elem, namespace, name) {
  return elem.hasAttributeNS(namespace, name);
};


/**
 * Wrapper for hasAttributeNS method
 * @param {object} elem DOM element
 * @param {string} name the name of the attribute.
 * @return {boolean} true if the element has the specified attribute.
 */
dvt.ToolkitUtils.hasAttrNullNS = function(elem, name) {
  return dvt.ToolkitUtils.hasAttrNS(elem, null, name);
};


/**
 * Wrapper for setAttributeNS method.  When the value of the attribute matches the default value, the DOM will not be
 * updated unless the attribute has already been set to a different value.
 * @param {object} elem DOM element
 * @param {string} namespace The namespace of the attribute.
 * @param {string} name the name of the attribute.
 * @param {string} value The value of the attribute.
 * @param {string=} defaultValue The default value of the attribute, which can be provided to optimize performance.
 */
dvt.ToolkitUtils.setAttrNS = function(elem, namespace, name, value, defaultValue) {
  // Note: We're not strict about value or defaultValue being String types, since browser implementations are not. The
  //       code in this function should always assume that users may pass objects that would be converted to Strings.

  // If defaultValue specified and value matches default, optimize the DOM calls
  // removeAttrNS fails for IE9 and IE10 and x,y attributes of text elements in Chrome version 34, so exclude it here. (when not in test environment)
  if (defaultValue != null && value == defaultValue) {
    if (dvt.ToolkitUtils.hasAttrNS(elem, namespace, name)) {
      if ((dvt.Agent.isPlatformIE() && dvt.Agent.getVersion() <= 10) || (dvt.Agent.isBrowserChrome() && !dvt.Agent.isEnvironmentTest() && dvt.Agent.getVersion() >= 34 && elem.nodeName == 'text' && (name == 'x' || name == 'y')))
        elem.setAttributeNS(namespace, name, value);
      else
        dvt.ToolkitUtils.removeAttrNS(elem, namespace, name);
    }
    return;
  }

  // Otherwise set the attribute
  elem.setAttributeNS(namespace, name, value);
};


/**
 * Wrapper for setAttributeNS method.  When the value of the attribute matches the default value, the DOM will not be
 * updated unless the attribute has already been set to a different value.
 * @param {object} elem DOM element
 * @param {string} name the name of the attribute.
 * @param {string} value The value of the attribute.
 * @param {string=} defaultValue The default value of the attribute, which can be provided to optimize performance.
 */
dvt.ToolkitUtils.setAttrNullNS = function(elem, name, value, defaultValue) {
  dvt.ToolkitUtils.setAttrNS(elem, null, name, value, defaultValue);
};


/**
 * Remove an attribute from a DOM element.
 * @param {object} elem DOM element
 * @param {string} namespace Namespace to use
 * @param {string} name Attribute name to remove
 */
dvt.ToolkitUtils.removeAttrNS = function(elem, namespace, name) {
  //  This might be an over-optimization, but we know that hasAttrNS is cheap
  if (dvt.ToolkitUtils.hasAttrNS(elem, namespace, name))
    elem.removeAttributeNS(namespace, name);
};


/**
 * Remove an attribute from a DOM element, using a null namespace.
 * @param {object} elem DOM element
 * @param {string} name Attribute name to remove
 */
dvt.ToolkitUtils.removeAttrNullNS = function(elem, name) {
  dvt.ToolkitUtils.removeAttrNS(elem, null, name);
};

/**
 * Get a pseudo link callback that loads a document into the existing or a new window.
 * The callback can be used as an onclick callback for dvt.Button.
 * @param {string} target a target frame or a name of the window for the link
 * @param {string} dest a URL to be loaded for the link
 * @return {function} callback function
 */
dvt.ToolkitUtils.getLinkCallback = function(target, dest) {
  if ((target || dest)) {
    var callback = function() {
      if (target == null) {
        self.location = dest;
      }
      else {
        var newWindow = window.open(dest, target);
        if (newWindow)
          newWindow.focus();
      }
    };
    return callback;
  }
  return null;
};

/**
 * Rounds decimal values to the 3rd decimal for junit tests
 * @param {number} value The value to round
 * @return {number}
 */
dvt.ToolkitUtils.roundDecimal = function(value) {
  if (dvt.Agent.isEnvironmentTest())
    return Math.round(value * 1000) / 1000;
  else
    return value;
};

/**
 * Constructs a URL attribute value based on the ID in the SVG definition.
 * @param {string} id The ID in the SVG definition.
 * @return {string} URL attribute value.
 */
dvt.ToolkitUtils.getUrlById = function(id) {
  // If <base> is defined on the document, we have to use the full URL.
  // document.baseURI is not supported in IE, so we have to check if the <base> tag exists in the document.
  var hasBase = dvt.Agent.isPlatformIE() ? document.querySelector('base') != null : document.URL != document.baseURI;
  var root = hasBase ? document.URL + '#' : '#';
  return 'url(' + root + id + ')';
};

/**
 * Sets the width and height of the component SVG.
 * @param {dvt.Context} context
 * @param {number} width
 * @param {number} height
 */
dvt.ToolkitUtils.setSvgSize = function(context, width, height) {
  var svg = context.getSvgDocument();
  dvt.ToolkitUtils.setAttrNullNS(svg, 'width', width + 'px');
  dvt.ToolkitUtils.setAttrNullNS(svg, 'height', height + 'px');
};

/**
 * Returns the width and height of the component outer div.
 * @param {dvt.Context} context
 * @return {dvt.Dimension}
 */
dvt.ToolkitUtils.getOuterDivSize = function(context) {
  var outerDiv = context.getSvgDocument().parentNode;
  var computedStyle = window.getComputedStyle(outerDiv);
  return new dvt.Dimension(parseFloat(computedStyle.width), parseFloat(computedStyle.height));
};


dvt.Bundle.addDefaultStrings(dvt.Bundle.UTIL_PREFIX, {
  'SCALING_SUFFIX_THOUSAND': 'K',
  'SCALING_SUFFIX_MILLION': 'M',
  'SCALING_SUFFIX_BILLION': 'B',
  'SCALING_SUFFIX_TRILLION': 'T',
  'SCALING_SUFFIX_QUADRILLION': 'Q',

  'NUMBER_FORMAT_DECIMAL_SEPARATOR': '.',
  'NUMBER_FORMAT_GROUPING_SEPARATOR': ',',
  'NUMBER_FORMAT_GROUPING_SIZE': 3,

  'MONTH_JANUARY': 'January',
  'MONTH_FEBRUARY': 'February',
  'MONTH_MARCH': 'March',
  'MONTH_APRIL': 'April',
  'MONTH_MAY': 'May',
  'MONTH_JUNE': 'June',
  'MONTH_JULY': 'July',
  'MONTH_AUGUST': 'August',
  'MONTH_SEPTEMBER': 'September',
  'MONTH_OCTOBER': 'October',
  'MONTH_NOVEMBER': 'November',
  'MONTH_DECEMBER': 'December',
  'MONTH_SHORT_JANUARY': 'Jan',
  'MONTH_SHORT_FEBRUARY': 'Feb',
  'MONTH_SHORT_MARCH': 'Mar',
  'MONTH_SHORT_APRIL': 'Apr',
  'MONTH_SHORT_MAY': 'May',
  'MONTH_SHORT_JUNE': 'Jun',
  'MONTH_SHORT_JULY': 'Jul',
  'MONTH_SHORT_AUGUST': 'Aug',
  'MONTH_SHORT_SEPTEMBER': 'Sep',
  'MONTH_SHORT_OCTOBER': 'Oct',
  'MONTH_SHORT_NOVEMBER': 'Nov',
  'MONTH_SHORT_DECEMBER': 'Dec',
  'DAY_MONDAY': 'Monday',
  'DAY_TUESDAY': 'Tuesday',
  'DAY_WEDNESDAY': 'Wednesday',
  'DAY_THURSDAY': 'Thursday',
  'DAY_FRIDAY': 'Friday',
  'DAY_SATURDAY': 'Saturday',
  'DAY_SUNDAY': 'Sunday',
  'DAY_SHORT_MONDAY': 'Mon',
  'DAY_SHORT_TUESDAY': 'Tue',
  'DAY_SHORT_WEDNESDAY': 'Wed',
  'DAY_SHORT_THURSDAY': 'Thu',
  'DAY_SHORT_FRIDAY': 'Fri',
  'DAY_SHORT_SATURDAY': 'Sat',
  'DAY_SHORT_SUNDAY': 'Sun',
  'TIME_AM': 'AM',
  'TIME_PM': 'PM',

  'INVALID_DATA': 'Invalid data',
  'NO_DATA': 'No data to display',

  'CLEAR_SELECTION': 'Clear Selection',
  'EXPAND': 'Expand',
  'COLLAPSE': 'Collapse',

  'DATA_VISUALIZATION': 'Data Visualization',
  'STATE_SELECTED': 'Selected',
  'STATE_UNSELECTED': 'Unselected',
  'STATE_MAXIMIZED': 'Maximized',
  'STATE_MINIMIZED': 'Minimized',
  'STATE_EXPANDED': 'Expanded',
  'STATE_COLLAPSED': 'Collapsed',
  'STATE_ISOLATED': 'Isolated',
  'STATE_HIDDEN': 'Hidden',
  'STATE_VISIBLE': 'Visible',
  'STATE_DRILLABLE': 'Drillable',
  'ARIA_LABEL_STATE_DELIMITER': ', ',
  'ARIA_LABEL_DESC_DELIMITER': '. ',

  'COLON_SEP_LIST': '{0}: {1}',
  'COUNT_WITH_TOTAL': '{0} of {1}',

  'ZOOM_IN': 'Zoom In',
  'ZOOM_OUT': 'Zoom Out',

  'CHART': 'Chart',
  'DIAGRAM': 'Diagram',
  'GAUGE': 'Gauge',
  'HIERARCHY_VIEWER': 'Hierarchy Viewer',
  'LEGEND': 'Legend',
  'NBOX': '{0} Box',
  'PICTOCHART': 'Picture Chart',
  'SUNBURST': 'Sunburst',
  'TAG_CLOUD': 'Tag Cloud',
  'THEMATIC_MAP': 'Thematic Map',
  'TIMELINE': 'Timeline',
  'TIMELINE_SERIES': 'Series',
  'TREEMAP': 'Treemap'
});
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * Document APIs.
 * @class dvt.SvgDocumentUtils
 */
dvt.SvgDocumentUtils = function() {};

dvt.Obj.createSubclass(dvt.SvgDocumentUtils, dvt.Obj);

// TODO JSDoc
// Return displayable
dvt.SvgDocumentUtils.elementFromPoint = function(posX, posY) {
  var domObj = document.elementFromPoint(posX, posY);
  while (domObj) {
    if (domObj._obj && domObj._obj.getObj && domObj._obj.getObj()) {
      return domObj._obj.getObj();
    }
    domObj = domObj.parentNode;
  }
  return null;
};


/**
 * Wrapper for the elementFromPoint function that uses clientX and clientY coordinates
 * from the touch to find a corresponding displayable object
 * @param {dvt.Touch} touch The touch being passed in to evaluate the element it corresponds to
 * @return {dvt.Displayable} displayable The dom object the touch corresponds to
 */
dvt.SvgDocumentUtils.elementFromTouch = function(touch) {
  return this.elementFromPoint(touch.clientX, touch.clientY);
};


/**
 * Returns true if SVG filters are supported.
 * @return {boolean}
 */
dvt.SvgDocumentUtils.isFilterSupported = function(stage) {
  // Filters not supported in IE < 10, Safari < 6, Android
  return !(dvt.Agent.isPlatformIE() && dvt.Agent.getVersion() < 10) &&
         !(dvt.Agent.isBrowserSafari() && dvt.Agent.getVersion() < 536) &&
         !(dvt.Agent.isTouchDevice() && !dvt.Agent.isBrowserSafari());
};

/*
 * Whether or not events in SVG are received on regions that are visually clipped such that they are not visible
 */
dvt.SvgDocumentUtils.isEventAvailableOutsideClip = function() {
  return dvt.Agent.isBrowserSafari();
};

/*
 * : In Firefox 4, horizontal/vertical polylines must be bent by 0.01 pixes to show up when fitlers are used
 */
dvt.SvgDocumentUtils.isFilterStraightLineAdjustmentNeeded = function() {
  return dvt.Agent.isPlatformGecko();
};


/**
 * Work around , where removing filters from children or
 * removing children that have filters can leave behind rendering artifacts
 * in Firefox.
 * @param displayable The displayable to refresh.
 */
dvt.SvgDocumentUtils.fixGeckoContainerForFilter = function(displayable) {
  if (displayable && dvt.Agent.isPlatformGecko()) {
    var elem = displayable.getImpl().getElem();
    if (elem) {
      var transformAttr = dvt.ToolkitUtils.getAttrNullNS(elem, 'transform');
      //error message logged to Firefox console if transformAttr is null,
      //so initialize it to identity matrix instead
      if (!transformAttr) {
        transformAttr = 'matrix(1 0 0 1 0 0)';
      }
      dvt.ToolkitUtils.setAttrNullNS(elem, 'transform', transformAttr);
    }
  }
};


/**
 * Cancel a DOM event.
 *
 * @param {object}  e  event object to cancel
 */
dvt.SvgDocumentUtils.cancelDomEvent = function(e)
{
  //if (!e)
  //{
  //  e = window.event;
  //}
  if (e)
  {
    if (e.stopPropagation)
      e.stopPropagation();
    if (e.preventDefault)
      e.preventDefault();
    e.cancelBubble = true;
    e.cancel = true;
    e.returnValue = false;
  }
};


/**
 * Adds drag listeners to an object. The drag will have to start from the object, but the following mouse/touch
 * gestures will be captured even if it goes outside the object. The move and end listeners are added to the document
 * when the drag starts, and will be cleaned up when the drag ends.
 * @param {dvt.Displayable} displayable The draggable displayable.
 * @param {function} dragStartCallback The callback function that is called on drag start. It should return a boolean
 *     indicating if the drag is initiated.
 * @param {function} dragMoveCallback The callback function that is called on drag move.
 * @param {function} dragEndCallback The callback function that is called on drag end.
 * @param {object} callbackObj The object of the callback functions.
 * @param {boolean} bPreventClick (optional) Whether click should be prevented at the end of drag.
 * @return {function} A callback function to remove all listeners
 */
dvt.SvgDocumentUtils.addDragListeners = function(displayable, dragStartCallback, dragMoveCallback, dragEndCallback, callbackObj, bPreventClick) {
  var isTouch = dvt.Agent.isTouchDevice();
  var context = displayable.getCtx();
  var bodyStyle = dvt.Agent.isEnvironmentBrowser() ? document.body.style : {};

  var dragStartStaticCallback = function(dvtEvent) {
    if (dragStartCallback.call(callbackObj, dvtEvent)) {
      // Add dragMove and dragEnd event listeners to the document so that the gestures that follow can be captured
      // outside the component.
      if (isTouch) {
        document.addEventListener('touchmove', dragMoveStaticCallback, true);
        document.addEventListener('touchend', dragEndStaticCallback, true);
      }
      else {
        document.addEventListener('mousemove', dragMoveStaticCallback, true);
        document.addEventListener('mouseup', dragEndStaticCallback, true);

        if (bPreventClick)
          document.addEventListener('click', clickStaticCallback, true);
      }

      // Save the original CSS values
      dvt.SvgDocumentUtils._webkitUserSelect = bodyStyle.webkitUserSelect;
      dvt.SvgDocumentUtils._mozUserSelect = bodyStyle.MozUserSelect;

      // Disable selection during drag
      bodyStyle.webkitUserSelect = 'none';
      bodyStyle.MozUserSelect = 'none';
    }
  };

  var dragMoveStaticCallback = function(event) {
    // Convert the native event and call the callback
    var dvtEvent = dvt.DomEventFactory.newEvent(event, context);
    dragMoveCallback.call(callbackObj, dvtEvent);
  };

  var dragEndStaticCallback = function(event) {
    // Clean up the dragMove and dragEnd event listeners
    if (isTouch) {
      document.removeEventListener('touchmove', dragMoveStaticCallback, true);
      document.removeEventListener('touchend', dragEndStaticCallback, true);
    }
    else {
      document.removeEventListener('mousemove', dragMoveStaticCallback, true);
      document.removeEventListener('mouseup', dragEndStaticCallback, true);

      if (!isTouch)
        // Use timeout because the click event is fired after mouseup. We can't remove the listener in the
        // clickCallback because the click event may not be fired depending on where the mouseup happens.
        setTimeout(function() {
          document.removeEventListener('click', clickStaticCallback, true);
        }, 50);
    }

    // Restore selection
    bodyStyle.webkitUserSelect = dvt.SvgDocumentUtils._webkitUserSelect;
    bodyStyle.MozUserSelect = dvt.SvgDocumentUtils._mozUserSelect;

    // Convert the native event and call the callback
    var dvtEvent = dvt.DomEventFactory.newEvent(event, context);
    dragEndCallback.call(callbackObj, dvtEvent);
  };

  var clickStaticCallback = function(event) {
    // Prevent click from occurring (e.g. to prevent clearing selection)
    event.stopPropagation();
  };

  // Add the dragStart listener to the object.
  if (isTouch) {
    displayable.addEvtListener(dvt.TouchEvent.TOUCHSTART, dragStartStaticCallback);
  } else {
    displayable.addEvtListener(dvt.MouseEvent.MOUSEDOWN, dragStartStaticCallback);
  }

  // return function to cleanup listeners
  return function() {
    // Clean up the dragMove and dragEnd event listeners
    if (isTouch) {
      document.removeEventListener('touchmove', dragMoveStaticCallback, true);
      document.removeEventListener('touchend', dragEndStaticCallback, true);
    }
    else {
      document.removeEventListener('mousemove', dragMoveStaticCallback, true);
      document.removeEventListener('mouseup', dragEndStaticCallback, true);
      document.removeEventListener('click', clickStaticCallback, true);
    }

    // Restore selection
    bodyStyle.webkitUserSelect = dvt.SvgDocumentUtils._webkitUserSelect;
    bodyStyle.MozUserSelect = dvt.SvgDocumentUtils._mozUserSelect;
  };
};
/**
 * DvtSvgImageLoader.loadImage("pic.png", function(image) {
 *   alert(image.width);
 *   alert(image.height);
 * });
 *
 */

/*
 * DvtSvgImageLoader
 */
var DvtSvgImageLoader = { _cache: {} };

dvt.Obj.createSubclass(DvtSvgImageLoader, dvt.Obj);


/**
 * Copied from AdfIEAgent and AdfAgent
 * Adds an event listener that fires in the non-Capture phases for the specified
 * eventType.  There is no ordering guaranteee, nor is there a guarantee
 * regarding the number of times that an event listener will be called if
 * it is added to the same element multiple times.
 */
DvtSvgImageLoader.addBubbleEventListener = function(element, type, listener) 
{
  if (window.addEventListener) {
    dvt.ToolkitUtils.addDomEventListener(element, type, listener, false);
    return true;
  }
  // Internet Explorer
  else if (window.attachEvent) {
    element.attachEvent('on' + type, listener);
    return true;
  }
  else {
    return false;
  }
};


/**
 * @this {DvtSvgImageLoader}
 * Load an image.
 *
 * @param src URL of the image to load
 * @param onComplete function to call when the image is loaded
 *
 * @return image if image is already loaded
 *         otherwise null
 */
DvtSvgImageLoader.loadImage = function(src, onComplete) {
  //first look for a cached copy of the image
  var entry = this._cache[src];

  //if cached image found, use it
  if (entry) {
    // if image is loading, add listener to queue
    if (entry._image) {
      DvtSvgImageLoader._addListenerToQueue(entry._listeners, onComplete);
    }
    // if image is loaded, call onComplete function
    else {
      if (onComplete) {
        onComplete(entry);
      }
      // no handler, just return image width and height
      return entry;
    }
  }
  //if cached image not found, load the new image
  else {
    this.loadNewImage(src, onComplete);
  }
  return null;
};


/**
 * @this {DvtSvgImageLoader}
 * Load a new image.
 *
 * @param src URL of the image to load
 * @param onComplete function to call when the image is loaded
 */
DvtSvgImageLoader.loadNewImage = function(src, onComplete) {

  // create img element
  var image = document.createElement('img');

  // add a new entry to the image cached
  // depending on the state, entry value contains different attributes
  // when image is loading, entry contains image element and listeners
  // when image is loaded, entry contains image width and height
  var newEntry = {
    _listeners: [],
    url: src,
    _image: image
  };
  if (onComplete) {
    //    newEntry._listeners.push(onComplete);
    DvtSvgImageLoader._addListenerToQueue(newEntry._listeners, onComplete);
  }

  this._cache[src] = newEntry;

  DvtSvgImageLoader.addBubbleEventListener(image, 'load', function(e) {
    // copy width and height to entry and delete image element
    newEntry.width = image.width;
    newEntry.height = image.height;
    delete newEntry._image;

    // notify all listeners image loaded and delete all listeners
    var i;
    var len = newEntry._listeners.length;
    for (i = 0; i < len; i++) {
      // if there is a listener
      if (newEntry._listeners[i]) {
        newEntry._listeners[i](newEntry);
      }
    }
    delete newEntry._listeners;
  });

  image.src = src;

};


// add a listener to the queue only if it doesn't already exist
DvtSvgImageLoader._addListenerToQueue = function(queue, listener) {
  if (listener) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i] === listener)
        return;
    }
    queue.push(listener);
  }
};

// Used for rendering SVG content in to an HTML div wrapper
/**
 * @param {dvt.Context} context
 * @param {string} domElementId
 * @constructor
 */
var DvtHtmlRichTooltipManager = function(context, domElementId) {
  this.Init(context, domElementId);
};

dvt.Obj.createSubclass(DvtHtmlRichTooltipManager, dvt.HtmlTooltipManager);


/**
 * @param {dvt.Context} context
 * @param {string} domElementId
 */
DvtHtmlRichTooltipManager.prototype.Init = function(context, domElementId) 
{
  this._storedContexts = new Object();
  DvtHtmlRichTooltipManager.superclass.Init.call(this, context, domElementId);
};

DvtHtmlRichTooltipManager.prototype.InitContent = function(tooltip) {
  // For an svg custom tooltip, the context is the new svg context for the svg document overlay.
  tooltip.innerHTML = '';
  var context = new dvt.Context(tooltip, 'DvtCustomTooltip');
  this._storedContexts[this._domElementId] = context;
};

DvtHtmlRichTooltipManager.prototype.GetStoredContext = function() {
  return this._storedContexts[this._domElementId];
};

DvtHtmlRichTooltipManager.prototype.showRichElement = function(x, y, renderable, useOffset)
{
  this.showRichElementAtPosition(x, y, renderable, useOffset, false);
};

DvtHtmlRichTooltipManager.prototype.showRichElementAtPosition = function(x, y, renderable, useOffset, noEvents) {

  var tooltip = this.getTooltipElem();
  tooltip.style.position = 'absolute';
  tooltip.style.zIndex = 2147483647;

  var context = this.GetStoredContext();
  if (context) {
    var stage = context.getStage();
    stage.removeChildren();
    var rootDisplayable = renderable.getRootDisplayable();
    stage.addChild(rootDisplayable);

    if (renderable && renderable.Render) {
      renderable.Render();
    }

    var svg = stage.getImpl().getSVGRoot();
    dvt.ToolkitUtils.setAttrNullNS(svg, 'width', renderable.getDisplayWidth());
    dvt.ToolkitUtils.setAttrNullNS(svg, 'height', renderable.getDisplayHeight());

    this.PostElement(tooltip, x, y, noEvents, useOffset);
  }
};

DvtHtmlRichTooltipManager.prototype.hideTooltip = function()
{
  DvtHtmlRichTooltipManager.superclass.hideTooltip.call(this);
  var context = this.GetStoredContext();
  if (context) {
    var stage = context.getStage();
    stage.removeChildren();
  }
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/**
  * A factory class for SVG to create object implementations.
  * @extends {dvt.Obj}
  * @class DvtSvgImplFactory  A factory class to create SVG implementation objects.
  * @constructor  Creates SVG implementation objects.
  */
var DvtSvgImplFactory = function(context) {
  this._context = context;
};

dvt.Obj.createSubclass(DvtSvgImplFactory, dvt.Obj);


/**
 *  Returns a new SVG <defs> element
 *  @private
 */
DvtSvgImplFactory.prototype.newDefs = function() {
  return dvt.SvgShapeUtils.createElement('defs');
};


/**
 * Obtain imageLoader singleton
 * @override
 */
DvtSvgImplFactory.prototype.getImageLoader = function() {
  if (dvt.Agent.isEnvironmentBrowser())
    return DvtSvgImageLoader;
  else
    return dvt.JavaImageLoader;
};


/**
 * @override
 */
DvtSvgImplFactory.prototype.getDocumentUtils = function() {
  return dvt.SvgDocumentUtils;
};


/**
 * @override
 */
DvtSvgImplFactory.prototype.newParser = function() {
  if (dvt.Agent.isEnvironmentBrowser())
    return new DvtDomXmlParser();
  else
    return new DvtJavaXmlParser();
};


/**
 * @override
 */
DvtSvgImplFactory.prototype.newTooltipManager = function(id) {
  return new dvt.HtmlTooltipManager(this._context, id);
};


/**
 * @override
 */
DvtSvgImplFactory.prototype.newRichTooltipManager = function(id) {
  return new DvtHtmlRichTooltipManager(this._context, id);
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/**
 * @constructor
 */
var DvtSvgFilterContext = function()
{
  this.Init();
};

dvt.Obj.createSubclass(DvtSvgFilterContext, dvt.Obj);

DvtSvgFilterContext.prototype.Init = function()
{
  this._regionPctRect = new dvt.Rectangle(-10, -10, 120, 120);
  this._counter = 0;
  this._resultIdsUnder = [];
  this._resultIdsOver = [];
};

DvtSvgFilterContext.prototype.getRegionPctRect = function()
{
  return this._regionPctRect;
};

DvtSvgFilterContext.prototype.getResultIdsUnder = function()
{
  return this._resultIdsUnder;
};

DvtSvgFilterContext.prototype.getResultIdsOver = function()
{
  return this._resultIdsOver;
};

DvtSvgFilterContext.prototype.createResultId = function(id)
{
  if (!id)
  {
    id = 'filtRes';
  }
  return (id + (this._counter++));
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.



/**
  *   Static SVG filter routines.
  *   @class DvtSvgFilterUtils
  *   @constructor
  */
var DvtSvgFilterUtils = function()
{};

dvt.Obj.createSubclass(DvtSvgFilterUtils, dvt.Obj);

DvtSvgFilterUtils._counter = 0;

DvtSvgFilterUtils.createFilter = function(effects, svgDisplayable)
{
  var filt = dvt.SvgShapeUtils.createElement('filter', DvtSvgFilterUtils.CreateFilterId());
  var filtContext = new DvtSvgFilterContext();
  for (var i = 0; i < effects.length; i++)
  {
    var effect = effects[i];
    if (effect)
    {
      DvtSvgFilterUtils.CreateFilterPrimitives(filt, effect, svgDisplayable, filtContext);
    }
  }

  // : When bounding box of svg element has zero height or width, userSpaceOnUse must be used
  // Otherwise, the element will disappear
  var userSpaceOnUse = false;
  if (svgDisplayable) {
    var boundsRect = svgDisplayable.getElem().getBBox();
    if (boundsRect) {
      var width = boundsRect.width;
      var height = boundsRect.height;
      if (height == 0 || width == 0) {
        var stroke;
        //if displayable is not a shape, for example a container, then it doesn't have a stroke
        if (svgDisplayable.getStroke) {
          stroke = svgDisplayable.getStroke();
        }
        var adjustWidth = 10;
        if (stroke) {
          adjustWidth = stroke.getWidth();
        }
        var x = boundsRect.x;
        var y = boundsRect.y;

        // Firefox 4 requires the line to be bend slightly when feColorMatrix is used
        if (dvt.SvgDocumentUtils.isFilterStraightLineAdjustmentNeeded()) {
          if (svgDisplayable instanceof dvt.Polyline) {
            var points = dvt.ArrayUtils.copy(svgDisplayable.getPoints());
            if (width == 0) {
              points[0] = points[0] + 0.01;
            }
            if (height == 0) {
              points[1] = points[1] + 0.01;
            }

            var bentPoints = dvt.SvgShapeUtils.convertPointsArray(points);
            dvt.ToolkitUtils.setAttrNullNS(svgDisplayable.getElem(), 'points', bentPoints);
          }
        }

        if (height == 0) {
          height = 2 * adjustWidth;
          y -= adjustWidth;
        }
        if (width == 0) {
          width = 2 * adjustWidth;
          x -= adjustWidth;
        }

        dvt.ToolkitUtils.setAttrNullNS(filt, 'x', x);
        dvt.ToolkitUtils.setAttrNullNS(filt, 'y', y);
        dvt.ToolkitUtils.setAttrNullNS(filt, 'width', width);
        dvt.ToolkitUtils.setAttrNullNS(filt, 'height', height);
        dvt.ToolkitUtils.setAttrNullNS(filt, 'filterUnits', 'userSpaceOnUse');
        userSpaceOnUse = true;
      }
    }
  }
  if (!userSpaceOnUse) {
    if (filtContext.getRegionPctRect().x != -10 && filtContext.getRegionPctRect().x != 'Infinity' && filtContext.getRegionPctRect().x != '-Infinity')
    {
      dvt.ToolkitUtils.setAttrNullNS(filt, 'x', filtContext.getRegionPctRect().x + '%');
    }
    if (filtContext.getRegionPctRect().y != -10 && filtContext.getRegionPctRect().y != 'Infinity' && filtContext.getRegionPctRect().y != '-Infinity')
    {
      dvt.ToolkitUtils.setAttrNullNS(filt, 'y', filtContext.getRegionPctRect().y + '%');
    }
    if (filtContext.getRegionPctRect().w != 120 && filtContext.getRegionPctRect().w != 'Infinity' && filtContext.getRegionPctRect().w != '-Infinity')
    {
      dvt.ToolkitUtils.setAttrNullNS(filt, 'width', filtContext.getRegionPctRect().w + '%');
    }
    if (filtContext.getRegionPctRect().h != 120 && filtContext.getRegionPctRect().h != 'Infinity' && filtContext.getRegionPctRect().h != '-Infinity')
    {
      dvt.ToolkitUtils.setAttrNullNS(filt, 'height', filtContext.getRegionPctRect().h + '%');
    }

  }


  var numResultsUnder = filtContext.getResultIdsUnder().length;
  var numResultsOver = filtContext.getResultIdsOver().length;
  var elemMN;
  var j;

  var elemM = dvt.SvgShapeUtils.createElement('feMerge');
  if (numResultsUnder > 0)
  {
    for (j = 0; j < numResultsUnder; j++)
    {
      elemMN = dvt.SvgShapeUtils.createElement('feMergeNode');
      dvt.ToolkitUtils.setAttrNullNS(elemMN, 'in', filtContext.getResultIdsUnder()[j]);
      dvt.ToolkitUtils.appendChildElem(elemM, elemMN);
    }
  }
  elemMN = dvt.SvgShapeUtils.createElement('feMergeNode');
  dvt.ToolkitUtils.setAttrNullNS(elemMN, 'in', 'SourceGraphic');
  dvt.ToolkitUtils.appendChildElem(elemM, elemMN);
  if (numResultsOver > 0)
  {
    for (j = 0; j < numResultsOver; j++)
    {
      elemMN = dvt.SvgShapeUtils.createElement('feMergeNode');
      dvt.ToolkitUtils.setAttrNullNS(elemMN, 'in', filtContext.getResultIdsOver()[j]);
      dvt.ToolkitUtils.appendChildElem(elemM, elemMN);
    }
  }
  dvt.ToolkitUtils.appendChildElem(filt, elemM);

  return filt;
};

DvtSvgFilterUtils.CreateFilterPrimitives = function(filter, effect, svgDisplayable, filtContext)
{
  if (effect instanceof dvt.Shadow)
  {
    DvtSvgShadowUtils.createFilterPrimitives(filter, effect, svgDisplayable, filtContext);
  }
  return null;
};

DvtSvgFilterUtils.CreateFilterId = function()
{
  return ('filt' + (DvtSvgFilterUtils._counter++));
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    DvtSvgGradientUtils    A static class for SVG gradient property manip- */
/*                           ulation.                                        */
/*---------------------------------------------------------------------------*/
/**
  *   DvtSvgGradientUtils    A static class for SVG gradient property manipulation.
  *   @class DvtSvgGradientUtils
  *   @constructor
  */
var DvtSvgGradientUtils = function()
{};

dvt.Obj.createSubclass(DvtSvgGradientUtils, dvt.Obj);


/**
  *  Static method to create an SVG element and apply gradient properties to it.
  *  @param {Object}  Either a dvt.GradientFill or dvt.GradientStroke derivative to apply.
  */
DvtSvgGradientUtils.createElem = function(grad, id)
{
  var bLinear = ((grad instanceof dvt.LinearGradientFill) || (grad instanceof dvt.LinearGradientStroke));
  var elemGrad = dvt.SvgShapeUtils.createElement((bLinear ? 'linearGradient' : 'radialGradient'), id);

  var i;
  var arColors = grad.getColors();
  var arAlphas = grad.getAlphas();
  var arStops = grad.getStops();
  var arBounds = grad.getBounds();
  var len = arColors.length;

  for (i = 0; i < len; i++) {
    var elem = dvt.SvgShapeUtils.createElement('stop');
    dvt.ToolkitUtils.setAttrNullNS(elem, 'offset', '' + (arStops[i] * 100) + '%');
    var color = arColors[i];
    if (color) {
      var alpha = arAlphas[i];
      // Workaround for Safari where versions < 5.1 show rgba values as black
      if ((dvt.Agent.isEnvironmentBatik() || dvt.Agent.isBrowserSafari()) && color.indexOf('rgba') !== - 1) {
        dvt.ToolkitUtils.setAttrNullNS(elem, 'stop-color', dvt.ColorUtils.getRGB(color));
        // Use alpa in rgba value as a multiplier to the alpha set on the object as this is what svg does.
        if (alpha != null)
          dvt.ToolkitUtils.setAttrNullNS(elem, 'stop-opacity', dvt.ColorUtils.getAlpha(color) * alpha, 1);
        else
          dvt.ToolkitUtils.setAttrNullNS(elem, 'stop-opacity', dvt.ColorUtils.getAlpha(color), 1);
      }
      else {
        dvt.ToolkitUtils.setAttrNullNS(elem, 'stop-color', color);
        if (alpha != null)
          dvt.ToolkitUtils.setAttrNullNS(elem, 'stop-opacity', alpha, 1);
      }
    }
    dvt.ToolkitUtils.appendChildElem(elemGrad, elem);
  }

  //  If no gradient bounding box specified, will use the object's boundary box.

  var bUseObjBBox = (! arBounds ||
      ((arBounds[0] == 0) && (arBounds[1] == 0) && (arBounds[2] == 0) && (arBounds[3] == 0)));

  //  The angle of rotation for SVG is clockwise, so must convert from the standard
  //  anti-clockwise convention used by the middle-tier xml. Rotation is
  //  at the mid-point of the bounding box.

  if (bLinear) {
    var angle = grad.getAngle();

    var x1 = '0%';
    var y1 = '0%';
    var x2 = '100%';
    var y2 = '0%';

    var setGradientVector = true;

    if (bUseObjBBox) {

      // Set gradient vector for gradientUnits = "objectBoundingBox"
      // (the default value for gradientUnits).

      if (angle === 45) {
        y1 = '100%';
        x2 = '100%';
      }
      else if (angle === 90) {
        y1 = '100%';
        x2 = '0%';
      }
      else if (angle === 135) {
        x1 = '100%';
        x2 = '0%';
        y2 = '100%';
      }
      else if (angle === 270) {
        x2 = '0%';
        y2 = '100%';
      }
      else if (angle !== 0) {
        angle = -angle;
        dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'gradientTransform', 'rotate(' + dvt.ToolkitUtils.roundDecimal(angle) + ' ' + '.5 .5)');
        setGradientVector = false;  // no need to change the default gradient vector, since we are rotating the
        // gradient via gradientTransform
      }
    }
    else {

      //  Apply specified bounding box

      // use gradientUnits = "userSpaceOnUse"; for when we want to account for bounding box
      // first rotate the gradient by the specified angle
      // then scale this gradient to the width and bounds specifed in arBounds
      // then translate the gradient
      // note that if the width and height of the gradient are not equal, then the actual angle of the
      // gradient is different from the specified angle argument
      // However, this is the same behavior as how Flash processes the bounding box argument
      // Finally, note that in SVG, the order of transform operations is right to left

      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'gradientUnits', 'userSpaceOnUse');

      // set gradient vector to span the middle of the unit square
      x1 = '0';
      y1 = '0.5';
      x2 = '1';
      y2 = '0.5';

      var scaleX = arBounds[2];
      var scaleY = arBounds[3];
      var translateX = arBounds[0];
      var translateY = arBounds[1];

      angle = -angle;
      var rotateTransformStr = 'rotate(' + dvt.ToolkitUtils.roundDecimal(angle) + ' ' + '.5 .5)';
      var scaleTransformStr = 'scale(' + dvt.ToolkitUtils.roundDecimal(scaleX) + ' ' + dvt.ToolkitUtils.roundDecimal(scaleY) + ')';
      var translateTransformStr = 'translate(' + dvt.ToolkitUtils.roundDecimal(translateX) + ' ' + dvt.ToolkitUtils.roundDecimal(translateY) + ')';
      var boundingBoxTransformStr = scaleTransformStr + ' ' + rotateTransformStr;

      if (translateX != 0 || translateY != 0) {
        boundingBoxTransformStr = translateTransformStr + ' ' + boundingBoxTransformStr;
      }

      // in the case of a bounding box, to set up the gradient, we need both gradientTransform and
      // a gradient vector centered in the unit square

      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'gradientTransform', boundingBoxTransformStr);
    }

    if (setGradientVector) {
      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'x1', x1);
      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'y1', y1);
      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'x2', x2);
      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'y2', y2);
    }
  }
  else {    //  Radial gradient

    if (! bUseObjBBox) {

      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'gradientUnits', 'userSpaceOnUse');

      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'cx', grad.getCx());
      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'cy', grad.getCy());
      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'fx', grad.getCx());
      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'fy', grad.getCy());
      dvt.ToolkitUtils.setAttrNullNS(elemGrad, 'r', grad.getRadius());
    }
  }
  return elemGrad;
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    DvtSvgImageFillUtils    A static class for SVG image fill property     */
/*                           manipulation.                                   */
/*---------------------------------------------------------------------------*/
/**
  *   A static class for SVG image fill property manipulation.
  *   @class DvtSvgImageFillUtils
  *   @constructor
  */
var DvtSvgImageFillUtils = function()
{};

dvt.Obj.createSubclass(DvtSvgImageFillUtils, dvt.Obj);


/**
  *  Static method to create an SVG element and apply image fill properties
  *  to it.
  *  @param {dvt.ImageFill}
  */
DvtSvgImageFillUtils.createElem = function(imageFill, id)
{
  /* Example:
      <defs>
        <pattern id="img1" patternUnits="userSpaceOnUse" width="20" height="20" >
          <image xlink:href="400.png" x="0" y="0"  width="20" height="20" />
        </pattern>
      </defs>

      <rect x="0" y="0" height="100" width="100" fill="url(#img1)"/>
   */

  var elemPat = dvt.SvgShapeUtils.createElement('pattern', id);
  var elemImg = dvt.SvgShapeUtils.createElement('image', id);

  var src = imageFill.getSrc();
  var bound = imageFill.getBound();
  var repeat = imageFill.getRepeat();

  if (bound) {
    dvt.ToolkitUtils.setAttrNullNS(elemPat, 'x', bound.x);
    dvt.ToolkitUtils.setAttrNullNS(elemPat, 'y', bound.y);

    dvt.ToolkitUtils.setAttrNullNS(elemImg, 'x', bound.x);
    dvt.ToolkitUtils.setAttrNullNS(elemImg, 'y', bound.y);

    dvt.ToolkitUtils.setAttrNullNS(elemPat, 'width', bound.w);
    dvt.ToolkitUtils.setAttrNullNS(elemPat, 'height', bound.h);

    dvt.ToolkitUtils.setAttrNullNS(elemImg, 'width', bound.w);
    dvt.ToolkitUtils.setAttrNullNS(elemImg, 'height', bound.h);
    dvt.ToolkitUtils.setAttrNullNS(elemPat, 'patternUnits', 'userSpaceOnUse');

    /*
      // tile the background image
      if (! repeat || repeat != "no-repeat") {
      }
      // stretch out the background image
      else {
        dvt.ToolkitUtils.setAttrNullNS(elemPat, "patternUnits", "objectBoundingBox");
        dvt.ToolkitUtils.setAttrNullNS(elemPat, 'width', "100%");
        dvt.ToolkitUtils.setAttrNullNS(elemPat, 'height', "100%");
      }
      */

    if (src) {
      dvt.ToolkitUtils.setAttrNS(elemImg, dvt.Image.XLINK_NS, 'xlink:href', src);
    }
  }

  dvt.ToolkitUtils.appendChildElem(elemPat, elemImg);

  return elemPat;
};
// Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    DvtSvgPatternFillUtils    A static class for SVG pattern fill property */
/*                              manipulation.                                */
/*---------------------------------------------------------------------------*/
/**
  *   A static class for creating SVG pattern fills.
  *   @class DvtSvgPatternFillUtils
  *   @constructor
  */
var DvtSvgPatternFillUtils = function()
{};

dvt.Obj.createSubclass(DvtSvgPatternFillUtils, dvt.Obj);


/**   @private @final @type {String}  */
DvtSvgPatternFillUtils._SM_WIDTH = 8;


/**   @private @final @type {String}  */
DvtSvgPatternFillUtils._SM_HEIGHT = 8;


/**   @private @final @type {String}  */
DvtSvgPatternFillUtils._LG_WIDTH = 16;


/**   @private @final @type {String}  */
DvtSvgPatternFillUtils._LG_HEIGHT = 16;


/**
  *  Static method to create an SVG pattern element.
  *  @param {dvt.PatternFill}  patternFill  pattern fill object
  *  @param {string}  id  pattern identifier
  */
DvtSvgPatternFillUtils.createElem = function(patternFill, id)
{
  var elemPat = dvt.SvgShapeUtils.createElement('pattern', id);

  var pattern = patternFill.getPattern();
  var bSmall = DvtSvgPatternFillUtils.IsSmallPattern(pattern);
  var ww;
  var hh;
  if (bSmall)
  {
    ww = DvtSvgPatternFillUtils._SM_WIDTH;
    hh = DvtSvgPatternFillUtils._SM_HEIGHT;
  }
  else
  {
    ww = DvtSvgPatternFillUtils._LG_WIDTH;
    hh = DvtSvgPatternFillUtils._LG_HEIGHT;
  }

  dvt.ToolkitUtils.setAttrNullNS(elemPat, 'x', 0);
  dvt.ToolkitUtils.setAttrNullNS(elemPat, 'y', 0);
  dvt.ToolkitUtils.setAttrNullNS(elemPat, 'width', ww);
  dvt.ToolkitUtils.setAttrNullNS(elemPat, 'height', hh);
  dvt.ToolkitUtils.setAttrNullNS(elemPat, 'patternUnits', 'userSpaceOnUse');
  var mat = patternFill.getMatrix();
  if (mat) {
    var sMat = 'matrix(' + mat.getA() + ',' + mat.getC() + ',' + mat.getB() + ',' + mat.getD() + ',' + mat.getTx() + ',' + mat.getTy() + ')';
    dvt.ToolkitUtils.setAttrNullNS(elemPat, 'patternTransform', sMat);
  }

  DvtSvgPatternFillUtils.CreatePatternElems(patternFill, elemPat);

  return elemPat;
};


/**
  * Determine if the pattern is large or small.
  *
  * @param {string}  pattern  constant representing the pattern
  * @protected
  */
DvtSvgPatternFillUtils.IsSmallPattern = function(pattern)
{
  return (pattern.charAt(0) === 's');
};


/**
  * Determine if the pattern is large or small.
  *
  * @param {dvt.PatternFill}  patternFill  pattern fill object
  * @param {object}  parentElem  parent pattern DOM element
  * @protected
  */
DvtSvgPatternFillUtils.CreatePatternElems = function(patternFill, parentElem)
{
  var rightX;
  var bottomY;
  var w;
  var h;
  var halfW;
  var halfH;
  var elem;

  var pattern = patternFill.getPattern();
  var sColor = patternFill.getColor();
  var color = dvt.ColorUtils.getRGB(sColor);
  var alpha = dvt.ColorUtils.getAlpha(sColor);
  var sBackgroundColor = patternFill.getBackgroundColor();
  var backgroundColor = dvt.ColorUtils.getRGB(sBackgroundColor);
  var backgroundAlpha = dvt.ColorUtils.getAlpha(sBackgroundColor);

  var bSmall = DvtSvgPatternFillUtils.IsSmallPattern(pattern);
  if (bSmall)
  {
    rightX = DvtSvgPatternFillUtils._SM_WIDTH;
    bottomY = DvtSvgPatternFillUtils._SM_HEIGHT;
    w = DvtSvgPatternFillUtils._SM_WIDTH;
    h = DvtSvgPatternFillUtils._SM_HEIGHT;
  }
  else
  {
    rightX = DvtSvgPatternFillUtils._LG_WIDTH;
    bottomY = DvtSvgPatternFillUtils._LG_HEIGHT;
    w = DvtSvgPatternFillUtils._LG_WIDTH;
    h = DvtSvgPatternFillUtils._LG_HEIGHT;
  }

  //if a background color is specified, then fill a rect with that color
  //before drawing the pattern elements on top of it
  if (backgroundColor && (backgroundAlpha > 0))
  {
    elem = dvt.SvgShapeUtils.createElement('rect');

    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke', backgroundColor);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-opacity', backgroundAlpha);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-width', 1);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'fill', backgroundColor);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'fill-opacity', backgroundAlpha);

    dvt.ToolkitUtils.setAttrNullNS(elem, 'x', 0);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'y', 0);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'width', rightX);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'height', bottomY);

    dvt.ToolkitUtils.appendChildElem(parentElem, elem);
  }

  if (pattern === dvt.PatternFill.SM_DIAG_UP_LT ||
      pattern === dvt.PatternFill.LG_DIAG_UP_LT)
  {
    elem = dvt.SvgShapeUtils.createElement('path');
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-opacity', alpha);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-width', 1);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-linecap', 'square');

    dvt.ToolkitUtils.setAttrNullNS(elem, 'd', dvt.PathUtils.moveTo(0, -h / 2) + dvt.PathUtils.lineTo(3 * w / 2, h) +
        dvt.PathUtils.moveTo(-w / 2, 0) + dvt.PathUtils.lineTo(w / 2, h));

    dvt.ToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === dvt.PatternFill.SM_DIAG_UP_RT ||
           pattern === dvt.PatternFill.LG_DIAG_UP_RT)
  {
    elem = dvt.SvgShapeUtils.createElement('path');
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-opacity', alpha);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-width', 1);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-linecap', 'square');

    dvt.ToolkitUtils.setAttrNullNS(elem, 'd', dvt.PathUtils.moveTo(-w / 2, h) + dvt.PathUtils.lineTo(w, -h / 2) +
        dvt.PathUtils.moveTo(0, 3 * h / 2) + dvt.PathUtils.lineTo(3 * w / 2, 0));

    dvt.ToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === dvt.PatternFill.SM_CROSSHATCH ||
           pattern === dvt.PatternFill.LG_CROSSHATCH)
  {
    //use path instead of two lines because it's more compact (uses one
    //DOM element instead of two)
    elem = dvt.SvgShapeUtils.createElement('path');

    //  g.lineStyle((bSmall? 1 : 2), color) ;
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-opacity', alpha);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-width', 1);

    dvt.ToolkitUtils.setAttrNullNS(elem, 'd', 'M0,0' +
        'L' + rightX + ',' + bottomY +
        'M' + rightX + ',0' +
        'L0,' + bottomY);

    dvt.ToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === dvt.PatternFill.SM_CHECK ||
           pattern === dvt.PatternFill.LG_CHECK)
  {
    halfW = w / 2;
    halfH = h / 2;

    //use path instead of two rects because it's more compact (uses one
    //DOM element instead of two)
    elem = dvt.SvgShapeUtils.createElement('path');

    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-opacity', alpha);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-width', 1);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'fill', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'fill-opacity', alpha);

    dvt.ToolkitUtils.setAttrNullNS(elem, 'd', 'M' + halfW + ',0' +
        'L' + w + ',0' +
        'L' + w + ',' + halfH +
        'L' + halfW + ',' + halfH + 'Z' +
        'M0,' + halfH +
        'L' + halfW + ',' + halfH +
        'L' + halfW + ',' + h +
        'L0,' + h + 'Z');

    dvt.ToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === dvt.PatternFill.SM_TRIANGLE_CHECK ||
           pattern === dvt.PatternFill.LG_TRIANGLE_CHECK)
  {
    elem = dvt.SvgShapeUtils.createElement('polygon');

    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-opacity', alpha);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-width', 1);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'fill', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'fill-opacity', alpha);

    dvt.ToolkitUtils.setAttrNullNS(elem, 'points', '0,' + bottomY + ' ' +
        rightX + ',0 ' +
        rightX + ',' + bottomY);

    dvt.ToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === dvt.PatternFill.SM_DIAMOND_CHECK ||
           pattern === dvt.PatternFill.LG_DIAMOND_CHECK)
  {
    halfW = w / 2;
    halfH = h / 2;

    elem = dvt.SvgShapeUtils.createElement('polygon');

    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-opacity', alpha);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'stroke-width', 1);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'fill', color);
    dvt.ToolkitUtils.setAttrNullNS(elem, 'fill-opacity', alpha);

    dvt.ToolkitUtils.setAttrNullNS(elem, 'points', '0,' + halfH + ' ' +
        halfW + ',0 ' +
        rightX + ',' + halfW + ' ' +
        halfW + ',' + bottomY);

    dvt.ToolkitUtils.appendChildElem(parentElem, elem);
  }
};
// Copyright (c) 2008, 2016, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*   DvtSvgShadowUtils    A static class for SVG drop shadow property manip- */
/*                        ulation.                                           */
/*---------------------------------------------------------------------------*/
/**
  *  A static class for SVG drop shadow property manipulation.
  *  @class DvtSvgShadowUtils
  *  @constructor
  */
var DvtSvgShadowUtils = function()
{};

dvt.Obj.createSubclass(DvtSvgShadowUtils, dvt.Obj);


/**
 * @private
 * @final
 */
DvtSvgShadowUtils.RADS_PER_DEGREE = (Math.PI / 180);


/**
  *  Static method to create an SVG filter element and apply shadow properties to it.
  *  @param {dvt.Shadow}
  *  @return {DOM_Element}  An SVG  &lt;filter&gt; element
  */
DvtSvgShadowUtils.createFilter = function(shadow, displayable)
{
  //  The following filter is created:

  //   <filter id="ds1">
  //     <feColorMatrix type="matrix" values="0 0 0 red 0
  //                                          0 0 0 green 0
  //                                          0 0 0 blue 0
  //                                          0 0 0 alpha 0">
  //     </feColorMatrix>
  //     <feGaussianBlur stdDeviation="5.166666666666666" result="blur1"></feGaussianBlur>
  //     <feOffset dx="5.75" dy="5.75" in="blur1" result="offset"></feOffset>
  //     <feMerge>
  //       <feMergeNode in="offset"></feMergeNode>
  //       <feMergeNode in="SourceGraphic"></feMergeNode>
  //     </feMerge>
  //   </filter>

  var filt;

  if (! shadow.isLocked()) {
    var filtContext = new DvtSvgFilterContext();
    filt = dvt.SvgShapeUtils.createElement('filter', shadow._Id);
    DvtSvgShadowUtils.createFilterPrimitives(filt, shadow, displayable, filtContext);

    var elemM = dvt.SvgShapeUtils.createElement('feMerge');
    var elemMN1 = dvt.SvgShapeUtils.createElement('feMergeNode');
    dvt.ToolkitUtils.setAttrNullNS(elemMN1, 'in', filtContext.getResultIdsUnder()[0]);
    var elemMN2 = dvt.SvgShapeUtils.createElement('feMergeNode');
    dvt.ToolkitUtils.setAttrNullNS(elemMN2, 'in', 'SourceGraphic');

    dvt.ToolkitUtils.appendChildElem(filt, elemM);
    dvt.ToolkitUtils.appendChildElem(elemM, elemMN1);
    dvt.ToolkitUtils.appendChildElem(elemM, elemMN2);
  }

  return filt;
};

DvtSvgShadowUtils.createFilterPrimitives = function(filt, shadow, svgDisplayable, filtContext)
{
  //: create inner shadow if necessary
  if (shadow._bInner)
  {
    DvtSvgShadowUtils.CreateInnerFilterPrimitives(filt, shadow, svgDisplayable, filtContext);
  }
  else
  {
    DvtSvgShadowUtils.CreateOuterFilterPrimitives(filt, shadow, svgDisplayable, filtContext);
  }
};


/**
 * @protected
 */
DvtSvgShadowUtils.CreateOuterFilterPrimitives = function(filt, shadow, svgDisplayable, filtContext)
{
  //if (! shadow.isLocked()) {

  var rgba = shadow._rgba;
  var red = dvt.ColorUtils.getRed(rgba) / 255;
  var green = dvt.ColorUtils.getGreen(rgba) / 255;
  var blue = dvt.ColorUtils.getBlue(rgba) / 255;
  var alpha = dvt.ColorUtils.getAlpha(rgba);
  var strength = shadow._strength;

  var origBlurX = shadow._blurX;
  var origBlurY = shadow._blurY;
  //adjust blur values so that SVG behaves more like Flash
  //: only calculate blur if blur is not set to 0
  var blurX = 0;
  var blurY = 0;
  if (shadow._blurX > 0)
  {
    blurX = Math.max(shadow._blurX / 3, 1);
  }
  if (shadow._blurY > 0)
  {
    blurY = Math.max(shadow._blurY / 3, 1);
  }
  var distance = shadow._distance;
  var angleDegs = shadow._angle;

  var angleRads = angleDegs * DvtSvgShadowUtils.RADS_PER_DEGREE;
  var dx = Math.cos(angleRads) * distance;
  var dy = Math.sin(angleRads) * distance;

  //:
  //if we have a boundsRect, increase the size of the filter so
  //that the shadow has room to display outside the shape
  var boundsRect = svgDisplayable.getDimensions(svgDisplayable.getParent());
  if (boundsRect)
  {
    //try to optimize based on how much of the shadow falls
    //on each side of the bounding box
    var absDistance = Math.abs(distance);
    //use two times the blur by default, because using it directly
    //still clips the shadow
    var padLeft = 2 * origBlurX;
    var padRight = 2 * origBlurX;
    var padTop = 2 * origBlurY;
    var padBottom = 2 * origBlurY;
    if (distance > 0)
    {
      padLeft -= absDistance;
      padTop -= absDistance;
      padRight += absDistance;
      padBottom += absDistance;
    }
    else if (distance < 0)
    {
      padLeft += absDistance;
      padTop += absDistance;
      padRight -= absDistance;
      padBottom -= absDistance;
    }
    if (padLeft < 0)
    {
      padLeft = 0;
    }
    if (padTop < 0)
    {
      padTop = 0;
    }
    if (padRight < 0)
    {
      padRight = 0;
    }
    if (padBottom < 0)
    {
      padBottom = 0;
    }
    var ratioLeft = (padLeft / boundsRect.w) * 100;
    var ratioRight = (padRight / boundsRect.w) * 100;
    var ratioTop = (padTop / boundsRect.h) * 100;
    var ratioBottom = (padBottom / boundsRect.h) * 100;
    if (filtContext.getRegionPctRect().x > -ratioLeft)
    {
      filtContext.getRegionPctRect().x = -ratioLeft;
    }
    if (filtContext.getRegionPctRect().y > -ratioTop)
    {
      filtContext.getRegionPctRect().y = -ratioTop;
    }
    if (filtContext.getRegionPctRect().w < (100 + ratioLeft + ratioRight))
    {
      filtContext.getRegionPctRect().w = (100 + ratioLeft + ratioRight);
    }
    if (filtContext.getRegionPctRect().h < (100 + ratioTop + ratioBottom))
    {
      filtContext.getRegionPctRect().h = (100 + ratioTop + ratioBottom);
    }
  }
  // The bounding box does not take into accoutn stroke-width. Need to adjust for dvt.Line objects
  if (svgDisplayable instanceof dvt.Polyline) {
    var strokeWidth = svgDisplayable.getStroke().getWidth();
    // If stroke is wider than 1 pixel, adjust y coordinate and height of shadow bounding box
    if (strokeWidth > 1) {
      filtContext.getRegionPctRect().h = filtContext.getRegionPctRect().h + strokeWidth;
      filtContext.getRegionPctRect().y = filtContext.getRegionPctRect().y - strokeWidth;
    }
  }

  var elemCM = dvt.SvgShapeUtils.createElement('feColorMatrix');
  dvt.ToolkitUtils.setAttrNullNS(elemCM, 'in', 'SourceGraphic');
  dvt.ToolkitUtils.setAttrNullNS(elemCM, 'type', 'matrix');
  dvt.ToolkitUtils.setAttrNullNS(elemCM, 'values', '0 0 0 ' + red + ' 0 ' +
      '0 0 0 ' + green + ' 0 ' +
      '0 0 0 ' + blue + ' 0 ' +
      '0 0 0 ' + alpha * strength + ' 0');
  //var elemCMResult = filtContext.createResultId('colorMatrix');
  //dvt.ToolkitUtils.setAttrNullNS(elemCM, 'result', elemCMResult) ;

  var elemGB = dvt.SvgShapeUtils.createElement('feGaussianBlur');
  //include both numbers for stdDev when necessary
  var stdDev = blurX;
  if (blurX !== blurY)
  {
    stdDev += ' ' + blurY;
  }
  dvt.ToolkitUtils.setAttrNullNS(elemGB, 'stdDeviation', stdDev);
  var elemGBResult = filtContext.createResultId('blur');
  dvt.ToolkitUtils.setAttrNullNS(elemGB, 'result', elemGBResult);

  var elemO = dvt.SvgShapeUtils.createElement('feOffset');
  dvt.ToolkitUtils.setAttrNullNS(elemO, 'dx', dx);
  dvt.ToolkitUtils.setAttrNullNS(elemO, 'dy', dy);
  dvt.ToolkitUtils.setAttrNullNS(elemO, 'in', elemGBResult);
  var elemOResult = filtContext.createResultId('offset');
  dvt.ToolkitUtils.setAttrNullNS(elemO, 'result', elemOResult);

  filtContext.getResultIdsUnder().push(elemOResult);

  dvt.ToolkitUtils.appendChildElem(filt, elemCM);
  dvt.ToolkitUtils.appendChildElem(filt, elemGB);
  dvt.ToolkitUtils.appendChildElem(filt, elemO);


  // TDO <feMorphology operator="erode" in="blurred" radius="3" result="eroded"/>
  //}
};


/**
 * @protected
 */
DvtSvgShadowUtils.CreateInnerFilterPrimitives = function(filt, shadow, svgDisplayable, filtContext)
{
  var rgba = shadow._rgba;
  var red = dvt.ColorUtils.getRed(rgba) / 255;
  var green = dvt.ColorUtils.getGreen(rgba) / 255;
  var blue = dvt.ColorUtils.getBlue(rgba) / 255;
  var rgb = dvt.ColorUtils.makeRGB(red, green, blue);
  var alpha = dvt.ColorUtils.getAlpha(rgba);

  var origBlurX = shadow._blurX;
  var origBlurY = shadow._blurY;
  //adjust blur values so that SVG behaves more like Flash
  var blurX = Math.max(shadow._blurX / 2, 1);
  var blurY = Math.max(shadow._blurY / 2, 1);
  var distance = shadow._distance;
  var angleDegs = shadow._angle;
  var strength = shadow._strength;

  var angleRads = angleDegs * DvtSvgShadowUtils.RADS_PER_DEGREE;
  var dx = Math.cos(angleRads) * distance;
  var dy = Math.sin(angleRads) * distance;

  var elemF1 = dvt.SvgShapeUtils.createElement('feFlood');
  dvt.ToolkitUtils.setAttrNullNS(elemF1, 'in', 'SourceGraphic');
  dvt.ToolkitUtils.setAttrNullNS(elemF1, 'flood-opacity', alpha);
  dvt.ToolkitUtils.setAttrNullNS(elemF1, 'flood-color', rgb);
  var elemF1Result = filtContext.createResultId('flood');
  dvt.ToolkitUtils.setAttrNullNS(elemF1, 'result', elemF1Result);

  var elemC1 = dvt.SvgShapeUtils.createElement('feComposite');
  dvt.ToolkitUtils.setAttrNullNS(elemC1, 'operator', 'out');
  dvt.ToolkitUtils.setAttrNullNS(elemC1, 'in', elemF1Result);
  dvt.ToolkitUtils.setAttrNullNS(elemC1, 'in2', 'SourceGraphic');
  //var elemC1Result = filtContext.createResultId('comp');
  //dvt.ToolkitUtils.setAttrNullNS(elemC1, 'result', elemC1Result) ;

  /*
   var elemCM  = dvt.SvgShapeUtils.createElement('feColorMatrix') ;
   dvt.ToolkitUtils.setAttrNullNS(elemCM, 'in', 'SourceGraphic') ;
   dvt.ToolkitUtils.setAttrNullNS(elemCM, 'type', 'matrix') ;
   dvt.ToolkitUtils.setAttrNullNS(elemCM, 'values', '0 0 0 ' + red   + ' 0 ' +
                                        '0 0 0 ' + green + ' 0 ' +
                                        '0 0 0 ' + blue  + ' 0 ' +
                                        '0 0 0 ' + alpha + ' 0') ;
   //var elemCMResult = filtContext.createResultId('colorMatrix');
   //dvt.ToolkitUtils.setAttrNullNS(elemCM, 'result', elemCMResult) ;
  */

  var elemGB = dvt.SvgShapeUtils.createElement('feGaussianBlur');
  //include both numbers for stdDev when necessary
  var stdDev = blurX;
  if (blurX !== blurY)
  {
    stdDev += ' ' + blurY;
  }
  dvt.ToolkitUtils.setAttrNullNS(elemGB, 'stdDeviation', stdDev);
  var elemGBResult = filtContext.createResultId('blur');
  dvt.ToolkitUtils.setAttrNullNS(elemGB, 'result', elemGBResult);

  //attempt to use the shadow strength as multiplier for alpha
  //value in blur filter
  var elemCM2 = dvt.SvgShapeUtils.createElement('feColorMatrix');
  dvt.ToolkitUtils.setAttrNullNS(elemCM2, 'in', elemGBResult);
  dvt.ToolkitUtils.setAttrNullNS(elemCM2, 'type', 'matrix');
  dvt.ToolkitUtils.setAttrNullNS(elemCM2, 'values', '1 0 0 0 0 ' +
      '0 1 0 0 0 ' +
      '0 0 1 0 0 ' +
      '0 0 0 ' + strength + ' 0');
  var elemCM2Result = filtContext.createResultId('colMat');
  dvt.ToolkitUtils.setAttrNullNS(elemCM2, 'result', elemCM2Result);

  var elemO = dvt.SvgShapeUtils.createElement('feOffset');
  dvt.ToolkitUtils.setAttrNullNS(elemO, 'dx', dx);
  dvt.ToolkitUtils.setAttrNullNS(elemO, 'dy', dy);
  dvt.ToolkitUtils.setAttrNullNS(elemO, 'in', elemCM2Result);
  var elemOResult = filtContext.createResultId('offset');
  dvt.ToolkitUtils.setAttrNullNS(elemO, 'result', elemOResult);

  var elemC2 = dvt.SvgShapeUtils.createElement('feComposite');
  dvt.ToolkitUtils.setAttrNullNS(elemC2, 'operator', 'in');
  dvt.ToolkitUtils.setAttrNullNS(elemC2, 'in', elemOResult);
  dvt.ToolkitUtils.setAttrNullNS(elemC2, 'in2', 'SourceGraphic');
  var elemC2Result = filtContext.createResultId('comp');
  dvt.ToolkitUtils.setAttrNullNS(elemC2, 'result', elemC2Result);

  filtContext.getResultIdsOver().push(elemC2Result);

  dvt.ToolkitUtils.appendChildElem(filt, elemF1);
  dvt.ToolkitUtils.appendChildElem(filt, elemC1);
  //dvt.ToolkitUtils.appendChildElem(filt, elemCM) ;
  dvt.ToolkitUtils.appendChildElem(filt, elemGB);
  dvt.ToolkitUtils.appendChildElem(filt, elemCM2);
  dvt.ToolkitUtils.appendChildElem(filt, elemO);
  dvt.ToolkitUtils.appendChildElem(filt, elemC2);
};
dvt.exportProperty(dvt, 'Agent', dvt.Agent);
dvt.exportProperty(dvt.Agent, 'setEnvironment', dvt.Agent.setEnvironment);
dvt.exportProperty(dvt.Agent, 'setHighContrast', dvt.Agent.setHighContrast);

dvt.exportProperty(dvt.Automation.prototype, 'getDomElementForSubId', dvt.Automation.prototype.getDomElementForSubId);
dvt.exportProperty(dvt.Automation.prototype, 'getSubIdForDomElement', dvt.Automation.prototype.getSubIdForDomElement);

dvt.exportProperty(dvt.BaseComponent.prototype, 'applyOptions', dvt.BaseComponent.prototype.applyOptions);
dvt.exportProperty(dvt.BaseComponent.prototype, 'render', dvt.BaseComponent.prototype.render);
dvt.exportProperty(dvt.BaseComponent.prototype, 'highlight', dvt.BaseComponent.prototype.highlight);
dvt.exportProperty(dvt.BaseComponent.prototype, 'select', dvt.BaseComponent.prototype.select);
dvt.exportProperty(dvt.BaseComponent.prototype, 'getKeyboardFocus', dvt.BaseComponent.prototype.getKeyboardFocus);

dvt.exportProperty(dvt, 'Bundle', dvt.Bundle);
dvt.exportProperty(dvt.Bundle, 'addLocalizedStrings', dvt.Bundle.addLocalizedStrings);

dvt.exportProperty(dvt, 'Context', dvt.Context);
dvt.exportProperty(dvt.Context, 'resetCaches', dvt.Context.resetCaches);
dvt.exportProperty(dvt.Context, 'resetUniqueSeeds', dvt.Context.resetUniqueSeeds);
dvt.exportProperty(dvt.Context.prototype, 'getStage', dvt.Context.prototype.getStage);
dvt.exportProperty(dvt.Context.prototype, 'getSvgDocument', dvt.Context.prototype.getSvgDocument);
dvt.exportProperty(dvt.Context.prototype, 'hideTooltips', dvt.Context.prototype.hideTooltips);
dvt.exportProperty(dvt.Context.prototype, 'isReadyToRender', dvt.Context.prototype.isReadyToRender);
dvt.exportProperty(dvt.Context.prototype, 'setDatatipStyleClass', dvt.Context.prototype.setDatatipStyleClass);
dvt.exportProperty(dvt.Context.prototype, 'setLocaleHelpers', dvt.Context.prototype.setLocaleHelpers);
dvt.exportProperty(dvt.Context.prototype, 'setReadingDirection', dvt.Context.prototype.setReadingDirection);
dvt.exportProperty(dvt.Context.prototype, 'setOverlayAttachedCallback', dvt.Context.prototype.setOverlayAttachedCallback);
dvt.exportProperty(dvt.Context.prototype, 'setTooltipAttachedCallback', dvt.Context.prototype.setTooltipAttachedCallback);
dvt.exportProperty(dvt.Context.prototype, 'setTooltipStyleClass', dvt.Context.prototype.setTooltipStyleClass);

dvt.exportProperty(dvt.Dimension.prototype, 'getWidth', dvt.Dimension.prototype.getWidth);
dvt.exportProperty(dvt.Dimension.prototype, 'getHeight', dvt.Dimension.prototype.getHeight);

dvt.exportProperty(dvt, 'JsonUtils', dvt.JsonUtils);
dvt.exportProperty(dvt.JsonUtils, 'clone', dvt.JsonUtils.clone);
dvt.exportProperty(dvt.JsonUtils, 'merge', dvt.JsonUtils.merge);

dvt.exportProperty(DvtStage.prototype, 'addChild', DvtStage.prototype.addChild);

return dvt;
})();

  return dvt;
});
