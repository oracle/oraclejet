{"version":3,"file":"MessagesManager-ecd5a2ae.js","sources":["../../src/UNSAFE_Message/MessagesContext.ts","../../src/UNSAFE_Message/MessagesManager.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\n\n/**\n * Messages Context\n */\ntype MessagesContextProps = {\n  /**\n   * An optional function that adds busy state to the root element\n   */\n  addBusyState?: (description?: string) => () => void;\n};\n\n/**\n * Context which the parent custom element components can use for passing down\n * the busy context\n */\nconst MessagesContext = createContext<MessagesContextProps>({});\n\n/**\n * Uses the MessagesContext if one is available.\n *\n * @returns The context from the closes provider\n */\nfunction useMessagesContext() {\n  return useContext(MessagesContext);\n}\n\nexport { MessagesContext, useMessagesContext };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChild, Fragment } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { Transition, TransitionGroup } from '../UNSAFE_TransitionGroup';\nimport { Item } from '../utils/UNSAFE_dataProvider';\nimport { useMessagesContext } from './MessagesContext';\n\n/**\n * A type that defines animation configuration\n */\ntype MessageAnimation = {\n  effect?: string;\n  duration?: string | number;\n  direction?: string;\n};\n\n/**\n * Transition states for animations\n */\ntype TransitionState = 'enter' | 'exit';\n\n/**\n * Metadata passed on to the Transition component\n */\ntype TransitionMetadata<K> = {\n  index: number;\n  key: K;\n};\n\n/**\n * Type of the render context passed on to render individual message\n */\ntype MessageRenderContext<Key, Data> = {\n  /**\n   * The index of the current message\n   */\n  index: number;\n\n  /**\n   * The message item with all the necessary data in it\n   */\n  item: Item<Key, Data>;\n};\n\n// Type of startAnimation property\ntype StartAnimType = (\n  element: Element,\n  action: string,\n  effects: string | object | (string | object)[],\n  component?: object\n) => Promise<unknown>;\n\n/**\n * Props for the Message Component\n */\ntype Props<Key, Data> = {\n  /**\n   * An object of various animation effects for the transitions.\n   */\n  animations?: Record<string, MessageAnimation[]>;\n\n  /**\n   * A render function that renders individual child.\n   */\n  children?: (context: MessageRenderContext<Key, Data>) => ComponentChild;\n\n  /**\n   * Data for the messages. This data is used for rendering each message.\n   */\n  data: Item<Key, Data>[];\n\n  /**\n   * Method for starting an animation.\n   */\n  startAnimation?: StartAnimType;\n\n  /**\n   * A callback function that gets called before a message is removed\n   */\n  onMessageWillRemove?: (key: Key, index: number, node?: Element) => void;\n};\n\n/**\n * The component that renders individual messages for the provided data.\n */\nfunction MessagesManager<K extends string | number = string | number, D = any>(props: Props<K, D>) {\n  const { children, data } = props;\n  const { handleEntering, handleExiting } = useMessagesManager(props);\n\n  return (\n    <TransitionGroup elementType={Fragment}>\n      {data.map((item, index) => (\n        <Transition\n          key={item.key}\n          metadata={{ index, key: item.key }}\n          onEntering={handleEntering}\n          onExiting={handleExiting}>\n          {children?.({ index, item })}\n        </Transition>\n      ))}\n    </TransitionGroup>\n  );\n}\n\n/**\n * A custom hook for creating the listeners for the MessagesManager\n *\n * @param param0 The props for the messages\n * @returns The transition listeners\n */\nfunction useMessagesManager<K, D>({\n  animations,\n  startAnimation = () => Promise.resolve(false),\n  onMessageWillRemove\n}: Props<K, D>) {\n  const { addBusyState } = useMessagesContext();\n\n  /**\n   * Adds busy state if available in the context\n   *\n   * @param description The description of the busyState\n   * @returns The busyState resolver\n   */\n  const _addBusyState = useCallback(\n    (description: string) => {\n      return addBusyState?.(description) ?? (() => {});\n    },\n    [addBusyState]\n  );\n\n  /**\n   * Performs animation.\n   *\n   * @param type The type of the animation\n   * @param base The root DOM element\n   */\n  const performAnimation = useCallback(\n    async (type: TransitionState, base?: Element) => {\n      if (!base) {\n        return;\n      }\n\n      const animation = animations?.[type];\n      if (animation) {\n        const busyStateResolver = _addBusyState(`performing message animation - ${type}`);\n        // If an animation is provided for the current transition, perform the animation\n        await startAnimation(base, type, animation);\n        busyStateResolver();\n      }\n    },\n    [animations, startAnimation, _addBusyState]\n  );\n\n  /**\n   * Handles when a message is successfully entered.\n   *\n   * @param node The corresponding message element\n   * @param callback A callback function to be called after the animation is complete\n   */\n  const handleEntering = useCallback(\n    async (node?: Element, callback?: () => void) => {\n      await performAnimation('enter', node);\n      callback?.();\n    },\n    [performAnimation]\n  );\n\n  /**\n   * Handles when a message has started to exit.\n   *\n   * @param node The corresponding message element\n   * @param callback A callback function to be called after the animation is complete\n   */\n  const handleExiting = useCallback(\n    async (node?: Element, callback?: () => void, metadata?: TransitionMetadata<K>) => {\n      await performAnimation('exit', node);\n      metadata && onMessageWillRemove?.(metadata.key, metadata.index, node);\n      callback?.();\n    },\n    [performAnimation, onMessageWillRemove]\n  );\n\n  return { handleEntering, handleExiting };\n}\n\nexport { MessageAnimation, MessagesManager };\n"],"names":["MessagesContext","createContext","props","children","data","handleEntering","handleExiting","animations","startAnimation","Promise","resolve","onMessageWillRemove","addBusyState","useContext","_addBusyState","useCallback","description","_a","performAnimation","async","type","base","animation","busyStateResolver","node","callback","metadata","key","index","useMessagesManager","_jsx","TransitionGroup","Object","assign","elementType","Fragment","map","item","Transition","onEntering","onExiting"],"mappings":"6HAyBA,MAAMA,EAAkBC,EAAaA,cAAuB,0CCkE5D,SAA+EC,GAC7E,MAAMC,SAAEA,EAAFC,KAAYA,GAASF,GACrBG,eAAEA,EAAFC,cAAkBA,GAuB1B,UAAkCC,WAChCA,EADgCC,eAEhCA,EAAiB,KAAMC,QAAQC,SAAQ,IAFPC,oBAGhCA,IAEA,MAAMC,aAAEA,GDxFDC,EAAAA,WAAWb,GCgGZc,EAAgBC,eACnBC,UACC,OAAkC,UAA3BJ,MAAAA,OAAY,EAAZA,EAAeI,UAAY,IAAAC,EAAAA,EAAK,SAEzC,CAACL,IASGM,EAAmBH,EAAAA,aACvBI,MAAOC,EAAuBC,KAC5B,IAAKA,EACH,OAGF,MAAMC,EAAYf,MAAAA,SAAAA,EAAaa,GAC/B,GAAIE,EAAW,CACb,MAAMC,EAAoBT,oCAAgDM,WAEpEZ,EAAea,EAAMD,EAAME,GACjCC,OAGJ,CAAChB,EAAYC,EAAgBM,IASzBT,EAAiBU,EAAAA,aACrBI,MAAOK,EAAgBC,WACfP,EAAiB,QAASM,GAChCC,MAAAA,GAAAA,MAEF,CAACP,IASGZ,EAAgBS,EAAWA,aAC/BI,MAAOK,EAAgBC,EAAuBC,WACtCR,EAAiB,OAAQM,GAC/BE,IAAYf,MAAAA,GAAAA,EAAsBe,EAASC,IAAKD,EAASE,MAAOJ,IAChEC,MAAAA,GAAAA,MAEF,CAACP,EAAkBP,IAGrB,MAAO,CAAEN,eAAAA,EAAgBC,cAAAA,GA/FiBuB,CAAmB3B,GAE7D,OACE4B,MAACC,EAAAA,gBAAeC,OAAAC,OAAA,CAACC,YAAaC,EAAAA,UAAQ,CAAAhC,SACnCC,EAAKgC,KAAI,CAACC,EAAMT,IACfE,EAAAA,IAACQ,EAAUA,WAAAN,OAAAC,OAAA,CAETP,SAAU,CAAEE,MAAAA,EAAOD,IAAKU,EAAKV,KAC7BY,WAAYlC,EACZmC,UAAWlC,GACV,CAAAH,SAAAA,MAAAA,SAAAA,EAAW,CAAEyB,MAAAA,EAAOS,KAAAA,MAJhBA,EAAKV"}