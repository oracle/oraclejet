{"version":3,"file":"dimensions.js","sources":["../../../../../node_modules/ramda/src/isNil.js","../../../../src/utils/UNSAFE_interpolations/dimensions/dimensions.ts"],"sourcesContent":["var _curry1 =\n/*#__PURE__*/\nrequire(\"./internal/_curry1\");\n/**\n * Checks if the input value is `null` or `undefined`.\n *\n * @func\n * @memberOf R\n * @since v0.9.0\n * @category Type\n * @sig * -> Boolean\n * @param {*} x The value to test.\n * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.\n * @example\n *\n *      R.isNil(null); //=> true\n *      R.isNil(undefined); //=> true\n *      R.isNil(0); //=> false\n *      R.isNil([]); //=> false\n */\n\n\nvar isNil =\n/*#__PURE__*/\n_curry1(function isNil(x) {\n  return x == null;\n});\n\nmodule.exports = isNil;","/**\n * This file contains a style interpolation for dimension css properties.\n * It contains prop => style functions related to a UI elements\n * dimensions.\n * Style interpolations are functions that transform props to UI styling.\n * This technique is often used in Styled Components to provide consistent,\n * reusable styled props API.\n *\n * This file contains dimension properties like width, height,\n * maxHeight, etc. The intent of this dimension interpolation file\n * is that all component apis that need dimension properties\n * will use these dimensions interpolations so that the properties, in whatever component they are used,\n * will type the properties the same way and will also interpolate the\n * property values the same way. This gives us consistent apis and behavior.\n * I.e., The dimension properties are all typed with Size, and the user's values all run through the same sizeToCSS() function.\n */\nimport { stringLiteralArray } from '../../../utils/UNSAFE_arrayUtils';\nimport { sizeToCSS, Size } from '../../../utils/UNSAFE_size';\nimport isNil from 'ramda/src/isNil';\n\n// if we don't run this array through this stringLiteralArray function, then the type is string[].\n// After running it through this stringLiteralArray function its type changes to be\n// (\"height\" | \"maxHeight\" | \"maxWidth\" | \"minHeight\" | \"minWidth\" | \"width\")[].\n// The typed dimensions array can be exported to show options in a test or storybook.\nconst dimensions = stringLiteralArray([\n  'height',\n  'maxHeight',\n  'maxWidth',\n  'minHeight',\n  'minWidth',\n  'width'\n]);\n// This is deriving a type from the dimensions array implementation. This type is used\n// throughout this file.\ntype Dimension = typeof dimensions[number];\n\nexport type DimensionProps = {\n  [key in Dimension]?: Size;\n};\n// The return type of our interpolations.\n// This says it  will be an object with the keys of our dimensions and a corresponding function that requires\n// an object with that same dimension key and will return an empty object or the non-null CSS property and value.\ntype Interpolations = {\n  //The -? means every key in DimensionProps must be present.\n  [Key in keyof DimensionProps]-?: (\n    props: Pick<DimensionProps, Key>\n  ) => {} | Record<string, string>;\n};\n\n// Pick<DimensionProps, Key> Constructs a type by picking the set of properties Keys (string literal or union\n// of string literals ) from DimensionProps.\n// This is the *dimension interpolation function*. All dimension properties run through this function;\n// it runs the dimension's value through the sizeToCSS() function to return the css that can be used\n// in the html style property.\n// e.g., it maps 50x to calc(50 * var(--oj-core-spacing-1x)))\nconst propToSize =\n  <Key extends Dimension>(key: Key) =>\n  (props: Pick<DimensionProps, Key>) => {\n    // Storing a local copy of the prop for proper type guarding in the ternary (conditional) below.\n    const val = props[key];\n    // casting val as Size because we know it can't be undefined\n    return isNil(props[key]) ? {} : { [key]: sizeToCSS(val as Size) };\n  };\n\n// A map of dimension style props to size style interpolation functions.\n// Since TS infers the return type of `reduce` from the `initialValue`,\n// we need to manually write the type so is isn't cast as `{}` which is effectively `any`.\n// Our initial object {} is cast to Interpolations type.\n// This will reduce the dimensions array to an Object that has the dimension keys, like\n// width, height, etc., and an interpolation funcion.\n// In component code that uses dimensionInterpolations, we run the dimension\n// props through this interpolation function to get the value, a class, else a style\n// (dimensions return styles, not style classes.). Other interpolations, like flexitem,\n// may return classes for properties that have distinct prop values, like start, center, end\n// or sm, md, lg.\n// Search component .tsx files for a dimensionInterpolations usage example.\nconst dimensionInterpolations = dimensions.reduce(\n  (acc, key) => Object.assign(acc, { [key]: propToSize(key) }),\n  {} as Interpolations\n);\n\nexport { dimensions, dimensionInterpolations };\n"],"names":["isNil_1","_curry1","require$$0","x","dimensions","stringLiteralArray","propToSize","key","props","val","isNil","sizeToCSS","dimensionInterpolations","reduce","acc","Object","assign"],"mappings":"6KAAA,IA4BAA,GAJAC,EAtBAC,EAAAA,YAsBQ,SAAeC,GACrB,OAAY,MAALA,KCDH,MAAAC,EAAaC,EAAAA,mBAAmB,CACpC,SACA,YACA,WACA,YACA,WACA,UAyBIC,EACoBC,GACvBC,IAEC,MAAMC,EAAMD,EAAMD,GAElB,OAAOG,EAAMF,EAAMD,IAAQ,GAAK,CAAEA,CAACA,GAAMI,EAAAA,UAAUF,KAejDG,EAA0BR,EAAWS,QACzC,CAACC,EAAKP,IAAQQ,OAAOC,OAAOF,EAAK,CAAEP,CAACA,GAAMD,EAAWC,MACrD"}