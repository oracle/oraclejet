{"version":3,"file":"UNSAFE_useBreakpointValues.js","sources":["../../../src/hooks/UNSAFE_useBreakpointValues/useBreakpointValues.ts"],"sourcesContent":["import { useBreakpoints, Breakpoints, defaultBreakpoints } from '../UNSAFE_useBreakpoints';\n\n/*\n * This allows a user to define key/value pairs that map to each breakpoint.\n * The user's custom value is returned when the specific breakpoint is reached.\n */\ntype DefaultBreakpoints = keyof typeof defaultBreakpoints;\ntype DefaultType<T> = Record<DefaultBreakpoints, T>;\ntype Responsive<V> = Partial<DefaultType<V>>;\n\n/*\n * Custom hook to allow the user to define custom values that are returned if a breakpoint is reached.\n * The Responsive object is a set of one or more key/value pairs, with each breakpoint as a key.\n *\n * TODO: Fix breakpoint value Type:\n *  The second arg allows arbitrary breakpoints to be specified, but the first arg only allows values for \"sm\", \"md\", \"lg\" and \"xl\"; if we allow custom breakpoints to be specified via the second arg, the first arg needs to allow values for those same custom breakpoints to be passed in.\n */\nexport function useBreakpointValues<V>(\n  breakpointValues: Responsive<V>,\n  breakpoints: Breakpoints = defaultBreakpoints\n) {\n  const current = useBreakpoints(breakpoints);\n\n  const breakpoint = Object.entries(breakpointValues).reduce((p, c) => {\n    const key = c[0]; // first entry in breakpoint values is the key\n    return current[key] ? c : p; // if current breakpoint is true, return it, else stay with previous\n  });\n\n  return breakpoint[1]; // second entry in breakpoint values is the value\n}\n"],"names":["breakpointValues","breakpoints","defaultBreakpoints","current","useBreakpoints","Object","entries","reduce","p","c","key"],"mappings":"yHAkBEA,EACAC,EAA2BC,sBAE3B,MAAMC,EAAUC,iBAAeH,GAO/B,OALmBI,OAAOC,QAAQN,GAAkBO,QAAO,CAACC,EAAGC,KAC7D,MAAMC,EAAMD,EAAE,GACd,OAAON,EAAQO,GAAOD,EAAID,KAGV"}