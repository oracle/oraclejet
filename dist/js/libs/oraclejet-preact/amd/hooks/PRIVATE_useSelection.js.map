{"version":3,"file":"PRIVATE_useSelection.js","sources":["../../../src/hooks/PRIVATE_useSelection/useSelection.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { RefObject } from 'preact';\nimport { useCallback, useRef } from 'preact/hooks';\nimport { stringLiteralArray } from '../../utils/UNSAFE_arrayUtils';\nimport { Keys, containsKey, isKeyDefined, addKey, removeKey } from '../../utils/UNSAFE_keys';\nimport { SelectionDetail, SelectionMode } from '../../UNSAFE_Collection';\n\n/**\n * Type for selection behavior.  See useMultipleSelection hook for details.\n */\nexport const behaviors = stringLiteralArray(['toggle', 'replace']);\nexport type SelectionBehavior = typeof behaviors[number];\n\n/**\n * Type for payload of selection range change event handler\n */\nexport type SelectionRangeDetail<K> = {\n  value: { start: K; end: K };\n};\n\nconst isShiftModeSupported = <K>(\n  anchorKey: K,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  selectionBehavior: SelectionBehavior\n) => {\n  return (\n    selectionMode === 'multiple' &&\n    selectionBehavior !== 'toggle' &&\n    containsKey(selectedKeys, anchorKey)\n  );\n};\n\nconst handleSelect = <K>(\n  event: MouseEvent | KeyboardEvent,\n  keyExtractor: (event: Event) => K | null,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  selectionBehavior: SelectionBehavior,\n  isSelectionRequired: boolean,\n  keyboardCursorRef: RefObject<K | undefined>,\n  anchorKey?: K,\n  onChange?: (detail: SelectionDetail<K>) => void,\n  onRangeChange?: (detail: SelectionRangeDetail<K>) => void\n) => {\n  const itemKey = keyExtractor(event);\n  if (itemKey == null) {\n    return;\n  }\n\n  // handle shift key selection\n  if (\n    event.shiftKey &&\n    anchorKey &&\n    onRangeChange &&\n    isShiftModeSupported(anchorKey, selectedKeys, selectionMode, selectionBehavior)\n  ) {\n    onRangeChange({ value: { start: anchorKey, end: itemKey } });\n    // set keyboard selection cursor in case user extends with SHIFT+ARROW\n    if (keyboardCursorRef) {\n      keyboardCursorRef.current = itemKey;\n    }\n    return;\n  }\n\n  const selected = containsKey(selectedKeys, itemKey);\n  let keySet = selectedKeys;\n  if (!selected) {\n    if (\n      selectionMode === 'single' ||\n      (selectionBehavior === 'replace' && !(event.ctrlKey || event.metaKey))\n    ) {\n      // should only contains this item key\n      keySet = { all: false, keys: new Set([itemKey]) };\n    } else {\n      // add to existing selected keys\n      keySet = addKey(selectedKeys, itemKey);\n    }\n  } else {\n    if (\n      selectionBehavior === 'toggle' ||\n      event.ctrlKey ||\n      event.metaKey ||\n      (event as KeyboardEvent).key === ' '\n    ) {\n      // de-select only when ctrl/meta key is pressed or selectionBehavior is\n      // explicitly set to toggle\n      keySet = removeKey(selectedKeys, itemKey, isSelectionRequired);\n    } else if (selectionMode === 'multiple' && (selectedKeys.all || selectedKeys.keys.size > 1)) {\n      // in this case everything should be de-selected except for this key\n      keySet = { all: false, keys: new Set([itemKey]) };\n    }\n  }\n  // only invoke callback if there is really a change\n  // note onSelectionChange should never be null here\n  if (selectedKeys != keySet && onChange) {\n    onChange({ value: keySet });\n  }\n};\n\n/**\n * Hook for handling various selection mode.  This can be reuse by all Collection components.\n * @param keyExtractor function to extract the key based on event that trigger the selection change.\n * @param selectedKeys the currently selected keys\n * @param selectionMode the selection mode\n * @param selectionBehavior the selection behavior.  If the value is 'toggle', then the key is\n *                          added/removed from the current selected keys.  If the value is 'replace',\n *                          then the current selected keys are cleared first before the key is added\n *                          unless the ctrl/shift/meta key is pressed.\n * @param onSelectionChange callback function that is invoked when selection has changed.\n * @returns an event map that the consumer can register as event listeners\n */\nexport function useSelection<K>(\n  keyExtractor: (event: Event) => K | null,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  isSelectionRequired: boolean,\n  selectionBehavior: SelectionBehavior,\n  onChange?: (detail: SelectionDetail<K>) => void,\n  anchorKey?: K,\n  currentKey?: K | undefined,\n  getPrevNextKey?: (currentKey: K | undefined, isPrev: boolean) => () => K | null,\n  scrollToKey?: (key: K) => void,\n  onRangeChange?: (detail: SelectionRangeDetail<K>) => void\n) {\n  // ref to track the cursor for the SHIFT+ARROW keyboard selection separately than the anchor of the selection.\n  const keyboardSelectionCursor = useRef<K>();\n\n  const onClick = useCallback(\n    (event: MouseEvent) => {\n      handleSelect(\n        event,\n        keyExtractor,\n        selectedKeys,\n        selectionMode,\n        selectionBehavior,\n        isSelectionRequired,\n        keyboardSelectionCursor,\n        anchorKey,\n        onChange,\n        onRangeChange\n      );\n      if (!event.shiftKey) {\n        // reset keyboard cursor when using mouse to select\n        keyboardSelectionCursor.current = undefined;\n      }\n    },\n    [\n      keyExtractor,\n      selectedKeys,\n      selectionMode,\n      selectionBehavior,\n      isSelectionRequired,\n      keyboardSelectionCursor,\n      anchorKey,\n      onChange,\n      onRangeChange\n    ]\n  );\n\n  // general keyboard events listen to keyUp for a11y\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      // older browser that we don't support returns 'Spacebar' for space key\n      if (event.key === ' ') {\n        handleSelect(\n          event,\n          keyExtractor,\n          selectedKeys,\n          selectionMode,\n          selectionBehavior,\n          isSelectionRequired,\n          keyboardSelectionCursor,\n          anchorKey,\n          onChange,\n          event.shiftKey ? onRangeChange : undefined\n        );\n      }\n    },\n    [\n      keyboardSelectionCursor.current,\n      keyExtractor,\n      selectedKeys,\n      selectionMode,\n      selectionBehavior,\n      isSelectionRequired,\n      anchorKey,\n      onChange,\n      onRangeChange\n    ]\n  );\n\n  // arrowKey events listen to keyDown so they can support holding them down\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      // prevent default (propagation) for keyDown to space bar causing container to scroll\n      if (event.key === ' ') {\n        event.preventDefault();\n        return;\n      }\n\n      if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n        if (event.shiftKey && getPrevNextKey && scrollToKey) {\n          let keySet = selectedKeys;\n          // on first selection event, set keyboard cursor to start at currentKey\n          if (!keyboardSelectionCursor.current && isKeyDefined(currentKey)) {\n            keySet = { all: false, keys: new Set([currentKey as K]) };\n          }\n          const newAnchorKey = getPrevNextKey(\n            keyboardSelectionCursor.current || currentKey,\n            event.key === 'ArrowDown' ? false : true\n          );\n          const cursorKey = newAnchorKey();\n          if (cursorKey) {\n            // extend selection\n            if (!containsKey(keySet, cursorKey)) {\n              keySet = addKey(keySet, cursorKey);\n              // subtract from selection\n            } else if (keyboardSelectionCursor.current) {\n              keySet = removeKey(keySet, keyboardSelectionCursor.current, isSelectionRequired);\n            }\n            keyboardSelectionCursor.current = cursorKey;\n            // keep visible\n            scrollToKey(cursorKey);\n          }\n          if (selectedKeys != keySet && onChange) {\n            onChange({ value: keySet });\n          }\n        } else {\n          // reset keyBoard on non-shifted arrow use as this interrupts the extend mode (and would make for messy logic that doesn't align with current Jet behavior)\n          keyboardSelectionCursor.current = undefined;\n        }\n      }\n    },\n    [keyboardSelectionCursor.current, selectedKeys, isSelectionRequired, onChange]\n  );\n\n  const selectionProps =\n    selectionMode === 'none' || onChange == null ? {} : { onClick, onKeyDown, onKeyUp };\n  return { selectionProps };\n}\n"],"names":["stringLiteralArray","handleSelect","event","keyExtractor","selectedKeys","selectionMode","selectionBehavior","isSelectionRequired","keyboardCursorRef","anchorKey","onChange","onRangeChange","itemKey","shiftKey","containsKey","isShiftModeSupported","value","start","end","current","keySet","ctrlKey","metaKey","key","removeKey","all","keys","size","Set","addKey","currentKey","getPrevNextKey","scrollToKey","keyboardSelectionCursor","useRef","onClick","useCallback","undefined","onKeyUp","onKeyDown","isKeyDefined","cursorKey","newAnchorKey","preventDefault","selectionProps"],"mappings":"sHAgByBA,EAAAA,mBAAmB,CAAC,SAAU,YAAhD,MAuBDC,EAAe,CACnBC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,KAEA,MAAMC,EAAUT,EAAaD,GAC7B,GAAe,MAAXU,EACF,OAIF,GACEV,EAAMW,UACNJ,GACAE,GAlCyB,EAC3BF,EACAL,EACAC,EACAC,IAGoB,aAAlBD,GACsB,WAAtBC,GACAQ,cAAYV,EAAcK,GA0B1BM,CAAqBN,EAAWL,EAAcC,EAAeC,GAO7D,OALAK,EAAc,CAAEK,MAAO,CAAEC,MAAOR,EAAWS,IAAKN,UAE5CJ,IACFA,EAAkBW,QAAUP,IAMhC,IAAIQ,EAAShB,EADIU,EAAAA,YAAYV,EAAcQ,GAejB,WAAtBN,GACAJ,EAAMmB,SACNnB,EAAMoB,SAC2B,MAAhCpB,EAAwBqB,IAIzBH,EAASI,EAAAA,UAAUpB,EAAcQ,EAASL,GACf,aAAlBF,IAAiCD,EAAaqB,KAAOrB,EAAasB,KAAKC,KAAO,KAEvFP,EAAS,CAAEK,KAAK,EAAOC,KAAM,IAAIE,IAAI,CAAChB,MAjBtCQ,EAJkB,WAAlBf,GACuB,YAAtBC,IAAqCJ,EAAMmB,UAAWnB,EAAMoB,QAGpD,CAAEG,KAAK,EAAOC,KAAM,IAAIE,IAAI,CAAChB,KAG7BiB,EAAMA,OAACzB,EAAcQ,GAmB9BR,GAAgBgB,GAAUV,GAC5BA,EAAS,CAAEM,MAAOI,oBAgBhB,SACJjB,EACAC,EACAC,EACAE,EACAD,EACAI,EACAD,EACAqB,EACAC,EACAC,EACArB,GAGA,MAAMsB,EAA0BC,EAAAA,SAE1BC,EAAUC,eACblC,IACCD,EACEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACA0B,EACAxB,EACAC,EACAC,GAEGT,EAAMW,WAEToB,EAAwBd,aAAUkB,KAGtC,CACElC,EACAC,EACAC,EACAC,EACAC,EACA0B,EACAxB,EACAC,EACAC,IAKE2B,EAAUF,eACblC,IAEmB,MAAdA,EAAMqB,KACRtB,EACEC,EACAC,EACAC,EACAC,EACAC,EACAC,EACA0B,EACAxB,EACAC,EACAR,EAAMW,SAAWF,OAAgB0B,KAIvC,CACEJ,EAAwBd,QACxBhB,EACAC,EACAC,EACAC,EACAC,EACAE,EACAC,EACAC,IAKE4B,EAAYH,eACflC,IAEC,GAAkB,MAAdA,EAAMqB,KAKV,GAAkB,cAAdrB,EAAMqB,KAAqC,YAAdrB,EAAMqB,IACrC,GAAIrB,EAAMW,UAAYkB,GAAkBC,EAAa,CACnD,IAAIZ,EAAShB,GAER6B,EAAwBd,SAAWqB,EAAYA,aAACV,KACnDV,EAAS,CAAEK,KAAK,EAAOC,KAAM,IAAIE,IAAI,CAACE,MAExC,MAIMW,EAJeV,EACnBE,EAAwBd,SAAWW,EACrB,cAAd5B,EAAMqB,IAEUmB,GACdD,IAEG3B,EAAWA,YAACM,EAAQqB,GAGdR,EAAwBd,UACjCC,EAASI,EAASA,UAACJ,EAAQa,EAAwBd,QAASZ,IAH5Da,EAASS,EAAMA,OAACT,EAAQqB,GAK1BR,EAAwBd,QAAUsB,EAElCT,EAAYS,IAEVrC,GAAgBgB,GAAUV,GAC5BA,EAAS,CAAEM,MAAOI,SAIpBa,EAAwBd,aAAUkB,OAjCpCnC,EAAMyC,mBAqCV,CAACV,EAAwBd,QAASf,EAAcG,EAAqBG,IAKvE,MAAO,CAAEkC,eADW,SAAlBvC,GAAwC,MAAZK,EAAmB,GAAK,CAAEyB,QAAAA,EAASI,UAAAA,EAAWD,QAAAA"}