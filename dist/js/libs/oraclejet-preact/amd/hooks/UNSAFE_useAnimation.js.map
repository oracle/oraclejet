{"version":3,"file":"UNSAFE_useAnimation.js","sources":["../../../src/hooks/UNSAFE_useAnimation/animationUtils.ts","../../../src/hooks/UNSAFE_useAnimation/useAnimation.ts"],"sourcesContent":["import { StandardProperties } from 'csstype';\n\nexport type UseAnimationCssProperties = StandardProperties & TransformProperties;\n\n// This represents shorthand UseAnimationCssProperties props.\ntype TransformProperties = Partial<\n  Record<\n    | 'translateX'\n    | 'translateY'\n    | 'translateZ'\n    | 'rotateX'\n    | 'rotateY'\n    | 'rotateZ'\n    | 'skewX'\n    | 'skewY',\n    string\n  > &\n    Record<'scaleX' | 'scaleY' | 'scaleZ', string | number>\n>;\n\n/**\n * Converts shorthand translate props into transform string representation.\n *\n * @param translateX\n * @param translateY\n * @param translateZ\n * @returns Longhand transform string representation.\n */\nfunction convertTranslateShortcuts(\n  translateX: TransformProperties['translateX'],\n  translateY: TransformProperties['translateY'],\n  translateZ: TransformProperties['translateZ']\n) {\n  return `${translateX ? ` translateX(${translateX})` : ''}${\n    translateY ? ` translateY(${translateY})` : ''\n  }${translateZ ? ` translateZ(${translateZ})` : ''}`;\n}\n\n/**\n * Converts shorthand rotate props into transform string representation.\n *\n * @param rotateX\n * @param rotateY\n * @param rotateZ\n * @returns Longhand transform string representation.\n */\nfunction convertRotateShortcuts(\n  rotateX?: TransformProperties['rotateX'],\n  rotateY?: TransformProperties['rotateY'],\n  rotateZ?: TransformProperties['rotateZ']\n) {\n  return `${rotateX ? ` rotateX(${rotateX})` : ''}${rotateY ? ` rotateY(${rotateY})` : ''}${\n    rotateZ ? ` rotateZ(${rotateZ})` : ''\n  }`;\n}\n\n/**\n * Converts shorthand scale props into transform string representation.\n *\n * @param scaleX\n * @param scaleY\n * @param scaleZ\n * @returns Longhand transform string representation.\n */\nfunction convertScaleShortcuts(\n  scaleX: TransformProperties['scaleX'],\n  scaleY: TransformProperties['scaleY'],\n  scaleZ: TransformProperties['scaleZ']\n) {\n  return `${scaleX || scaleX === 0 ? ` scaleX(${scaleX})` : ''}${\n    scaleY || scaleY === 0 ? ` scaleY(${scaleY})` : ''\n  }${scaleZ || scaleZ === 0 ? ` scaleZ(${scaleZ})` : ''}`;\n}\n\n/**\n * Converts shorthand skew props into transform string representation.\n *\n * @param skewX\n * @param skewY\n * @returns Longhand transform string representation.\n */\nfunction convertSkewShortcuts(\n  skewX: TransformProperties['skewX'],\n  skewY: TransformProperties['skewY']\n) {\n  return `${skewX ? ` skewX(${skewX})` : ''}${skewY ? ` skewY(${skewY})` : ''}`;\n}\n\n/**\n * Converts animation CSS properties into Regular camel cased CSS properties.\n *\n * @param useAnimationCssProperties This include transform shorthand props.\n * @returns Regular camel cased CSS properties.\n */\nexport function convertUseAnimationCssPropertiesToRegularCSS(\n  useAnimationCssProperties?: UseAnimationCssProperties\n) {\n  if (!useAnimationCssProperties) {\n    return {};\n  }\n  const {\n    translateX,\n    translateY,\n    translateZ,\n    rotateX,\n    rotateY,\n    rotateZ,\n    scaleX,\n    scaleY,\n    scaleZ,\n    skewX,\n    skewY,\n    ...otherCssProperties\n  } = useAnimationCssProperties;\n  const initialTransformValue = useAnimationCssProperties['transform'] || '';\n  // Now we just add values pased in shortcuts to transform property, do we want to replace it instead?\n  const finalTransformValue = `${initialTransformValue}${convertTranslateShortcuts(\n    translateX,\n    translateY,\n    translateZ\n  )}${convertRotateShortcuts(rotateX, rotateY, rotateZ)}${convertScaleShortcuts(\n    scaleX,\n    scaleY,\n    scaleZ\n  )}${convertSkewShortcuts(skewX, skewY)}`;\n  return {\n    ...otherCssProperties,\n    ...(finalTransformValue && { transform: finalTransformValue })\n  };\n}\n\n/**\n * Converts animation CSS properties into WAAPI keyframe properties.\n * Since keyframes have a difference between offset and cssOffset this collision is avoided here.\n *\n * @param useAnimationCssProperties This include transform shorthand props.\n * @returns WAAPI keyframe\n */\nexport function convertUseAnimationCssPropertiesToWAAPIKeyframe(\n  useAnimationCssProperties?: UseAnimationCssProperties\n) {\n  if (!useAnimationCssProperties) {\n    return {};\n  }\n  const { offset, ...otherCssProperties } =\n    convertUseAnimationCssPropertiesToRegularCSS(useAnimationCssProperties);\n  return {\n    ...otherCssProperties,\n    ...(offset && { cssOffset: offset })\n  };\n}\n","import { useRef, useLayoutEffect, useCallback } from 'preact/hooks';\nimport {\n  convertUseAnimationCssPropertiesToRegularCSS,\n  convertUseAnimationCssPropertiesToWAAPIKeyframe,\n  UseAnimationCssProperties\n} from './animationUtils';\n\nexport type UseAnimationConfig<V extends string, E extends HTMLElement> = {\n  animationStates: Partial<\n    Record<AnimationStateKey<V>, ((node: E) => AnimationConfig) | AnimationConfig>\n  >;\n  isAnimatedOnMount?: boolean;\n  onAnimationEnd?: ({ animationState }: { animationState: V }) => void;\n};\n\n// Used to filter simple states and ones that include previous state\ntype AnimationStateKey<PA extends string> = ExtractAnimationStates<PA | `${PA} => ${PA}`>;\n\n// Used to get previous and current states and do deeper typing\ntype ExtractAnimationStates<StateString extends string> =\n  StateString extends `${infer From} => ${infer To}`\n    ? KeyWithPreviousAndCurrentState<From, To>\n    : StateString;\n\n// Used to just allow keys with different previous and current states\ntype KeyWithPreviousAndCurrentState<PreviousState extends string, CurrentState extends string> = {\n  b: PreviousState;\n} extends { b: CurrentState }\n  ? never\n  : `${PreviousState} => ${CurrentState}`;\n\ntype AnimationConfig = {\n  from?: UseAnimationCssProperties;\n  to: UseAnimationCssProperties;\n  end?: UseAnimationCssProperties;\n  options?: AnimationOptions;\n};\n\ntype AnimationOptions = {\n  delay?: number;\n  duration?: number;\n  easing?:\n    | 'linear'\n    | 'ease'\n    | 'ease-in'\n    | 'ease-out'\n    | 'ease-in-out'\n    | [number, number, number, number];\n};\n\n// Used to exclude states that include => since this string is used to represent a transition from state to another.\ntype PermittedAnimationState<V extends string> = Exclude<V, `${string}=>${string}`>;\n\n/**\n * Hook to animate single components.\n * It allows n number of animation states.\n * @param animationState\n * @param animationConfig\n * @returns\n */\nexport function useAnimation<V extends string, E extends HTMLElement = HTMLElement>(\n  animationState: PermittedAnimationState<V>,\n  {\n    animationStates,\n    isAnimatedOnMount = false,\n    onAnimationEnd = () => {}\n  }: UseAnimationConfig<PermittedAnimationState<V>, E>\n) {\n  const didMountRef = useRef(false);\n  const nodeRef = useRef<E>(null);\n  const currentAnimationState = useRef<PermittedAnimationState<V>>();\n  const currentAnimation = useRef<Animation>();\n\n  // We don't allow changing animationStates. Ref to keep \"first run\" animation states.\n  const animationStatesRef =\n    useRef<UseAnimationConfig<PermittedAnimationState<V>, E>['animationStates']>(animationStates);\n\n  useLayoutEffect(() => {\n    stopAnimation(currentAnimation.current);\n\n    const animatedElement = nodeRef.current;\n    if (!animatedElement) {\n      return;\n    }\n\n    const previousAnimationState = currentAnimationState.current;\n    currentAnimationState.current = animationState;\n\n    const animationConfig = getConfig(\n      animationStatesRef.current,\n      animatedElement,\n      animationState,\n      previousAnimationState\n    );\n\n    if (!animationConfig) {\n      return;\n    }\n\n    if (!didMountRef.current) {\n      didMountRef.current = true;\n      if (!isAnimatedOnMount) {\n        setEndStyle(animatedElement, true, animationConfig);\n        return;\n      }\n    }\n\n    currentAnimation.current = startAnimation(\n      animationConfig,\n      animatedElement,\n      animationState,\n      onAnimationEnd\n    );\n  }, [animationState]);\n\n  /**\n   * Used to cancel current animation. When animation is canceled node style goes back to style of last finished animation\n   * @returns\n   */\n  const cancelCurrentAnimation = useCallback(() => {\n    const animation = currentAnimation.current;\n    if (animation?.playState === 'running') {\n      animation.currentTime = 0;\n      stopAnimation(animation);\n    }\n  }, []);\n\n  return { nodeRef, controller: { cancel: cancelCurrentAnimation } };\n}\n\n/**\n * Stops an animation.\n *\n * @param animation Animation that is going to be stopped.\n * @returns\n */\nfunction stopAnimation(animation?: Animation) {\n  if (animation) {\n    // TO DO: rollup-plugin-typescript seems to have an outdated Animation typing. That produces warnings while bulding.\n    // Update picked type to get rid of this casting.\n    (animation as any).commitStyles();\n    animation.cancel();\n  }\n}\n\n/**\n * Gets animation configuration.\n *\n * @param animationStates Set of animation configurations provided by the user.\n * @param animatedElement Element that is going to be styled.\n * @param animationState Current animation state.\n * @param previousAnimationState Previous animation state.\n * @returns AnimationConfig.\n */\nfunction getConfig<V extends string, E extends HTMLElement>(\n  animationStates: UseAnimationConfig<PermittedAnimationState<V>, E>['animationStates'],\n  animatedElement: E,\n  animationState: PermittedAnimationState<V>,\n  previousAnimationState?: PermittedAnimationState<V>\n) {\n  const currentAnimationStateConfig =\n    animationStates[\n      `${previousAnimationState} => ${animationState}` as keyof UseAnimationConfig<\n        PermittedAnimationState<V>,\n        E\n      >['animationStates']\n    ] ||\n    animationStates[\n      animationState as keyof UseAnimationConfig<PermittedAnimationState<V>, E>['animationStates']\n    ];\n\n  const animationConfig =\n    typeof currentAnimationStateConfig === 'function'\n      ? currentAnimationStateConfig(animatedElement)\n      : (currentAnimationStateConfig as AnimationConfig);\n\n  return animationConfig && Object.keys(animationConfig).length > 0 ? animationConfig : null;\n}\n\n/**\n * Starts an animation.\n *\n * @param animationConfig Animation configuration used by the animation.\n * @param animatedElement Element that is going to be styled.\n * @param animationState Current animation state.\n * @param onAnimationEnd Callback called once the animation is completed.\n * @returns Animation.\n */\nfunction startAnimation<V extends string, E extends HTMLElement>(\n  animationConfig: AnimationConfig,\n  animatedElement: E,\n  animationState: PermittedAnimationState<V>,\n  onAnimationEnd: UseAnimationConfig<PermittedAnimationState<V>, E>['onAnimationEnd']\n) {\n  const { delay, duration, easing } = animationConfig.options || {};\n\n  //Now, if user does not pass a value we override it by hand. We will use theming tools in future.\n  const animationOptions = {\n    delay: delay || 0,\n    duration: duration || 400,\n    easing: easing\n      ? typeof easing === 'string'\n        ? easing\n        : `cubic-bezier(${easing[0]}, ${easing[1]}, ${easing[2]}, ${easing[3]})`\n      : 'ease'\n  };\n\n  // WAAPI animation method. https://developer.mozilla.org/en-US/docs/Web/API/Element/animate\n  // TO DO: Check for required browser compatibility in case we need pollyfill.\n  // https://github.com/web-animations/web-animations-js/blob/dev/docs/support.md#browser-support\n  const startedAnimation = animatedElement.animate(\n    [\n      convertUseAnimationCssPropertiesToWAAPIKeyframe(animationConfig.from),\n      convertUseAnimationCssPropertiesToWAAPIKeyframe(animationConfig.to)\n    ],\n    { ...animationOptions, fill: 'forwards' }\n  );\n\n  startedAnimation.onfinish = () => {\n    //We commit styles to have an only source of truth.\n    stopAnimation(startedAnimation);\n\n    //In case user pass a final style after animation we do that here.\n    setEndStyle(animatedElement, false, animationConfig);\n\n    // On animationEnd is only called when animation actually finished. If an animation is interruped by other one\n    // the old one will not be finished. Do we want to have a callback for those cases?\n    onAnimationEnd?.({ animationState });\n  };\n\n  return startedAnimation;\n}\n\n/**\n * Sets element style.\n *\n * @param animatedElement Element that is going to be styled.\n * @param toAndEndStyle Represents which data will be used to set style. If set to true it uses \"to\" and \"endStyle\".\n * If set to false it uses just \"endStyle\".\n * @param animationConfig Style that is going to be set.\n */\nfunction setEndStyle<E extends HTMLElement>(\n  animatedElement: E,\n  toAndEndStyle: boolean,\n  animationConfig: AnimationConfig\n) {\n  const endStyle = toAndEndStyle\n    ? {\n        ...convertUseAnimationCssPropertiesToRegularCSS(animationConfig.to),\n        ...convertUseAnimationCssPropertiesToRegularCSS(animationConfig.end)\n      }\n    : convertUseAnimationCssPropertiesToRegularCSS(animationConfig.end);\n  for (const key in endStyle) {\n    //TO DO: Look for a better way to handle types.\n    (<any>animatedElement.style)[key] = endStyle[key as keyof typeof endStyle];\n  }\n}\n"],"names":["convertUseAnimationCssPropertiesToRegularCSS","useAnimationCssProperties","translateX","translateY","translateZ","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skewX","skewY","otherCssProperties","__rest","finalTransformValue","convertTranslateShortcuts","convertRotateShortcuts","convertScaleShortcuts","convertSkewShortcuts","Object","assign","transform","convertUseAnimationCssPropertiesToWAAPIKeyframe","_a","offset","cssOffset","stopAnimation","animation","commitStyles","cancel","setEndStyle","animatedElement","toAndEndStyle","animationConfig","endStyle","to","end","key","style","animationState","animationStates","isAnimatedOnMount","onAnimationEnd","didMountRef","useRef","nodeRef","currentAnimationState","currentAnimation","animationStatesRef","useLayoutEffect","current","previousAnimationState","currentAnimationStateConfig","keys","length","getConfig","delay","duration","easing","options","animationOptions","startedAnimation","animate","from","fill","onfinish","startAnimation","cancelCurrentAnimation","useCallback","playState","currentTime","controller"],"mappings":"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"}