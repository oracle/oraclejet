{"version":3,"file":"UNSAFE_useViewportIntersect.js","sources":["../../../src/hooks/UNSAFE_useViewportIntersect/useViewportIntersect.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useEffect } from 'preact/hooks';\n\n/**\n * Configuration about the viewport.  For now, it only has a field that returns the viewport element.\n */\nexport type ViewportConfig = {\n  scroller: () => HTMLElement | null;\n};\n\n/**\n * Hook to detect when the specified viewport element intersects elements that matches the specified css selector.\n * This is currently used by IncrementalLoader and VirtualizeViewportCollection.\n * Note options to IntersectionObsever such as rootMargin is not exposed now but can be added in the future as\n * needed.  (for example, with sticky footer we want to specify a wider margin so it won't trigger intersect)\n *\n * @param viewport an object which provide information about the viewport including what the viewport element is\n * @param onIntersect callback when an intersection with an element that has the specified target\n *                    style class occurred\n * @param targetSelector the CSS querySelector string used to identify the element where IntersectionObserver\n *                       observes\n * @param margin the top and bottom margin surrounding the viewport element in which the intersect detection takes into account.\n */\nexport function useViewportIntersect(\n  viewport: ViewportConfig,\n  margin: number = 0,\n  targetSelector: string,\n  onIntersect: () => void\n) {\n  // create an IntersectionObserver.  Note for now we are creating it on every render (instead of once\n  // on mounted) due to an issue we encountered where sometimes IntersectionObserver will not invoke\n  // the intersect callback (possibly due to the root might have been detach/re-attached?), see JET-49951.\n  useEffect(() => {\n    let observer: IntersectionObserver;\n    const root = viewport.scroller();\n    if (root) {\n      const options = {\n        // specifying null to cause ResizeObserver to use document viewport\n        root: root === document.body || root === document.documentElement ? null : root,\n        rootMargin: `${margin}px 0px`,\n        threshold: 0\n      };\n      observer = new IntersectionObserver((entries) => {\n        for (const entry of entries) {\n          if (entry.isIntersecting) {\n            onIntersect();\n            return;\n          }\n        }\n      }, options);\n\n      // start observing the element with certain class is scrolled into viewport\n      root.querySelectorAll(targetSelector).forEach((target) => {\n        observer.observe(target);\n      });\n    }\n\n    return () => {\n      observer?.disconnect();\n    };\n  });\n}\n"],"names":["viewport","margin","targetSelector","onIntersect","useEffect","observer","root","scroller","options","document","body","documentElement","rootMargin","threshold","IntersectionObserver","entries","entry","isIntersecting","querySelectorAll","forEach","target","observe","disconnect"],"mappings":"qFA6BM,SACJA,EACAC,EAAiB,EACjBC,EACAC,GAKAC,EAAAA,WAAU,KACR,IAAIC,EACJ,MAAMC,EAAON,EAASO,WACtB,GAAID,EAAM,CACR,MAAME,EAAU,CAEdF,KAAMA,IAASG,SAASC,MAAQJ,IAASG,SAASE,gBAAkB,KAAOL,EAC3EM,WAAe,GAAAX,UACfY,UAAW,GAEbR,EAAW,IAAIS,sBAAsBC,IACnC,IAAK,MAAMC,KAASD,EAClB,GAAIC,EAAMC,eAER,YADAd,MAIHK,GAGHF,EAAKY,iBAAiBhB,GAAgBiB,SAASC,IAC7Cf,EAASgB,QAAQD,MAIrB,MAAO,KACLf,MAAAA,GAAAA,EAAUiB"}